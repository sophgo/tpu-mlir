/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Op Definitions                                                             *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

#ifdef GET_OP_LIST
#undef GET_OP_LIST

::mlir::spirv::AccessChainOp,
::mlir::spirv::AddressOfOp,
::mlir::spirv::AtomicAndOp,
::mlir::spirv::AtomicCompareExchangeOp,
::mlir::spirv::AtomicCompareExchangeWeakOp,
::mlir::spirv::AtomicExchangeOp,
::mlir::spirv::AtomicFAddEXTOp,
::mlir::spirv::AtomicIAddOp,
::mlir::spirv::AtomicIDecrementOp,
::mlir::spirv::AtomicIIncrementOp,
::mlir::spirv::AtomicISubOp,
::mlir::spirv::AtomicOrOp,
::mlir::spirv::AtomicSMaxOp,
::mlir::spirv::AtomicSMinOp,
::mlir::spirv::AtomicUMaxOp,
::mlir::spirv::AtomicUMinOp,
::mlir::spirv::AtomicXorOp,
::mlir::spirv::BitCountOp,
::mlir::spirv::BitFieldInsertOp,
::mlir::spirv::BitFieldSExtractOp,
::mlir::spirv::BitFieldUExtractOp,
::mlir::spirv::BitReverseOp,
::mlir::spirv::BitcastOp,
::mlir::spirv::BitwiseAndOp,
::mlir::spirv::BitwiseOrOp,
::mlir::spirv::BitwiseXorOp,
::mlir::spirv::BranchConditionalOp,
::mlir::spirv::BranchOp,
::mlir::spirv::CompositeConstructOp,
::mlir::spirv::CompositeExtractOp,
::mlir::spirv::CompositeInsertOp,
::mlir::spirv::ConstantOp,
::mlir::spirv::ControlBarrierOp,
::mlir::spirv::ConvertFToSOp,
::mlir::spirv::ConvertFToUOp,
::mlir::spirv::ConvertSToFOp,
::mlir::spirv::ConvertUToFOp,
::mlir::spirv::CooperativeMatrixLengthNVOp,
::mlir::spirv::CooperativeMatrixLoadNVOp,
::mlir::spirv::CooperativeMatrixMulAddNVOp,
::mlir::spirv::CooperativeMatrixStoreNVOp,
::mlir::spirv::CopyMemoryOp,
::mlir::spirv::EntryPointOp,
::mlir::spirv::ExecutionModeOp,
::mlir::spirv::FAddOp,
::mlir::spirv::FConvertOp,
::mlir::spirv::FDivOp,
::mlir::spirv::FModOp,
::mlir::spirv::FMulOp,
::mlir::spirv::FNegateOp,
::mlir::spirv::FOrdEqualOp,
::mlir::spirv::FOrdGreaterThanEqualOp,
::mlir::spirv::FOrdGreaterThanOp,
::mlir::spirv::FOrdLessThanEqualOp,
::mlir::spirv::FOrdLessThanOp,
::mlir::spirv::FOrdNotEqualOp,
::mlir::spirv::FRemOp,
::mlir::spirv::FSubOp,
::mlir::spirv::FUnordEqualOp,
::mlir::spirv::FUnordGreaterThanEqualOp,
::mlir::spirv::FUnordGreaterThanOp,
::mlir::spirv::FUnordLessThanEqualOp,
::mlir::spirv::FUnordLessThanOp,
::mlir::spirv::FUnordNotEqualOp,
::mlir::spirv::FuncOp,
::mlir::spirv::FunctionCallOp,
::mlir::spirv::GLSLAcosOp,
::mlir::spirv::GLSLAsinOp,
::mlir::spirv::GLSLAtanOp,
::mlir::spirv::GLSLCeilOp,
::mlir::spirv::GLSLCosOp,
::mlir::spirv::GLSLCoshOp,
::mlir::spirv::GLSLExpOp,
::mlir::spirv::GLSLFAbsOp,
::mlir::spirv::GLSLFClampOp,
::mlir::spirv::GLSLFMaxOp,
::mlir::spirv::GLSLFMinOp,
::mlir::spirv::GLSLFMixOp,
::mlir::spirv::GLSLFSignOp,
::mlir::spirv::GLSLFloorOp,
::mlir::spirv::GLSLFmaOp,
::mlir::spirv::GLSLFrexpStructOp,
::mlir::spirv::GLSLInverseSqrtOp,
::mlir::spirv::GLSLLdexpOp,
::mlir::spirv::GLSLLogOp,
::mlir::spirv::GLSLPowOp,
::mlir::spirv::GLSLRoundOp,
::mlir::spirv::GLSLSAbsOp,
::mlir::spirv::GLSLSClampOp,
::mlir::spirv::GLSLSMaxOp,
::mlir::spirv::GLSLSMinOp,
::mlir::spirv::GLSLSSignOp,
::mlir::spirv::GLSLSinOp,
::mlir::spirv::GLSLSinhOp,
::mlir::spirv::GLSLSqrtOp,
::mlir::spirv::GLSLTanOp,
::mlir::spirv::GLSLTanhOp,
::mlir::spirv::GLSLUClampOp,
::mlir::spirv::GLSLUMaxOp,
::mlir::spirv::GLSLUMinOp,
::mlir::spirv::GlobalVariableOp,
::mlir::spirv::GroupBroadcastOp,
::mlir::spirv::GroupNonUniformBallotOp,
::mlir::spirv::GroupNonUniformBroadcastOp,
::mlir::spirv::GroupNonUniformElectOp,
::mlir::spirv::GroupNonUniformFAddOp,
::mlir::spirv::GroupNonUniformFMaxOp,
::mlir::spirv::GroupNonUniformFMinOp,
::mlir::spirv::GroupNonUniformFMulOp,
::mlir::spirv::GroupNonUniformIAddOp,
::mlir::spirv::GroupNonUniformIMulOp,
::mlir::spirv::GroupNonUniformSMaxOp,
::mlir::spirv::GroupNonUniformSMinOp,
::mlir::spirv::GroupNonUniformUMaxOp,
::mlir::spirv::GroupNonUniformUMinOp,
::mlir::spirv::IAddOp,
::mlir::spirv::IEqualOp,
::mlir::spirv::IMulOp,
::mlir::spirv::INotEqualOp,
::mlir::spirv::ISubOp,
::mlir::spirv::ImageDrefGatherOp,
::mlir::spirv::ImageOp,
::mlir::spirv::ImageQuerySizeOp,
::mlir::spirv::InBoundsPtrAccessChainOp,
::mlir::spirv::IsInfOp,
::mlir::spirv::IsNanOp,
::mlir::spirv::LoadOp,
::mlir::spirv::LogicalAndOp,
::mlir::spirv::LogicalEqualOp,
::mlir::spirv::LogicalNotEqualOp,
::mlir::spirv::LogicalNotOp,
::mlir::spirv::LogicalOrOp,
::mlir::spirv::LoopOp,
::mlir::spirv::MatrixTimesMatrixOp,
::mlir::spirv::MatrixTimesScalarOp,
::mlir::spirv::MemoryBarrierOp,
::mlir::spirv::MergeOp,
::mlir::spirv::ModuleOp,
::mlir::spirv::NotOp,
::mlir::spirv::OCLCeilOp,
::mlir::spirv::OCLCosOp,
::mlir::spirv::OCLErfOp,
::mlir::spirv::OCLExpOp,
::mlir::spirv::OCLFAbsOp,
::mlir::spirv::OCLFloorOp,
::mlir::spirv::OCLFmaOp,
::mlir::spirv::OCLLogOp,
::mlir::spirv::OCLPowOp,
::mlir::spirv::OCLRsqrtOp,
::mlir::spirv::OCLSAbsOp,
::mlir::spirv::OCLSinOp,
::mlir::spirv::OCLSqrtOp,
::mlir::spirv::OCLTanhOp,
::mlir::spirv::OrderedOp,
::mlir::spirv::PtrAccessChainOp,
::mlir::spirv::ReferenceOfOp,
::mlir::spirv::ReturnOp,
::mlir::spirv::ReturnValueOp,
::mlir::spirv::SConvertOp,
::mlir::spirv::SDivOp,
::mlir::spirv::SGreaterThanEqualOp,
::mlir::spirv::SGreaterThanOp,
::mlir::spirv::SLessThanEqualOp,
::mlir::spirv::SLessThanOp,
::mlir::spirv::SModOp,
::mlir::spirv::SNegateOp,
::mlir::spirv::SRemOp,
::mlir::spirv::SelectOp,
::mlir::spirv::SelectionOp,
::mlir::spirv::ShiftLeftLogicalOp,
::mlir::spirv::ShiftRightArithmeticOp,
::mlir::spirv::ShiftRightLogicalOp,
::mlir::spirv::SpecConstantCompositeOp,
::mlir::spirv::SpecConstantOp,
::mlir::spirv::SpecConstantOperationOp,
::mlir::spirv::StoreOp,
::mlir::spirv::SubgroupBallotKHROp,
::mlir::spirv::SubgroupBlockReadINTELOp,
::mlir::spirv::SubgroupBlockWriteINTELOp,
::mlir::spirv::TransposeOp,
::mlir::spirv::UConvertOp,
::mlir::spirv::UDivOp,
::mlir::spirv::UGreaterThanEqualOp,
::mlir::spirv::UGreaterThanOp,
::mlir::spirv::ULessThanEqualOp,
::mlir::spirv::ULessThanOp,
::mlir::spirv::UModOp,
::mlir::spirv::UndefOp,
::mlir::spirv::UnorderedOp,
::mlir::spirv::UnreachableOp,
::mlir::spirv::VariableOp,
::mlir::spirv::VectorExtractDynamicOp,
::mlir::spirv::VectorInsertDynamicOp,
::mlir::spirv::VectorShuffleOp,
::mlir::spirv::YieldOp
#endif  // GET_OP_LIST

#ifdef GET_OP_CLASSES
#undef GET_OP_CLASSES


//===----------------------------------------------------------------------===//
// Local Utility Method Definitions
//===----------------------------------------------------------------------===//

namespace mlir {
namespace spirv {

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_SPIRVOps0(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((type.isa<::mlir::spirv::PointerType>()))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be any SPIR-V pointer type, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_SPIRVOps1(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!(((type.isInteger(8))) || ((type.isInteger(16))) || ((type.isInteger(32))) || ((type.isInteger(64))))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be 8/16/32/64-bit integer, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_SPIRVOps2(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((((type.isInteger(8))) || ((type.isInteger(16))) || ((type.isInteger(32))) || ((type.isInteger(64)))) || (((type.isF16())) || ((type.isF32())) || ((type.isF64()))))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be 8/16/32/64-bit integer or 16/32/64-bit float, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_SPIRVOps3(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!(((type.isF16())) || ((type.isF32())) || ((type.isF64())))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be 16/32/64-bit float, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_SPIRVOps4(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((((type.isInteger(8))) || ((type.isInteger(16))) || ((type.isInteger(32))) || ((type.isInteger(64)))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isInteger(8))) || ((elementType.isInteger(16))) || ((elementType.isInteger(32))) || ((elementType.isInteger(64))); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be 8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4/8/16, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_SPIRVOps5(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!(((((((type.isInteger(8))) || ((type.isInteger(16))) || ((type.isInteger(32))) || ((type.isInteger(64)))) || (((type.isF16())) || ((type.isF32())) || ((type.isF64())))) || ((type.isSignlessInteger(1)))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isSignlessInteger(1))) || (((elementType.isInteger(8))) || ((elementType.isInteger(16))) || ((elementType.isInteger(32))) || ((elementType.isInteger(64)))) || (((elementType.isF16())) || ((elementType.isF32())) || ((elementType.isF64()))); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16)))))) || ((type.isa<::mlir::spirv::PointerType>())))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be 8/16/32/64-bit integer or 16/32/64-bit float or bool or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float values of length 2/3/4/8/16 or any SPIR-V pointer type, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_SPIRVOps6(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((type.isSignlessInteger(1)))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be bool, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_SPIRVOps7(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!(((type.isa<::mlir::NoneType>())) || ((type.isSignlessInteger(1))) || (((type.isInteger(8))) || ((type.isInteger(16))) || ((type.isInteger(32))) || ((type.isInteger(64)))) || (((type.isF16())) || ((type.isF32())) || ((type.isF64()))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isSignlessInteger(1))) || (((elementType.isInteger(8))) || ((elementType.isInteger(16))) || ((elementType.isInteger(32))) || ((elementType.isInteger(64)))) || (((elementType.isF16())) || ((elementType.isF32())) || ((elementType.isF64()))); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))) || ((type.isa<::mlir::spirv::PointerType>())) || ((type.isa<::mlir::spirv::ArrayType>())) || ((type.isa<::mlir::spirv::RuntimeArrayType>())) || ((type.isa<::mlir::spirv::StructType>())) || ((type.isa<::mlir::spirv::CooperativeMatrixNVType>())) || ((type.isa<::mlir::spirv::MatrixType>())) || ((type.isa<::mlir::spirv::SampledImageType>())))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float values of length 2/3/4/8/16 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V sampled image type, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_SPIRVOps8(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isSignlessInteger(1))) || (((elementType.isInteger(8))) || ((elementType.isInteger(16))) || ((elementType.isInteger(32))) || ((elementType.isInteger(64)))) || (((elementType.isF16())) || ((elementType.isF32())) || ((elementType.isF64()))); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))) || ((type.isa<::mlir::spirv::ArrayType>())) || ((type.isa<::mlir::spirv::RuntimeArrayType>())) || ((type.isa<::mlir::spirv::StructType>())) || ((type.isa<::mlir::spirv::CooperativeMatrixNVType>())) || ((type.isa<::mlir::spirv::MatrixType>())))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float values of length 2/3/4/8/16 or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_SPIRVOps9(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((((type.isF16())) || ((type.isF32())) || ((type.isF64()))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isF16())) || ((elementType.isF32())) || ((elementType.isF64())); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))) || (((type.isa<::mlir::spirv::CooperativeMatrixNVType>())) && (((type.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF16())) || ((type.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF32())) || ((type.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isF64())))))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be 16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4/8/16 or Cooperative Matrix of 16/32/64-bit float values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_SPIRVOps10(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((((type.isInteger(8))) || ((type.isInteger(16))) || ((type.isInteger(32))) || ((type.isInteger(64)))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isInteger(8))) || ((elementType.isInteger(16))) || ((elementType.isInteger(32))) || ((elementType.isInteger(64))); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))) || (((type.isa<::mlir::spirv::CooperativeMatrixNVType>())) && (((type.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(8))) || ((type.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(16))) || ((type.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(32))) || ((type.cast<::mlir::spirv::CooperativeMatrixNVType>().getElementType().isInteger(64))))))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be 8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4/8/16 or Cooperative Matrix of 8/16/32/64-bit integer values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_SPIRVOps11(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((type.isSignlessInteger(32)))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be Int32, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_SPIRVOps12(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((type.isa<::mlir::spirv::CooperativeMatrixNVType>()))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be any SPIR-V cooperative matrix type, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_SPIRVOps13(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((((type.isF16())) || ((type.isF32())) || ((type.isF64()))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isF16())) || ((elementType.isF32())) || ((elementType.isF64())); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be 16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4/8/16, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_SPIRVOps14(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!(((type.isSignlessInteger(1))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return (elementType.isSignlessInteger(1)); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be bool or vector of bool values of length 2/3/4/8/16, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_SPIRVOps15(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((((type.isF16())) || ((type.isF32()))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isF16())) || ((elementType.isF32())); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be 16/32-bit float or vector of 16/32-bit float values of length 2/3/4/8/16, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_SPIRVOps16(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((type.isa<::mlir::spirv::StructType>()))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be any SPIR-V struct type, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_SPIRVOps17(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((((type.isSignedInteger(8))) || ((type.isSignedInteger(16))) || ((type.isSignedInteger(32))) || ((type.isSignedInteger(64)))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isSignedInteger(8))) || ((elementType.isSignedInteger(16))) || ((elementType.isSignedInteger(32))) || ((elementType.isSignedInteger(64))); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be 8/16/32/64-bit signed integer or vector of 8/16/32/64-bit signed integer values of length 2/3/4/8/16, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_SPIRVOps18(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!(((((type.isSignlessInteger(8))) || ((type.isUnsignedInteger(8)))) || (((type.isSignlessInteger(16))) || ((type.isUnsignedInteger(16)))) || (((type.isSignlessInteger(32))) || ((type.isUnsignedInteger(32)))) || (((type.isSignlessInteger(64))) || ((type.isUnsignedInteger(64))))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return (((elementType.isSignlessInteger(8))) || ((elementType.isUnsignedInteger(8)))) || (((elementType.isSignlessInteger(16))) || ((elementType.isUnsignedInteger(16)))) || (((elementType.isSignlessInteger(32))) || ((elementType.isUnsignedInteger(32)))) || (((elementType.isSignlessInteger(64))) || ((elementType.isUnsignedInteger(64)))); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be 8/16/32/64-bit signless/unsigned integer or vector of 8/16/32/64-bit signless/unsigned integer values of length 2/3/4/8/16, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_SPIRVOps19(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!(((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return (((elementType.isSignlessInteger(8))) || ((elementType.isUnsignedInteger(8)))) || (((elementType.isSignlessInteger(16))) || ((elementType.isUnsignedInteger(16)))) || (((elementType.isSignlessInteger(32))) || ((elementType.isUnsignedInteger(32)))) || (((elementType.isSignlessInteger(64))) || ((elementType.isUnsignedInteger(64)))); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4))))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be vector of 8/16/32/64-bit signless/unsigned integer values of length 4, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_SPIRVOps20(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((type.isa<::mlir::spirv::SampledImageType>()))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be any SPIR-V sampled image type, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_SPIRVOps21(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!(((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isSignlessInteger(1))) || (((elementType.isInteger(8))) || ((elementType.isInteger(16))) || ((elementType.isInteger(32))) || ((elementType.isInteger(64)))) || (((elementType.isF16())) || ((elementType.isF32())) || ((elementType.isF64()))); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16)))))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float values of length 2/3/4/8/16, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_SPIRVOps22(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((type.isa<::mlir::spirv::ImageType>()))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be any SPIR-V image type, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_SPIRVOps23(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((type.isa<::mlir::spirv::MatrixType>()))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be any SPIR-V matrix type, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_SPIRVOps24(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((((((type.isInteger(8))) || ((type.isInteger(16))) || ((type.isInteger(32))) || ((type.isInteger(64)))) || (((type.isF16())) || ((type.isF32())) || ((type.isF64())))) || ((type.isSignlessInteger(1)))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isSignlessInteger(1))) || (((elementType.isInteger(8))) || ((elementType.isInteger(16))) || ((elementType.isInteger(32))) || ((elementType.isInteger(64)))) || (((elementType.isF16())) || ((elementType.isF32())) || ((elementType.isF64()))); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))) || ((type.isa<::mlir::spirv::PointerType>())))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be 8/16/32/64-bit integer or 16/32/64-bit float or bool or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float values of length 2/3/4/8/16 or any SPIR-V pointer type, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_SPIRVOps25(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((true))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be any type, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_SPIRVOps26(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!(((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return (elementType.isInteger(32)); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4))))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be vector of 32-bit integer values of length 4, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_SPIRVOps27(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!(((((type.isInteger(8))) || ((type.isInteger(16))) || ((type.isInteger(32))) || ((type.isInteger(64)))) || (((type.isF16())) || ((type.isF32())) || ((type.isF64())))) || ((type.isSignlessInteger(1))))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be 8/16/32/64-bit integer or 16/32/64-bit float or bool, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_attr_constraint_SPIRVOps0(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  if (attr && !((attr.isa<::mlir::FlatSymbolRefAttr>()))) {
    return op->emitOpError("attribute '") << attrName
        << "' failed to satisfy constraint: flat symbol reference attribute";
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_attr_constraint_SPIRVOps1(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  if (attr && !((((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(attr.cast<IntegerAttr>().getValue().getZExtValue()).hasValue())))) {
    return op->emitOpError("attribute '") << attrName
        << "' failed to satisfy constraint: valid SPIR-V Scope";
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_attr_constraint_SPIRVOps2(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  if (attr && !((((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics(attr.cast<IntegerAttr>().getValue().getZExtValue()).hasValue())))) {
    return op->emitOpError("attribute '") << attrName
        << "' failed to satisfy constraint: valid SPIR-V MemorySemantics";
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_attr_constraint_SPIRVOps3(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  if (attr && !(((attr.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(attr.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32))); })))) {
    return op->emitOpError("attribute '") << attrName
        << "' failed to satisfy constraint: 32-bit integer array attribute";
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_attr_constraint_SPIRVOps4(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  if (attr && !((true))) {
    return op->emitOpError("attribute '") << attrName
        << "' failed to satisfy constraint: any attribute";
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_attr_constraint_SPIRVOps5(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  if (attr && !(((attr.isa<::mlir::TypeAttr>())) && ((attr.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())))) {
    return op->emitOpError("attribute '") << attrName
        << "' failed to satisfy constraint: any type attribute";
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_attr_constraint_SPIRVOps6(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  if (attr && !((((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemoryAccess(attr.cast<IntegerAttr>().getValue().getZExtValue()).hasValue())))) {
    return op->emitOpError("attribute '") << attrName
        << "' failed to satisfy constraint: valid SPIR-V MemoryAccess";
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_attr_constraint_SPIRVOps7(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  if (attr && !(((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32))))) {
    return op->emitOpError("attribute '") << attrName
        << "' failed to satisfy constraint: 32-bit signless integer attribute";
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_attr_constraint_SPIRVOps8(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  if (attr && !((((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeExecutionModel(attr.cast<IntegerAttr>().getValue().getZExtValue()).hasValue())))) {
    return op->emitOpError("attribute '") << attrName
        << "' failed to satisfy constraint: valid SPIR-V ExecutionModel";
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_attr_constraint_SPIRVOps9(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  if (attr && !(((attr.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(attr.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return (attr.isa<::mlir::SymbolRefAttr>()); })))) {
    return op->emitOpError("attribute '") << attrName
        << "' failed to satisfy constraint: symbol ref array attribute";
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_attr_constraint_SPIRVOps10(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  if (attr && !((((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeExecutionMode(attr.cast<IntegerAttr>().getValue().getZExtValue()).hasValue())))) {
    return op->emitOpError("attribute '") << attrName
        << "' failed to satisfy constraint: valid SPIR-V ExecutionMode";
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_attr_constraint_SPIRVOps11(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  if (attr && !((attr.isa<::mlir::StringAttr>()))) {
    return op->emitOpError("attribute '") << attrName
        << "' failed to satisfy constraint: string attribute";
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_attr_constraint_SPIRVOps12(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  if (attr && !((((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeFunctionControl(attr.cast<IntegerAttr>().getValue().getZExtValue()).hasValue())))) {
    return op->emitOpError("attribute '") << attrName
        << "' failed to satisfy constraint: valid SPIR-V FunctionControl";
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_attr_constraint_SPIRVOps13(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  if (attr && !((((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeGroupOperation(attr.cast<IntegerAttr>().getValue().getZExtValue()).hasValue())))) {
    return op->emitOpError("attribute '") << attrName
        << "' failed to satisfy constraint: valid SPIR-V GroupOperation";
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_attr_constraint_SPIRVOps14(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  if (attr && !((((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeImageOperands(attr.cast<IntegerAttr>().getValue().getZExtValue()).hasValue())))) {
    return op->emitOpError("attribute '") << attrName
        << "' failed to satisfy constraint: valid SPIR-V ImageOperands";
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_attr_constraint_SPIRVOps15(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  if (attr && !((((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeLoopControl(attr.cast<IntegerAttr>().getValue().getZExtValue()).hasValue())))) {
    return op->emitOpError("attribute '") << attrName
        << "' failed to satisfy constraint: valid SPIR-V LoopControl";
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_attr_constraint_SPIRVOps16(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  if (attr && !((((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeAddressingModel(attr.cast<IntegerAttr>().getValue().getZExtValue()).hasValue())))) {
    return op->emitOpError("attribute '") << attrName
        << "' failed to satisfy constraint: valid SPIR-V AddressingModel";
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_attr_constraint_SPIRVOps17(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  if (attr && !((((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemoryModel(attr.cast<IntegerAttr>().getValue().getZExtValue()).hasValue())))) {
    return op->emitOpError("attribute '") << attrName
        << "' failed to satisfy constraint: valid SPIR-V MemoryModel";
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_attr_constraint_SPIRVOps18(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  if (attr && !((attr.isa<::mlir::spirv::VerCapExtAttr>()))) {
    return op->emitOpError("attribute '") << attrName
        << "' failed to satisfy constraint: version-capability-extension attribute";
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_attr_constraint_SPIRVOps19(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  if (attr && !((((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeSelectionControl(attr.cast<IntegerAttr>().getValue().getZExtValue()).hasValue())))) {
    return op->emitOpError("attribute '") << attrName
        << "' failed to satisfy constraint: valid SPIR-V SelectionControl";
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_attr_constraint_SPIRVOps20(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  if (attr && !((((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeStorageClass(attr.cast<IntegerAttr>().getValue().getZExtValue()).hasValue())))) {
    return op->emitOpError("attribute '") << attrName
        << "' failed to satisfy constraint: valid SPIR-V StorageClass";
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_region_constraint_SPIRVOps0(
    ::mlir::Operation *op, ::mlir::Region &region, ::llvm::StringRef regionName,
    unsigned regionIndex) {
  if (!((true))) {
    return op->emitOpError("region #") << regionIndex
        << (regionName.empty() ? " " : " ('" + regionName + "') ")
        << "failed to verify constraint: any region";
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_region_constraint_SPIRVOps1(
    ::mlir::Operation *op, ::mlir::Region &region, ::llvm::StringRef regionName,
    unsigned regionIndex) {
  if (!((::llvm::hasNItems(region, 1)))) {
    return op->emitOpError("region #") << regionIndex
        << (regionName.empty() ? " " : " ('" + regionName + "') ")
        << "failed to verify constraint: region with 1 blocks";
  }
  return ::mlir::success();
}
} // namespace spirv
} // namespace mlir
namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::AccessChainOp definitions
//===----------------------------------------------------------------------===//

AccessChainOpAdaptor::AccessChainOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

AccessChainOpAdaptor::AccessChainOpAdaptor(AccessChainOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange AccessChainOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AccessChainOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange AccessChainOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AccessChainOpAdaptor::base_ptr() {
  return *getODSOperands(0).begin();
}

::mlir::ValueRange AccessChainOpAdaptor::indices() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr AccessChainOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult AccessChainOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> AccessChainOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range AccessChainOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AccessChainOp::base_ptr() {
  return *getODSOperands(0).begin();
}

::mlir::Operation::operand_range AccessChainOp::indices() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange AccessChainOp::base_ptrMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange AccessChainOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> AccessChainOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AccessChainOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AccessChainOp::component_ptr() {
  return *getODSResults(0).begin();
}

void AccessChainOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type component_ptr, ::mlir::Value base_ptr, ::mlir::ValueRange indices) {
  odsState.addOperands(base_ptr);
  odsState.addOperands(indices);
  odsState.addTypes(component_ptr);
}

void AccessChainOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value base_ptr, ::mlir::ValueRange indices) {
  odsState.addOperands(base_ptr);
  odsState.addOperands(indices);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AccessChainOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AccessChainOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps0(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps0(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult AccessChainOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

void AccessChainOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::AccessChainOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::AddressOfOp definitions
//===----------------------------------------------------------------------===//

AddressOfOpAdaptor::AddressOfOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

AddressOfOpAdaptor::AddressOfOpAdaptor(AddressOfOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange AddressOfOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AddressOfOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AddressOfOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr AddressOfOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::FlatSymbolRefAttr AddressOfOpAdaptor::variableAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FlatSymbolRefAttr attr = odsAttrs.get("variable").cast<::mlir::FlatSymbolRefAttr>();
  return attr;
}

::llvm::StringRef AddressOfOpAdaptor::variable() {
  auto attr = variableAttr();
  return attr.getValue();
}

::mlir::LogicalResult AddressOfOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_variable = odsAttrs.get("variable");
    if (!tblgen_variable)
      return emitError(loc, "'spv.mlir.addressof' op ""requires attribute 'variable'");

    if (tblgen_variable && !((tblgen_variable.isa<::mlir::FlatSymbolRefAttr>())))
      return emitError(loc, "'spv.mlir.addressof' op ""attribute 'variable' failed to satisfy constraint: flat symbol reference attribute");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> AddressOfOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AddressOfOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> AddressOfOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AddressOfOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AddressOfOp::pointer() {
  return *getODSResults(0).begin();
}

::mlir::FlatSymbolRefAttr AddressOfOp::variableAttr() {
  return (*this)->getAttr(variableAttrName()).cast<::mlir::FlatSymbolRefAttr>();
}

::llvm::StringRef AddressOfOp::variable() {
  auto attr = variableAttr();
  return attr.getValue();
}

void AddressOfOp::variableAttr(::mlir::FlatSymbolRefAttr attr) {
  (*this)->setAttr(variableAttrName(), attr);
}

void AddressOfOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type pointer, ::mlir::FlatSymbolRefAttr variable) {
  odsState.addAttribute(variableAttrName(odsState.name), variable);
  odsState.addTypes(pointer);
}

void AddressOfOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::FlatSymbolRefAttr variable) {
  odsState.addAttribute(variableAttrName(odsState.name), variable);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AddressOfOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type pointer, ::llvm::StringRef variable) {
  odsState.addAttribute(variableAttrName(odsState.name), ::mlir::SymbolRefAttr::get(odsBuilder.getContext(), variable));
  odsState.addTypes(pointer);
}

void AddressOfOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef variable) {
  odsState.addAttribute(variableAttrName(odsState.name), ::mlir::SymbolRefAttr::get(odsBuilder.getContext(), variable));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AddressOfOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AddressOfOp::verifyInvariantsImpl() {
  {
    auto tblgen_variable = (*this)->getAttr(variableAttrName());
    if (!tblgen_variable)
      return emitOpError("requires attribute 'variable'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps0(*this, tblgen_variable, "variable")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps0(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((isNestedInFunctionOpInterface((*this->getOperation()).getParentOp()))))
    return emitOpError("failed to verify that op must appear in a function-like op's block");
  return ::mlir::success();
}

::mlir::LogicalResult AddressOfOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult AddressOfOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::FlatSymbolRefAttr variableAttr;
  ::mlir::Type pointerRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> pointerTypes(pointerRawTypes);

  if (parser.parseCustomAttributeWithFallback(variableAttr, parser.getBuilder().getType<::mlir::NoneType>(), "variable",
          result.attributes)) {
    return ::mlir::failure();
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    pointerRawTypes[0] = type;
  }
  result.addTypes(pointerTypes);
  return ::mlir::success();
}

void AddressOfOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter.printAttributeWithoutType(variableAttr());
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"variable"});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = pointer().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void AddressOfOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::AddressOfOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::AtomicAndOp definitions
//===----------------------------------------------------------------------===//

AtomicAndOpAdaptor::AtomicAndOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

AtomicAndOpAdaptor::AtomicAndOpAdaptor(AtomicAndOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange AtomicAndOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AtomicAndOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AtomicAndOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicAndOpAdaptor::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::Value AtomicAndOpAdaptor::value() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr AtomicAndOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ScopeAttr AtomicAndOpAdaptor::memory_scopeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ScopeAttr attr = odsAttrs.get("memory_scope").cast<::mlir::spirv::ScopeAttr>();
  return attr;
}

::mlir::spirv::Scope AtomicAndOpAdaptor::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicAndOpAdaptor::semanticsAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::MemorySemanticsAttr attr = odsAttrs.get("semantics").cast<::mlir::spirv::MemorySemanticsAttr>();
  return attr;
}

::mlir::spirv::MemorySemantics AtomicAndOpAdaptor::semantics() {
  auto attr = semanticsAttr();
  return attr.getValue();
}

::mlir::LogicalResult AtomicAndOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_memory_scope = odsAttrs.get("memory_scope");
    if (!tblgen_memory_scope)
      return emitError(loc, "'spv.AtomicAnd' op ""requires attribute 'memory_scope'");

    if (tblgen_memory_scope && !((((tblgen_memory_scope.isa<::mlir::IntegerAttr>())) && ((tblgen_memory_scope.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(tblgen_memory_scope.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.AtomicAnd' op ""attribute 'memory_scope' failed to satisfy constraint: valid SPIR-V Scope");
  }
  {
    auto tblgen_semantics = odsAttrs.get("semantics");
    if (!tblgen_semantics)
      return emitError(loc, "'spv.AtomicAnd' op ""requires attribute 'semantics'");

    if (tblgen_semantics && !((((tblgen_semantics.isa<::mlir::IntegerAttr>())) && ((tblgen_semantics.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics(tblgen_semantics.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.AtomicAnd' op ""attribute 'semantics' failed to satisfy constraint: valid SPIR-V MemorySemantics");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> AtomicAndOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AtomicAndOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicAndOp::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::Value AtomicAndOp::value() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange AtomicAndOp::pointerMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange AtomicAndOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> AtomicAndOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AtomicAndOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicAndOp::result() {
  return *getODSResults(0).begin();
}

::mlir::spirv::ScopeAttr AtomicAndOp::memory_scopeAttr() {
  return (*this)->getAttr(memory_scopeAttrName()).cast<::mlir::spirv::ScopeAttr>();
}

::mlir::spirv::Scope AtomicAndOp::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicAndOp::semanticsAttr() {
  return (*this)->getAttr(semanticsAttrName()).cast<::mlir::spirv::MemorySemanticsAttr>();
}

::mlir::spirv::MemorySemantics AtomicAndOp::semantics() {
  auto attr = semanticsAttr();
  return attr.getValue();
}

void AtomicAndOp::memory_scopeAttr(::mlir::spirv::ScopeAttr attr) {
  (*this)->setAttr(memory_scopeAttrName(), attr);
}

void AtomicAndOp::semanticsAttr(::mlir::spirv::MemorySemanticsAttr attr) {
  (*this)->setAttr(semanticsAttrName(), attr);
}

void AtomicAndOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value pointer, ::mlir::spirv::Scope scope, ::mlir::spirv::MemorySemantics memory, Value value) {
build(odsBuilder, odsState, value.getType(), pointer, scope, memory, value);
}

void AtomicAndOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pointer, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(semanticsAttrName(odsState.name), semantics);
  odsState.addTypes(result);
}

void AtomicAndOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pointer, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(semanticsAttrName(odsState.name), semantics);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicAndOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pointer, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), semantics));
  odsState.addTypes(result);
}

void AtomicAndOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pointer, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), semantics));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicAndOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AtomicAndOp::verifyInvariantsImpl() {
  {
    auto tblgen_memory_scope = (*this)->getAttr(memory_scopeAttrName());
    if (!tblgen_memory_scope)
      return emitOpError("requires attribute 'memory_scope'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps1(*this, tblgen_memory_scope, "memory_scope")))
      return ::mlir::failure();
  }
  {
    auto tblgen_semantics = (*this)->getAttr(semanticsAttrName());
    if (!tblgen_semantics)
      return emitOpError("requires attribute 'semantics'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps2(*this, tblgen_semantics, "semantics")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps0(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult AtomicAndOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::AtomicAndOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::AtomicCompareExchangeOp definitions
//===----------------------------------------------------------------------===//

AtomicCompareExchangeOpAdaptor::AtomicCompareExchangeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

AtomicCompareExchangeOpAdaptor::AtomicCompareExchangeOpAdaptor(AtomicCompareExchangeOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange AtomicCompareExchangeOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AtomicCompareExchangeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AtomicCompareExchangeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicCompareExchangeOpAdaptor::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::Value AtomicCompareExchangeOpAdaptor::value() {
  return *getODSOperands(1).begin();
}

::mlir::Value AtomicCompareExchangeOpAdaptor::comparator() {
  return *getODSOperands(2).begin();
}

::mlir::DictionaryAttr AtomicCompareExchangeOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ScopeAttr AtomicCompareExchangeOpAdaptor::memory_scopeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ScopeAttr attr = odsAttrs.get("memory_scope").cast<::mlir::spirv::ScopeAttr>();
  return attr;
}

::mlir::spirv::Scope AtomicCompareExchangeOpAdaptor::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicCompareExchangeOpAdaptor::equal_semanticsAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::MemorySemanticsAttr attr = odsAttrs.get("equal_semantics").cast<::mlir::spirv::MemorySemanticsAttr>();
  return attr;
}

::mlir::spirv::MemorySemantics AtomicCompareExchangeOpAdaptor::equal_semantics() {
  auto attr = equal_semanticsAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicCompareExchangeOpAdaptor::unequal_semanticsAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::MemorySemanticsAttr attr = odsAttrs.get("unequal_semantics").cast<::mlir::spirv::MemorySemanticsAttr>();
  return attr;
}

::mlir::spirv::MemorySemantics AtomicCompareExchangeOpAdaptor::unequal_semantics() {
  auto attr = unequal_semanticsAttr();
  return attr.getValue();
}

::mlir::LogicalResult AtomicCompareExchangeOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_memory_scope = odsAttrs.get("memory_scope");
    if (!tblgen_memory_scope)
      return emitError(loc, "'spv.AtomicCompareExchange' op ""requires attribute 'memory_scope'");

    if (tblgen_memory_scope && !((((tblgen_memory_scope.isa<::mlir::IntegerAttr>())) && ((tblgen_memory_scope.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(tblgen_memory_scope.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.AtomicCompareExchange' op ""attribute 'memory_scope' failed to satisfy constraint: valid SPIR-V Scope");
  }
  {
    auto tblgen_equal_semantics = odsAttrs.get("equal_semantics");
    if (!tblgen_equal_semantics)
      return emitError(loc, "'spv.AtomicCompareExchange' op ""requires attribute 'equal_semantics'");

    if (tblgen_equal_semantics && !((((tblgen_equal_semantics.isa<::mlir::IntegerAttr>())) && ((tblgen_equal_semantics.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics(tblgen_equal_semantics.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.AtomicCompareExchange' op ""attribute 'equal_semantics' failed to satisfy constraint: valid SPIR-V MemorySemantics");
  }
  {
    auto tblgen_unequal_semantics = odsAttrs.get("unequal_semantics");
    if (!tblgen_unequal_semantics)
      return emitError(loc, "'spv.AtomicCompareExchange' op ""requires attribute 'unequal_semantics'");

    if (tblgen_unequal_semantics && !((((tblgen_unequal_semantics.isa<::mlir::IntegerAttr>())) && ((tblgen_unequal_semantics.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics(tblgen_unequal_semantics.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.AtomicCompareExchange' op ""attribute 'unequal_semantics' failed to satisfy constraint: valid SPIR-V MemorySemantics");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> AtomicCompareExchangeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AtomicCompareExchangeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicCompareExchangeOp::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::Value AtomicCompareExchangeOp::value() {
  return *getODSOperands(1).begin();
}

::mlir::Value AtomicCompareExchangeOp::comparator() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange AtomicCompareExchangeOp::pointerMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange AtomicCompareExchangeOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange AtomicCompareExchangeOp::comparatorMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> AtomicCompareExchangeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AtomicCompareExchangeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicCompareExchangeOp::result() {
  return *getODSResults(0).begin();
}

::mlir::spirv::ScopeAttr AtomicCompareExchangeOp::memory_scopeAttr() {
  return (*this)->getAttr(memory_scopeAttrName()).cast<::mlir::spirv::ScopeAttr>();
}

::mlir::spirv::Scope AtomicCompareExchangeOp::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicCompareExchangeOp::equal_semanticsAttr() {
  return (*this)->getAttr(equal_semanticsAttrName()).cast<::mlir::spirv::MemorySemanticsAttr>();
}

::mlir::spirv::MemorySemantics AtomicCompareExchangeOp::equal_semantics() {
  auto attr = equal_semanticsAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicCompareExchangeOp::unequal_semanticsAttr() {
  return (*this)->getAttr(unequal_semanticsAttrName()).cast<::mlir::spirv::MemorySemanticsAttr>();
}

::mlir::spirv::MemorySemantics AtomicCompareExchangeOp::unequal_semantics() {
  auto attr = unequal_semanticsAttr();
  return attr.getValue();
}

void AtomicCompareExchangeOp::memory_scopeAttr(::mlir::spirv::ScopeAttr attr) {
  (*this)->setAttr(memory_scopeAttrName(), attr);
}

void AtomicCompareExchangeOp::equal_semanticsAttr(::mlir::spirv::MemorySemanticsAttr attr) {
  (*this)->setAttr(equal_semanticsAttrName(), attr);
}

void AtomicCompareExchangeOp::unequal_semanticsAttr(::mlir::spirv::MemorySemanticsAttr attr) {
  (*this)->setAttr(unequal_semanticsAttrName(), attr);
}

void AtomicCompareExchangeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pointer, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr equal_semantics, ::mlir::spirv::MemorySemanticsAttr unequal_semantics, ::mlir::Value value, ::mlir::Value comparator) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addOperands(comparator);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(equal_semanticsAttrName(odsState.name), equal_semantics);
  odsState.addAttribute(unequal_semanticsAttrName(odsState.name), unequal_semantics);
  odsState.addTypes(result);
}

void AtomicCompareExchangeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pointer, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr equal_semantics, ::mlir::spirv::MemorySemanticsAttr unequal_semantics, ::mlir::Value value, ::mlir::Value comparator) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addOperands(comparator);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(equal_semanticsAttrName(odsState.name), equal_semantics);
  odsState.addAttribute(unequal_semanticsAttrName(odsState.name), unequal_semantics);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicCompareExchangeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pointer, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics equal_semantics, ::mlir::spirv::MemorySemantics unequal_semantics, ::mlir::Value value, ::mlir::Value comparator) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addOperands(comparator);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(equal_semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), equal_semantics));
  odsState.addAttribute(unequal_semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), unequal_semantics));
  odsState.addTypes(result);
}

void AtomicCompareExchangeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pointer, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics equal_semantics, ::mlir::spirv::MemorySemantics unequal_semantics, ::mlir::Value value, ::mlir::Value comparator) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addOperands(comparator);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(equal_semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), equal_semantics));
  odsState.addAttribute(unequal_semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), unequal_semantics));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicCompareExchangeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AtomicCompareExchangeOp::verifyInvariantsImpl() {
  {
    auto tblgen_memory_scope = (*this)->getAttr(memory_scopeAttrName());
    if (!tblgen_memory_scope)
      return emitOpError("requires attribute 'memory_scope'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps1(*this, tblgen_memory_scope, "memory_scope")))
      return ::mlir::failure();
  }
  {
    auto tblgen_equal_semantics = (*this)->getAttr(equal_semanticsAttrName());
    if (!tblgen_equal_semantics)
      return emitOpError("requires attribute 'equal_semantics'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps2(*this, tblgen_equal_semantics, "equal_semantics")))
      return ::mlir::failure();
  }
  {
    auto tblgen_unequal_semantics = (*this)->getAttr(unequal_semanticsAttrName());
    if (!tblgen_unequal_semantics)
      return emitOpError("requires attribute 'unequal_semantics'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps2(*this, tblgen_unequal_semantics, "unequal_semantics")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps0(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult AtomicCompareExchangeOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::AtomicCompareExchangeOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::AtomicCompareExchangeWeakOp definitions
//===----------------------------------------------------------------------===//

AtomicCompareExchangeWeakOpAdaptor::AtomicCompareExchangeWeakOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

AtomicCompareExchangeWeakOpAdaptor::AtomicCompareExchangeWeakOpAdaptor(AtomicCompareExchangeWeakOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange AtomicCompareExchangeWeakOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AtomicCompareExchangeWeakOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AtomicCompareExchangeWeakOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicCompareExchangeWeakOpAdaptor::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::Value AtomicCompareExchangeWeakOpAdaptor::value() {
  return *getODSOperands(1).begin();
}

::mlir::Value AtomicCompareExchangeWeakOpAdaptor::comparator() {
  return *getODSOperands(2).begin();
}

::mlir::DictionaryAttr AtomicCompareExchangeWeakOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ScopeAttr AtomicCompareExchangeWeakOpAdaptor::memory_scopeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ScopeAttr attr = odsAttrs.get("memory_scope").cast<::mlir::spirv::ScopeAttr>();
  return attr;
}

::mlir::spirv::Scope AtomicCompareExchangeWeakOpAdaptor::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicCompareExchangeWeakOpAdaptor::equal_semanticsAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::MemorySemanticsAttr attr = odsAttrs.get("equal_semantics").cast<::mlir::spirv::MemorySemanticsAttr>();
  return attr;
}

::mlir::spirv::MemorySemantics AtomicCompareExchangeWeakOpAdaptor::equal_semantics() {
  auto attr = equal_semanticsAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicCompareExchangeWeakOpAdaptor::unequal_semanticsAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::MemorySemanticsAttr attr = odsAttrs.get("unequal_semantics").cast<::mlir::spirv::MemorySemanticsAttr>();
  return attr;
}

::mlir::spirv::MemorySemantics AtomicCompareExchangeWeakOpAdaptor::unequal_semantics() {
  auto attr = unequal_semanticsAttr();
  return attr.getValue();
}

::mlir::LogicalResult AtomicCompareExchangeWeakOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_memory_scope = odsAttrs.get("memory_scope");
    if (!tblgen_memory_scope)
      return emitError(loc, "'spv.AtomicCompareExchangeWeak' op ""requires attribute 'memory_scope'");

    if (tblgen_memory_scope && !((((tblgen_memory_scope.isa<::mlir::IntegerAttr>())) && ((tblgen_memory_scope.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(tblgen_memory_scope.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.AtomicCompareExchangeWeak' op ""attribute 'memory_scope' failed to satisfy constraint: valid SPIR-V Scope");
  }
  {
    auto tblgen_equal_semantics = odsAttrs.get("equal_semantics");
    if (!tblgen_equal_semantics)
      return emitError(loc, "'spv.AtomicCompareExchangeWeak' op ""requires attribute 'equal_semantics'");

    if (tblgen_equal_semantics && !((((tblgen_equal_semantics.isa<::mlir::IntegerAttr>())) && ((tblgen_equal_semantics.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics(tblgen_equal_semantics.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.AtomicCompareExchangeWeak' op ""attribute 'equal_semantics' failed to satisfy constraint: valid SPIR-V MemorySemantics");
  }
  {
    auto tblgen_unequal_semantics = odsAttrs.get("unequal_semantics");
    if (!tblgen_unequal_semantics)
      return emitError(loc, "'spv.AtomicCompareExchangeWeak' op ""requires attribute 'unequal_semantics'");

    if (tblgen_unequal_semantics && !((((tblgen_unequal_semantics.isa<::mlir::IntegerAttr>())) && ((tblgen_unequal_semantics.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics(tblgen_unequal_semantics.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.AtomicCompareExchangeWeak' op ""attribute 'unequal_semantics' failed to satisfy constraint: valid SPIR-V MemorySemantics");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> AtomicCompareExchangeWeakOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AtomicCompareExchangeWeakOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicCompareExchangeWeakOp::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::Value AtomicCompareExchangeWeakOp::value() {
  return *getODSOperands(1).begin();
}

::mlir::Value AtomicCompareExchangeWeakOp::comparator() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange AtomicCompareExchangeWeakOp::pointerMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange AtomicCompareExchangeWeakOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange AtomicCompareExchangeWeakOp::comparatorMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> AtomicCompareExchangeWeakOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AtomicCompareExchangeWeakOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicCompareExchangeWeakOp::result() {
  return *getODSResults(0).begin();
}

::mlir::spirv::ScopeAttr AtomicCompareExchangeWeakOp::memory_scopeAttr() {
  return (*this)->getAttr(memory_scopeAttrName()).cast<::mlir::spirv::ScopeAttr>();
}

::mlir::spirv::Scope AtomicCompareExchangeWeakOp::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicCompareExchangeWeakOp::equal_semanticsAttr() {
  return (*this)->getAttr(equal_semanticsAttrName()).cast<::mlir::spirv::MemorySemanticsAttr>();
}

::mlir::spirv::MemorySemantics AtomicCompareExchangeWeakOp::equal_semantics() {
  auto attr = equal_semanticsAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicCompareExchangeWeakOp::unequal_semanticsAttr() {
  return (*this)->getAttr(unequal_semanticsAttrName()).cast<::mlir::spirv::MemorySemanticsAttr>();
}

::mlir::spirv::MemorySemantics AtomicCompareExchangeWeakOp::unequal_semantics() {
  auto attr = unequal_semanticsAttr();
  return attr.getValue();
}

void AtomicCompareExchangeWeakOp::memory_scopeAttr(::mlir::spirv::ScopeAttr attr) {
  (*this)->setAttr(memory_scopeAttrName(), attr);
}

void AtomicCompareExchangeWeakOp::equal_semanticsAttr(::mlir::spirv::MemorySemanticsAttr attr) {
  (*this)->setAttr(equal_semanticsAttrName(), attr);
}

void AtomicCompareExchangeWeakOp::unequal_semanticsAttr(::mlir::spirv::MemorySemanticsAttr attr) {
  (*this)->setAttr(unequal_semanticsAttrName(), attr);
}

void AtomicCompareExchangeWeakOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pointer, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr equal_semantics, ::mlir::spirv::MemorySemanticsAttr unequal_semantics, ::mlir::Value value, ::mlir::Value comparator) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addOperands(comparator);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(equal_semanticsAttrName(odsState.name), equal_semantics);
  odsState.addAttribute(unequal_semanticsAttrName(odsState.name), unequal_semantics);
  odsState.addTypes(result);
}

void AtomicCompareExchangeWeakOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pointer, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr equal_semantics, ::mlir::spirv::MemorySemanticsAttr unequal_semantics, ::mlir::Value value, ::mlir::Value comparator) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addOperands(comparator);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(equal_semanticsAttrName(odsState.name), equal_semantics);
  odsState.addAttribute(unequal_semanticsAttrName(odsState.name), unequal_semantics);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicCompareExchangeWeakOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pointer, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics equal_semantics, ::mlir::spirv::MemorySemantics unequal_semantics, ::mlir::Value value, ::mlir::Value comparator) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addOperands(comparator);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(equal_semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), equal_semantics));
  odsState.addAttribute(unequal_semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), unequal_semantics));
  odsState.addTypes(result);
}

void AtomicCompareExchangeWeakOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pointer, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics equal_semantics, ::mlir::spirv::MemorySemantics unequal_semantics, ::mlir::Value value, ::mlir::Value comparator) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addOperands(comparator);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(equal_semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), equal_semantics));
  odsState.addAttribute(unequal_semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), unequal_semantics));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicCompareExchangeWeakOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AtomicCompareExchangeWeakOp::verifyInvariantsImpl() {
  {
    auto tblgen_memory_scope = (*this)->getAttr(memory_scopeAttrName());
    if (!tblgen_memory_scope)
      return emitOpError("requires attribute 'memory_scope'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps1(*this, tblgen_memory_scope, "memory_scope")))
      return ::mlir::failure();
  }
  {
    auto tblgen_equal_semantics = (*this)->getAttr(equal_semanticsAttrName());
    if (!tblgen_equal_semantics)
      return emitOpError("requires attribute 'equal_semantics'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps2(*this, tblgen_equal_semantics, "equal_semantics")))
      return ::mlir::failure();
  }
  {
    auto tblgen_unequal_semantics = (*this)->getAttr(unequal_semanticsAttrName());
    if (!tblgen_unequal_semantics)
      return emitOpError("requires attribute 'unequal_semantics'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps2(*this, tblgen_unequal_semantics, "unequal_semantics")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps0(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult AtomicCompareExchangeWeakOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::AtomicCompareExchangeWeakOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::AtomicExchangeOp definitions
//===----------------------------------------------------------------------===//

AtomicExchangeOpAdaptor::AtomicExchangeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

AtomicExchangeOpAdaptor::AtomicExchangeOpAdaptor(AtomicExchangeOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange AtomicExchangeOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AtomicExchangeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AtomicExchangeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicExchangeOpAdaptor::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::Value AtomicExchangeOpAdaptor::value() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr AtomicExchangeOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ScopeAttr AtomicExchangeOpAdaptor::memory_scopeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ScopeAttr attr = odsAttrs.get("memory_scope").cast<::mlir::spirv::ScopeAttr>();
  return attr;
}

::mlir::spirv::Scope AtomicExchangeOpAdaptor::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicExchangeOpAdaptor::semanticsAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::MemorySemanticsAttr attr = odsAttrs.get("semantics").cast<::mlir::spirv::MemorySemanticsAttr>();
  return attr;
}

::mlir::spirv::MemorySemantics AtomicExchangeOpAdaptor::semantics() {
  auto attr = semanticsAttr();
  return attr.getValue();
}

::mlir::LogicalResult AtomicExchangeOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_memory_scope = odsAttrs.get("memory_scope");
    if (!tblgen_memory_scope)
      return emitError(loc, "'spv.AtomicExchange' op ""requires attribute 'memory_scope'");

    if (tblgen_memory_scope && !((((tblgen_memory_scope.isa<::mlir::IntegerAttr>())) && ((tblgen_memory_scope.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(tblgen_memory_scope.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.AtomicExchange' op ""attribute 'memory_scope' failed to satisfy constraint: valid SPIR-V Scope");
  }
  {
    auto tblgen_semantics = odsAttrs.get("semantics");
    if (!tblgen_semantics)
      return emitError(loc, "'spv.AtomicExchange' op ""requires attribute 'semantics'");

    if (tblgen_semantics && !((((tblgen_semantics.isa<::mlir::IntegerAttr>())) && ((tblgen_semantics.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics(tblgen_semantics.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.AtomicExchange' op ""attribute 'semantics' failed to satisfy constraint: valid SPIR-V MemorySemantics");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> AtomicExchangeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AtomicExchangeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicExchangeOp::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::Value AtomicExchangeOp::value() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange AtomicExchangeOp::pointerMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange AtomicExchangeOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> AtomicExchangeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AtomicExchangeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicExchangeOp::result() {
  return *getODSResults(0).begin();
}

::mlir::spirv::ScopeAttr AtomicExchangeOp::memory_scopeAttr() {
  return (*this)->getAttr(memory_scopeAttrName()).cast<::mlir::spirv::ScopeAttr>();
}

::mlir::spirv::Scope AtomicExchangeOp::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicExchangeOp::semanticsAttr() {
  return (*this)->getAttr(semanticsAttrName()).cast<::mlir::spirv::MemorySemanticsAttr>();
}

::mlir::spirv::MemorySemantics AtomicExchangeOp::semantics() {
  auto attr = semanticsAttr();
  return attr.getValue();
}

void AtomicExchangeOp::memory_scopeAttr(::mlir::spirv::ScopeAttr attr) {
  (*this)->setAttr(memory_scopeAttrName(), attr);
}

void AtomicExchangeOp::semanticsAttr(::mlir::spirv::MemorySemanticsAttr attr) {
  (*this)->setAttr(semanticsAttrName(), attr);
}

void AtomicExchangeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pointer, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(semanticsAttrName(odsState.name), semantics);
  odsState.addTypes(result);
}

void AtomicExchangeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pointer, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(semanticsAttrName(odsState.name), semantics);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicExchangeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pointer, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), semantics));
  odsState.addTypes(result);
}

void AtomicExchangeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pointer, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), semantics));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicExchangeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AtomicExchangeOp::verifyInvariantsImpl() {
  {
    auto tblgen_memory_scope = (*this)->getAttr(memory_scopeAttrName());
    if (!tblgen_memory_scope)
      return emitOpError("requires attribute 'memory_scope'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps1(*this, tblgen_memory_scope, "memory_scope")))
      return ::mlir::failure();
  }
  {
    auto tblgen_semantics = (*this)->getAttr(semanticsAttrName());
    if (!tblgen_semantics)
      return emitOpError("requires attribute 'semantics'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps2(*this, tblgen_semantics, "semantics")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps0(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps2(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps2(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult AtomicExchangeOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::AtomicExchangeOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::AtomicFAddEXTOp definitions
//===----------------------------------------------------------------------===//

AtomicFAddEXTOpAdaptor::AtomicFAddEXTOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

AtomicFAddEXTOpAdaptor::AtomicFAddEXTOpAdaptor(AtomicFAddEXTOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange AtomicFAddEXTOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AtomicFAddEXTOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AtomicFAddEXTOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicFAddEXTOpAdaptor::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::Value AtomicFAddEXTOpAdaptor::value() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr AtomicFAddEXTOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ScopeAttr AtomicFAddEXTOpAdaptor::memory_scopeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ScopeAttr attr = odsAttrs.get("memory_scope").cast<::mlir::spirv::ScopeAttr>();
  return attr;
}

::mlir::spirv::Scope AtomicFAddEXTOpAdaptor::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicFAddEXTOpAdaptor::semanticsAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::MemorySemanticsAttr attr = odsAttrs.get("semantics").cast<::mlir::spirv::MemorySemanticsAttr>();
  return attr;
}

::mlir::spirv::MemorySemantics AtomicFAddEXTOpAdaptor::semantics() {
  auto attr = semanticsAttr();
  return attr.getValue();
}

::mlir::LogicalResult AtomicFAddEXTOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_memory_scope = odsAttrs.get("memory_scope");
    if (!tblgen_memory_scope)
      return emitError(loc, "'spv.AtomicFAddEXT' op ""requires attribute 'memory_scope'");

    if (tblgen_memory_scope && !((((tblgen_memory_scope.isa<::mlir::IntegerAttr>())) && ((tblgen_memory_scope.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(tblgen_memory_scope.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.AtomicFAddEXT' op ""attribute 'memory_scope' failed to satisfy constraint: valid SPIR-V Scope");
  }
  {
    auto tblgen_semantics = odsAttrs.get("semantics");
    if (!tblgen_semantics)
      return emitError(loc, "'spv.AtomicFAddEXT' op ""requires attribute 'semantics'");

    if (tblgen_semantics && !((((tblgen_semantics.isa<::mlir::IntegerAttr>())) && ((tblgen_semantics.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics(tblgen_semantics.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.AtomicFAddEXT' op ""attribute 'semantics' failed to satisfy constraint: valid SPIR-V MemorySemantics");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> AtomicFAddEXTOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AtomicFAddEXTOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicFAddEXTOp::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::Value AtomicFAddEXTOp::value() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange AtomicFAddEXTOp::pointerMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange AtomicFAddEXTOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> AtomicFAddEXTOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AtomicFAddEXTOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicFAddEXTOp::result() {
  return *getODSResults(0).begin();
}

::mlir::spirv::ScopeAttr AtomicFAddEXTOp::memory_scopeAttr() {
  return (*this)->getAttr(memory_scopeAttrName()).cast<::mlir::spirv::ScopeAttr>();
}

::mlir::spirv::Scope AtomicFAddEXTOp::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicFAddEXTOp::semanticsAttr() {
  return (*this)->getAttr(semanticsAttrName()).cast<::mlir::spirv::MemorySemanticsAttr>();
}

::mlir::spirv::MemorySemantics AtomicFAddEXTOp::semantics() {
  auto attr = semanticsAttr();
  return attr.getValue();
}

void AtomicFAddEXTOp::memory_scopeAttr(::mlir::spirv::ScopeAttr attr) {
  (*this)->setAttr(memory_scopeAttrName(), attr);
}

void AtomicFAddEXTOp::semanticsAttr(::mlir::spirv::MemorySemanticsAttr attr) {
  (*this)->setAttr(semanticsAttrName(), attr);
}

void AtomicFAddEXTOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pointer, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(semanticsAttrName(odsState.name), semantics);
  odsState.addTypes(result);
}

void AtomicFAddEXTOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pointer, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(semanticsAttrName(odsState.name), semantics);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicFAddEXTOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pointer, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), semantics));
  odsState.addTypes(result);
}

void AtomicFAddEXTOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pointer, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), semantics));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicFAddEXTOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AtomicFAddEXTOp::verifyInvariantsImpl() {
  {
    auto tblgen_memory_scope = (*this)->getAttr(memory_scopeAttrName());
    if (!tblgen_memory_scope)
      return emitOpError("requires attribute 'memory_scope'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps1(*this, tblgen_memory_scope, "memory_scope")))
      return ::mlir::failure();
  }
  {
    auto tblgen_semantics = (*this)->getAttr(semanticsAttrName());
    if (!tblgen_semantics)
      return emitOpError("requires attribute 'semantics'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps2(*this, tblgen_semantics, "semantics")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps0(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps3(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult AtomicFAddEXTOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::AtomicFAddEXTOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::AtomicIAddOp definitions
//===----------------------------------------------------------------------===//

AtomicIAddOpAdaptor::AtomicIAddOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

AtomicIAddOpAdaptor::AtomicIAddOpAdaptor(AtomicIAddOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange AtomicIAddOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AtomicIAddOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AtomicIAddOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicIAddOpAdaptor::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::Value AtomicIAddOpAdaptor::value() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr AtomicIAddOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ScopeAttr AtomicIAddOpAdaptor::memory_scopeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ScopeAttr attr = odsAttrs.get("memory_scope").cast<::mlir::spirv::ScopeAttr>();
  return attr;
}

::mlir::spirv::Scope AtomicIAddOpAdaptor::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicIAddOpAdaptor::semanticsAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::MemorySemanticsAttr attr = odsAttrs.get("semantics").cast<::mlir::spirv::MemorySemanticsAttr>();
  return attr;
}

::mlir::spirv::MemorySemantics AtomicIAddOpAdaptor::semantics() {
  auto attr = semanticsAttr();
  return attr.getValue();
}

::mlir::LogicalResult AtomicIAddOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_memory_scope = odsAttrs.get("memory_scope");
    if (!tblgen_memory_scope)
      return emitError(loc, "'spv.AtomicIAdd' op ""requires attribute 'memory_scope'");

    if (tblgen_memory_scope && !((((tblgen_memory_scope.isa<::mlir::IntegerAttr>())) && ((tblgen_memory_scope.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(tblgen_memory_scope.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.AtomicIAdd' op ""attribute 'memory_scope' failed to satisfy constraint: valid SPIR-V Scope");
  }
  {
    auto tblgen_semantics = odsAttrs.get("semantics");
    if (!tblgen_semantics)
      return emitError(loc, "'spv.AtomicIAdd' op ""requires attribute 'semantics'");

    if (tblgen_semantics && !((((tblgen_semantics.isa<::mlir::IntegerAttr>())) && ((tblgen_semantics.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics(tblgen_semantics.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.AtomicIAdd' op ""attribute 'semantics' failed to satisfy constraint: valid SPIR-V MemorySemantics");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> AtomicIAddOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AtomicIAddOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicIAddOp::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::Value AtomicIAddOp::value() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange AtomicIAddOp::pointerMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange AtomicIAddOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> AtomicIAddOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AtomicIAddOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicIAddOp::result() {
  return *getODSResults(0).begin();
}

::mlir::spirv::ScopeAttr AtomicIAddOp::memory_scopeAttr() {
  return (*this)->getAttr(memory_scopeAttrName()).cast<::mlir::spirv::ScopeAttr>();
}

::mlir::spirv::Scope AtomicIAddOp::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicIAddOp::semanticsAttr() {
  return (*this)->getAttr(semanticsAttrName()).cast<::mlir::spirv::MemorySemanticsAttr>();
}

::mlir::spirv::MemorySemantics AtomicIAddOp::semantics() {
  auto attr = semanticsAttr();
  return attr.getValue();
}

void AtomicIAddOp::memory_scopeAttr(::mlir::spirv::ScopeAttr attr) {
  (*this)->setAttr(memory_scopeAttrName(), attr);
}

void AtomicIAddOp::semanticsAttr(::mlir::spirv::MemorySemanticsAttr attr) {
  (*this)->setAttr(semanticsAttrName(), attr);
}

void AtomicIAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value pointer, ::mlir::spirv::Scope scope, ::mlir::spirv::MemorySemantics memory, Value value) {
build(odsBuilder, odsState, value.getType(), pointer, scope, memory, value);
}

void AtomicIAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pointer, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(semanticsAttrName(odsState.name), semantics);
  odsState.addTypes(result);
}

void AtomicIAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pointer, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(semanticsAttrName(odsState.name), semantics);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicIAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pointer, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), semantics));
  odsState.addTypes(result);
}

void AtomicIAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pointer, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), semantics));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicIAddOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AtomicIAddOp::verifyInvariantsImpl() {
  {
    auto tblgen_memory_scope = (*this)->getAttr(memory_scopeAttrName());
    if (!tblgen_memory_scope)
      return emitOpError("requires attribute 'memory_scope'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps1(*this, tblgen_memory_scope, "memory_scope")))
      return ::mlir::failure();
  }
  {
    auto tblgen_semantics = (*this)->getAttr(semanticsAttrName());
    if (!tblgen_semantics)
      return emitOpError("requires attribute 'semantics'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps2(*this, tblgen_semantics, "semantics")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps0(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult AtomicIAddOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::AtomicIAddOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::AtomicIDecrementOp definitions
//===----------------------------------------------------------------------===//

AtomicIDecrementOpAdaptor::AtomicIDecrementOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

AtomicIDecrementOpAdaptor::AtomicIDecrementOpAdaptor(AtomicIDecrementOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange AtomicIDecrementOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AtomicIDecrementOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AtomicIDecrementOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicIDecrementOpAdaptor::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr AtomicIDecrementOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ScopeAttr AtomicIDecrementOpAdaptor::memory_scopeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ScopeAttr attr = odsAttrs.get("memory_scope").cast<::mlir::spirv::ScopeAttr>();
  return attr;
}

::mlir::spirv::Scope AtomicIDecrementOpAdaptor::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicIDecrementOpAdaptor::semanticsAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::MemorySemanticsAttr attr = odsAttrs.get("semantics").cast<::mlir::spirv::MemorySemanticsAttr>();
  return attr;
}

::mlir::spirv::MemorySemantics AtomicIDecrementOpAdaptor::semantics() {
  auto attr = semanticsAttr();
  return attr.getValue();
}

::mlir::LogicalResult AtomicIDecrementOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_memory_scope = odsAttrs.get("memory_scope");
    if (!tblgen_memory_scope)
      return emitError(loc, "'spv.AtomicIDecrement' op ""requires attribute 'memory_scope'");

    if (tblgen_memory_scope && !((((tblgen_memory_scope.isa<::mlir::IntegerAttr>())) && ((tblgen_memory_scope.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(tblgen_memory_scope.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.AtomicIDecrement' op ""attribute 'memory_scope' failed to satisfy constraint: valid SPIR-V Scope");
  }
  {
    auto tblgen_semantics = odsAttrs.get("semantics");
    if (!tblgen_semantics)
      return emitError(loc, "'spv.AtomicIDecrement' op ""requires attribute 'semantics'");

    if (tblgen_semantics && !((((tblgen_semantics.isa<::mlir::IntegerAttr>())) && ((tblgen_semantics.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics(tblgen_semantics.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.AtomicIDecrement' op ""attribute 'semantics' failed to satisfy constraint: valid SPIR-V MemorySemantics");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> AtomicIDecrementOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AtomicIDecrementOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicIDecrementOp::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange AtomicIDecrementOp::pointerMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> AtomicIDecrementOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AtomicIDecrementOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicIDecrementOp::result() {
  return *getODSResults(0).begin();
}

::mlir::spirv::ScopeAttr AtomicIDecrementOp::memory_scopeAttr() {
  return (*this)->getAttr(memory_scopeAttrName()).cast<::mlir::spirv::ScopeAttr>();
}

::mlir::spirv::Scope AtomicIDecrementOp::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicIDecrementOp::semanticsAttr() {
  return (*this)->getAttr(semanticsAttrName()).cast<::mlir::spirv::MemorySemanticsAttr>();
}

::mlir::spirv::MemorySemantics AtomicIDecrementOp::semantics() {
  auto attr = semanticsAttr();
  return attr.getValue();
}

void AtomicIDecrementOp::memory_scopeAttr(::mlir::spirv::ScopeAttr attr) {
  (*this)->setAttr(memory_scopeAttrName(), attr);
}

void AtomicIDecrementOp::semanticsAttr(::mlir::spirv::MemorySemanticsAttr attr) {
  (*this)->setAttr(semanticsAttrName(), attr);
}

void AtomicIDecrementOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pointer, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr semantics) {
  odsState.addOperands(pointer);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(semanticsAttrName(odsState.name), semantics);
  odsState.addTypes(result);
}

void AtomicIDecrementOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pointer, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr semantics) {
  odsState.addOperands(pointer);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(semanticsAttrName(odsState.name), semantics);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicIDecrementOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pointer, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics semantics) {
  odsState.addOperands(pointer);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), semantics));
  odsState.addTypes(result);
}

void AtomicIDecrementOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pointer, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics semantics) {
  odsState.addOperands(pointer);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), semantics));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicIDecrementOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AtomicIDecrementOp::verifyInvariantsImpl() {
  {
    auto tblgen_memory_scope = (*this)->getAttr(memory_scopeAttrName());
    if (!tblgen_memory_scope)
      return emitOpError("requires attribute 'memory_scope'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps1(*this, tblgen_memory_scope, "memory_scope")))
      return ::mlir::failure();
  }
  {
    auto tblgen_semantics = (*this)->getAttr(semanticsAttrName());
    if (!tblgen_semantics)
      return emitOpError("requires attribute 'semantics'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps2(*this, tblgen_semantics, "semantics")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps0(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult AtomicIDecrementOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::AtomicIDecrementOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::AtomicIIncrementOp definitions
//===----------------------------------------------------------------------===//

AtomicIIncrementOpAdaptor::AtomicIIncrementOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

AtomicIIncrementOpAdaptor::AtomicIIncrementOpAdaptor(AtomicIIncrementOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange AtomicIIncrementOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AtomicIIncrementOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AtomicIIncrementOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicIIncrementOpAdaptor::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr AtomicIIncrementOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ScopeAttr AtomicIIncrementOpAdaptor::memory_scopeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ScopeAttr attr = odsAttrs.get("memory_scope").cast<::mlir::spirv::ScopeAttr>();
  return attr;
}

::mlir::spirv::Scope AtomicIIncrementOpAdaptor::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicIIncrementOpAdaptor::semanticsAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::MemorySemanticsAttr attr = odsAttrs.get("semantics").cast<::mlir::spirv::MemorySemanticsAttr>();
  return attr;
}

::mlir::spirv::MemorySemantics AtomicIIncrementOpAdaptor::semantics() {
  auto attr = semanticsAttr();
  return attr.getValue();
}

::mlir::LogicalResult AtomicIIncrementOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_memory_scope = odsAttrs.get("memory_scope");
    if (!tblgen_memory_scope)
      return emitError(loc, "'spv.AtomicIIncrement' op ""requires attribute 'memory_scope'");

    if (tblgen_memory_scope && !((((tblgen_memory_scope.isa<::mlir::IntegerAttr>())) && ((tblgen_memory_scope.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(tblgen_memory_scope.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.AtomicIIncrement' op ""attribute 'memory_scope' failed to satisfy constraint: valid SPIR-V Scope");
  }
  {
    auto tblgen_semantics = odsAttrs.get("semantics");
    if (!tblgen_semantics)
      return emitError(loc, "'spv.AtomicIIncrement' op ""requires attribute 'semantics'");

    if (tblgen_semantics && !((((tblgen_semantics.isa<::mlir::IntegerAttr>())) && ((tblgen_semantics.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics(tblgen_semantics.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.AtomicIIncrement' op ""attribute 'semantics' failed to satisfy constraint: valid SPIR-V MemorySemantics");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> AtomicIIncrementOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AtomicIIncrementOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicIIncrementOp::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange AtomicIIncrementOp::pointerMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> AtomicIIncrementOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AtomicIIncrementOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicIIncrementOp::result() {
  return *getODSResults(0).begin();
}

::mlir::spirv::ScopeAttr AtomicIIncrementOp::memory_scopeAttr() {
  return (*this)->getAttr(memory_scopeAttrName()).cast<::mlir::spirv::ScopeAttr>();
}

::mlir::spirv::Scope AtomicIIncrementOp::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicIIncrementOp::semanticsAttr() {
  return (*this)->getAttr(semanticsAttrName()).cast<::mlir::spirv::MemorySemanticsAttr>();
}

::mlir::spirv::MemorySemantics AtomicIIncrementOp::semantics() {
  auto attr = semanticsAttr();
  return attr.getValue();
}

void AtomicIIncrementOp::memory_scopeAttr(::mlir::spirv::ScopeAttr attr) {
  (*this)->setAttr(memory_scopeAttrName(), attr);
}

void AtomicIIncrementOp::semanticsAttr(::mlir::spirv::MemorySemanticsAttr attr) {
  (*this)->setAttr(semanticsAttrName(), attr);
}

void AtomicIIncrementOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pointer, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr semantics) {
  odsState.addOperands(pointer);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(semanticsAttrName(odsState.name), semantics);
  odsState.addTypes(result);
}

void AtomicIIncrementOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pointer, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr semantics) {
  odsState.addOperands(pointer);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(semanticsAttrName(odsState.name), semantics);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicIIncrementOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pointer, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics semantics) {
  odsState.addOperands(pointer);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), semantics));
  odsState.addTypes(result);
}

void AtomicIIncrementOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pointer, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics semantics) {
  odsState.addOperands(pointer);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), semantics));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicIIncrementOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AtomicIIncrementOp::verifyInvariantsImpl() {
  {
    auto tblgen_memory_scope = (*this)->getAttr(memory_scopeAttrName());
    if (!tblgen_memory_scope)
      return emitOpError("requires attribute 'memory_scope'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps1(*this, tblgen_memory_scope, "memory_scope")))
      return ::mlir::failure();
  }
  {
    auto tblgen_semantics = (*this)->getAttr(semanticsAttrName());
    if (!tblgen_semantics)
      return emitOpError("requires attribute 'semantics'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps2(*this, tblgen_semantics, "semantics")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps0(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult AtomicIIncrementOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::AtomicIIncrementOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::AtomicISubOp definitions
//===----------------------------------------------------------------------===//

AtomicISubOpAdaptor::AtomicISubOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

AtomicISubOpAdaptor::AtomicISubOpAdaptor(AtomicISubOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange AtomicISubOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AtomicISubOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AtomicISubOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicISubOpAdaptor::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::Value AtomicISubOpAdaptor::value() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr AtomicISubOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ScopeAttr AtomicISubOpAdaptor::memory_scopeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ScopeAttr attr = odsAttrs.get("memory_scope").cast<::mlir::spirv::ScopeAttr>();
  return attr;
}

::mlir::spirv::Scope AtomicISubOpAdaptor::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicISubOpAdaptor::semanticsAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::MemorySemanticsAttr attr = odsAttrs.get("semantics").cast<::mlir::spirv::MemorySemanticsAttr>();
  return attr;
}

::mlir::spirv::MemorySemantics AtomicISubOpAdaptor::semantics() {
  auto attr = semanticsAttr();
  return attr.getValue();
}

::mlir::LogicalResult AtomicISubOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_memory_scope = odsAttrs.get("memory_scope");
    if (!tblgen_memory_scope)
      return emitError(loc, "'spv.AtomicISub' op ""requires attribute 'memory_scope'");

    if (tblgen_memory_scope && !((((tblgen_memory_scope.isa<::mlir::IntegerAttr>())) && ((tblgen_memory_scope.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(tblgen_memory_scope.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.AtomicISub' op ""attribute 'memory_scope' failed to satisfy constraint: valid SPIR-V Scope");
  }
  {
    auto tblgen_semantics = odsAttrs.get("semantics");
    if (!tblgen_semantics)
      return emitError(loc, "'spv.AtomicISub' op ""requires attribute 'semantics'");

    if (tblgen_semantics && !((((tblgen_semantics.isa<::mlir::IntegerAttr>())) && ((tblgen_semantics.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics(tblgen_semantics.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.AtomicISub' op ""attribute 'semantics' failed to satisfy constraint: valid SPIR-V MemorySemantics");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> AtomicISubOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AtomicISubOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicISubOp::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::Value AtomicISubOp::value() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange AtomicISubOp::pointerMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange AtomicISubOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> AtomicISubOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AtomicISubOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicISubOp::result() {
  return *getODSResults(0).begin();
}

::mlir::spirv::ScopeAttr AtomicISubOp::memory_scopeAttr() {
  return (*this)->getAttr(memory_scopeAttrName()).cast<::mlir::spirv::ScopeAttr>();
}

::mlir::spirv::Scope AtomicISubOp::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicISubOp::semanticsAttr() {
  return (*this)->getAttr(semanticsAttrName()).cast<::mlir::spirv::MemorySemanticsAttr>();
}

::mlir::spirv::MemorySemantics AtomicISubOp::semantics() {
  auto attr = semanticsAttr();
  return attr.getValue();
}

void AtomicISubOp::memory_scopeAttr(::mlir::spirv::ScopeAttr attr) {
  (*this)->setAttr(memory_scopeAttrName(), attr);
}

void AtomicISubOp::semanticsAttr(::mlir::spirv::MemorySemanticsAttr attr) {
  (*this)->setAttr(semanticsAttrName(), attr);
}

void AtomicISubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value pointer, ::mlir::spirv::Scope scope, ::mlir::spirv::MemorySemantics memory, Value value) {
build(odsBuilder, odsState, value.getType(), pointer, scope, memory, value);
}

void AtomicISubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pointer, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(semanticsAttrName(odsState.name), semantics);
  odsState.addTypes(result);
}

void AtomicISubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pointer, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(semanticsAttrName(odsState.name), semantics);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicISubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pointer, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), semantics));
  odsState.addTypes(result);
}

void AtomicISubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pointer, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), semantics));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicISubOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AtomicISubOp::verifyInvariantsImpl() {
  {
    auto tblgen_memory_scope = (*this)->getAttr(memory_scopeAttrName());
    if (!tblgen_memory_scope)
      return emitOpError("requires attribute 'memory_scope'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps1(*this, tblgen_memory_scope, "memory_scope")))
      return ::mlir::failure();
  }
  {
    auto tblgen_semantics = (*this)->getAttr(semanticsAttrName());
    if (!tblgen_semantics)
      return emitOpError("requires attribute 'semantics'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps2(*this, tblgen_semantics, "semantics")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps0(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult AtomicISubOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::AtomicISubOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::AtomicOrOp definitions
//===----------------------------------------------------------------------===//

AtomicOrOpAdaptor::AtomicOrOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

AtomicOrOpAdaptor::AtomicOrOpAdaptor(AtomicOrOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange AtomicOrOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AtomicOrOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AtomicOrOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicOrOpAdaptor::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::Value AtomicOrOpAdaptor::value() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr AtomicOrOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ScopeAttr AtomicOrOpAdaptor::memory_scopeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ScopeAttr attr = odsAttrs.get("memory_scope").cast<::mlir::spirv::ScopeAttr>();
  return attr;
}

::mlir::spirv::Scope AtomicOrOpAdaptor::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicOrOpAdaptor::semanticsAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::MemorySemanticsAttr attr = odsAttrs.get("semantics").cast<::mlir::spirv::MemorySemanticsAttr>();
  return attr;
}

::mlir::spirv::MemorySemantics AtomicOrOpAdaptor::semantics() {
  auto attr = semanticsAttr();
  return attr.getValue();
}

::mlir::LogicalResult AtomicOrOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_memory_scope = odsAttrs.get("memory_scope");
    if (!tblgen_memory_scope)
      return emitError(loc, "'spv.AtomicOr' op ""requires attribute 'memory_scope'");

    if (tblgen_memory_scope && !((((tblgen_memory_scope.isa<::mlir::IntegerAttr>())) && ((tblgen_memory_scope.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(tblgen_memory_scope.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.AtomicOr' op ""attribute 'memory_scope' failed to satisfy constraint: valid SPIR-V Scope");
  }
  {
    auto tblgen_semantics = odsAttrs.get("semantics");
    if (!tblgen_semantics)
      return emitError(loc, "'spv.AtomicOr' op ""requires attribute 'semantics'");

    if (tblgen_semantics && !((((tblgen_semantics.isa<::mlir::IntegerAttr>())) && ((tblgen_semantics.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics(tblgen_semantics.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.AtomicOr' op ""attribute 'semantics' failed to satisfy constraint: valid SPIR-V MemorySemantics");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> AtomicOrOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AtomicOrOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicOrOp::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::Value AtomicOrOp::value() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange AtomicOrOp::pointerMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange AtomicOrOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> AtomicOrOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AtomicOrOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicOrOp::result() {
  return *getODSResults(0).begin();
}

::mlir::spirv::ScopeAttr AtomicOrOp::memory_scopeAttr() {
  return (*this)->getAttr(memory_scopeAttrName()).cast<::mlir::spirv::ScopeAttr>();
}

::mlir::spirv::Scope AtomicOrOp::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicOrOp::semanticsAttr() {
  return (*this)->getAttr(semanticsAttrName()).cast<::mlir::spirv::MemorySemanticsAttr>();
}

::mlir::spirv::MemorySemantics AtomicOrOp::semantics() {
  auto attr = semanticsAttr();
  return attr.getValue();
}

void AtomicOrOp::memory_scopeAttr(::mlir::spirv::ScopeAttr attr) {
  (*this)->setAttr(memory_scopeAttrName(), attr);
}

void AtomicOrOp::semanticsAttr(::mlir::spirv::MemorySemanticsAttr attr) {
  (*this)->setAttr(semanticsAttrName(), attr);
}

void AtomicOrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value pointer, ::mlir::spirv::Scope scope, ::mlir::spirv::MemorySemantics memory, Value value) {
build(odsBuilder, odsState, value.getType(), pointer, scope, memory, value);
}

void AtomicOrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pointer, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(semanticsAttrName(odsState.name), semantics);
  odsState.addTypes(result);
}

void AtomicOrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pointer, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(semanticsAttrName(odsState.name), semantics);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicOrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pointer, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), semantics));
  odsState.addTypes(result);
}

void AtomicOrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pointer, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), semantics));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicOrOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AtomicOrOp::verifyInvariantsImpl() {
  {
    auto tblgen_memory_scope = (*this)->getAttr(memory_scopeAttrName());
    if (!tblgen_memory_scope)
      return emitOpError("requires attribute 'memory_scope'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps1(*this, tblgen_memory_scope, "memory_scope")))
      return ::mlir::failure();
  }
  {
    auto tblgen_semantics = (*this)->getAttr(semanticsAttrName());
    if (!tblgen_semantics)
      return emitOpError("requires attribute 'semantics'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps2(*this, tblgen_semantics, "semantics")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps0(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult AtomicOrOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::AtomicOrOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::AtomicSMaxOp definitions
//===----------------------------------------------------------------------===//

AtomicSMaxOpAdaptor::AtomicSMaxOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

AtomicSMaxOpAdaptor::AtomicSMaxOpAdaptor(AtomicSMaxOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange AtomicSMaxOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AtomicSMaxOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AtomicSMaxOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicSMaxOpAdaptor::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::Value AtomicSMaxOpAdaptor::value() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr AtomicSMaxOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ScopeAttr AtomicSMaxOpAdaptor::memory_scopeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ScopeAttr attr = odsAttrs.get("memory_scope").cast<::mlir::spirv::ScopeAttr>();
  return attr;
}

::mlir::spirv::Scope AtomicSMaxOpAdaptor::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicSMaxOpAdaptor::semanticsAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::MemorySemanticsAttr attr = odsAttrs.get("semantics").cast<::mlir::spirv::MemorySemanticsAttr>();
  return attr;
}

::mlir::spirv::MemorySemantics AtomicSMaxOpAdaptor::semantics() {
  auto attr = semanticsAttr();
  return attr.getValue();
}

::mlir::LogicalResult AtomicSMaxOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_memory_scope = odsAttrs.get("memory_scope");
    if (!tblgen_memory_scope)
      return emitError(loc, "'spv.AtomicSMax' op ""requires attribute 'memory_scope'");

    if (tblgen_memory_scope && !((((tblgen_memory_scope.isa<::mlir::IntegerAttr>())) && ((tblgen_memory_scope.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(tblgen_memory_scope.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.AtomicSMax' op ""attribute 'memory_scope' failed to satisfy constraint: valid SPIR-V Scope");
  }
  {
    auto tblgen_semantics = odsAttrs.get("semantics");
    if (!tblgen_semantics)
      return emitError(loc, "'spv.AtomicSMax' op ""requires attribute 'semantics'");

    if (tblgen_semantics && !((((tblgen_semantics.isa<::mlir::IntegerAttr>())) && ((tblgen_semantics.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics(tblgen_semantics.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.AtomicSMax' op ""attribute 'semantics' failed to satisfy constraint: valid SPIR-V MemorySemantics");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> AtomicSMaxOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AtomicSMaxOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicSMaxOp::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::Value AtomicSMaxOp::value() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange AtomicSMaxOp::pointerMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange AtomicSMaxOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> AtomicSMaxOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AtomicSMaxOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicSMaxOp::result() {
  return *getODSResults(0).begin();
}

::mlir::spirv::ScopeAttr AtomicSMaxOp::memory_scopeAttr() {
  return (*this)->getAttr(memory_scopeAttrName()).cast<::mlir::spirv::ScopeAttr>();
}

::mlir::spirv::Scope AtomicSMaxOp::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicSMaxOp::semanticsAttr() {
  return (*this)->getAttr(semanticsAttrName()).cast<::mlir::spirv::MemorySemanticsAttr>();
}

::mlir::spirv::MemorySemantics AtomicSMaxOp::semantics() {
  auto attr = semanticsAttr();
  return attr.getValue();
}

void AtomicSMaxOp::memory_scopeAttr(::mlir::spirv::ScopeAttr attr) {
  (*this)->setAttr(memory_scopeAttrName(), attr);
}

void AtomicSMaxOp::semanticsAttr(::mlir::spirv::MemorySemanticsAttr attr) {
  (*this)->setAttr(semanticsAttrName(), attr);
}

void AtomicSMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value pointer, ::mlir::spirv::Scope scope, ::mlir::spirv::MemorySemantics memory, Value value) {
build(odsBuilder, odsState, value.getType(), pointer, scope, memory, value);
}

void AtomicSMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pointer, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(semanticsAttrName(odsState.name), semantics);
  odsState.addTypes(result);
}

void AtomicSMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pointer, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(semanticsAttrName(odsState.name), semantics);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicSMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pointer, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), semantics));
  odsState.addTypes(result);
}

void AtomicSMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pointer, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), semantics));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicSMaxOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AtomicSMaxOp::verifyInvariantsImpl() {
  {
    auto tblgen_memory_scope = (*this)->getAttr(memory_scopeAttrName());
    if (!tblgen_memory_scope)
      return emitOpError("requires attribute 'memory_scope'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps1(*this, tblgen_memory_scope, "memory_scope")))
      return ::mlir::failure();
  }
  {
    auto tblgen_semantics = (*this)->getAttr(semanticsAttrName());
    if (!tblgen_semantics)
      return emitOpError("requires attribute 'semantics'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps2(*this, tblgen_semantics, "semantics")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps0(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult AtomicSMaxOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::AtomicSMaxOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::AtomicSMinOp definitions
//===----------------------------------------------------------------------===//

AtomicSMinOpAdaptor::AtomicSMinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

AtomicSMinOpAdaptor::AtomicSMinOpAdaptor(AtomicSMinOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange AtomicSMinOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AtomicSMinOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AtomicSMinOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicSMinOpAdaptor::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::Value AtomicSMinOpAdaptor::value() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr AtomicSMinOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ScopeAttr AtomicSMinOpAdaptor::memory_scopeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ScopeAttr attr = odsAttrs.get("memory_scope").cast<::mlir::spirv::ScopeAttr>();
  return attr;
}

::mlir::spirv::Scope AtomicSMinOpAdaptor::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicSMinOpAdaptor::semanticsAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::MemorySemanticsAttr attr = odsAttrs.get("semantics").cast<::mlir::spirv::MemorySemanticsAttr>();
  return attr;
}

::mlir::spirv::MemorySemantics AtomicSMinOpAdaptor::semantics() {
  auto attr = semanticsAttr();
  return attr.getValue();
}

::mlir::LogicalResult AtomicSMinOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_memory_scope = odsAttrs.get("memory_scope");
    if (!tblgen_memory_scope)
      return emitError(loc, "'spv.AtomicSMin' op ""requires attribute 'memory_scope'");

    if (tblgen_memory_scope && !((((tblgen_memory_scope.isa<::mlir::IntegerAttr>())) && ((tblgen_memory_scope.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(tblgen_memory_scope.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.AtomicSMin' op ""attribute 'memory_scope' failed to satisfy constraint: valid SPIR-V Scope");
  }
  {
    auto tblgen_semantics = odsAttrs.get("semantics");
    if (!tblgen_semantics)
      return emitError(loc, "'spv.AtomicSMin' op ""requires attribute 'semantics'");

    if (tblgen_semantics && !((((tblgen_semantics.isa<::mlir::IntegerAttr>())) && ((tblgen_semantics.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics(tblgen_semantics.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.AtomicSMin' op ""attribute 'semantics' failed to satisfy constraint: valid SPIR-V MemorySemantics");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> AtomicSMinOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AtomicSMinOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicSMinOp::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::Value AtomicSMinOp::value() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange AtomicSMinOp::pointerMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange AtomicSMinOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> AtomicSMinOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AtomicSMinOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicSMinOp::result() {
  return *getODSResults(0).begin();
}

::mlir::spirv::ScopeAttr AtomicSMinOp::memory_scopeAttr() {
  return (*this)->getAttr(memory_scopeAttrName()).cast<::mlir::spirv::ScopeAttr>();
}

::mlir::spirv::Scope AtomicSMinOp::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicSMinOp::semanticsAttr() {
  return (*this)->getAttr(semanticsAttrName()).cast<::mlir::spirv::MemorySemanticsAttr>();
}

::mlir::spirv::MemorySemantics AtomicSMinOp::semantics() {
  auto attr = semanticsAttr();
  return attr.getValue();
}

void AtomicSMinOp::memory_scopeAttr(::mlir::spirv::ScopeAttr attr) {
  (*this)->setAttr(memory_scopeAttrName(), attr);
}

void AtomicSMinOp::semanticsAttr(::mlir::spirv::MemorySemanticsAttr attr) {
  (*this)->setAttr(semanticsAttrName(), attr);
}

void AtomicSMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value pointer, ::mlir::spirv::Scope scope, ::mlir::spirv::MemorySemantics memory, Value value) {
build(odsBuilder, odsState, value.getType(), pointer, scope, memory, value);
}

void AtomicSMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pointer, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(semanticsAttrName(odsState.name), semantics);
  odsState.addTypes(result);
}

void AtomicSMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pointer, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(semanticsAttrName(odsState.name), semantics);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicSMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pointer, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), semantics));
  odsState.addTypes(result);
}

void AtomicSMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pointer, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), semantics));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicSMinOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AtomicSMinOp::verifyInvariantsImpl() {
  {
    auto tblgen_memory_scope = (*this)->getAttr(memory_scopeAttrName());
    if (!tblgen_memory_scope)
      return emitOpError("requires attribute 'memory_scope'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps1(*this, tblgen_memory_scope, "memory_scope")))
      return ::mlir::failure();
  }
  {
    auto tblgen_semantics = (*this)->getAttr(semanticsAttrName());
    if (!tblgen_semantics)
      return emitOpError("requires attribute 'semantics'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps2(*this, tblgen_semantics, "semantics")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps0(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult AtomicSMinOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::AtomicSMinOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::AtomicUMaxOp definitions
//===----------------------------------------------------------------------===//

AtomicUMaxOpAdaptor::AtomicUMaxOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

AtomicUMaxOpAdaptor::AtomicUMaxOpAdaptor(AtomicUMaxOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange AtomicUMaxOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AtomicUMaxOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AtomicUMaxOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicUMaxOpAdaptor::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::Value AtomicUMaxOpAdaptor::value() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr AtomicUMaxOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ScopeAttr AtomicUMaxOpAdaptor::memory_scopeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ScopeAttr attr = odsAttrs.get("memory_scope").cast<::mlir::spirv::ScopeAttr>();
  return attr;
}

::mlir::spirv::Scope AtomicUMaxOpAdaptor::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicUMaxOpAdaptor::semanticsAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::MemorySemanticsAttr attr = odsAttrs.get("semantics").cast<::mlir::spirv::MemorySemanticsAttr>();
  return attr;
}

::mlir::spirv::MemorySemantics AtomicUMaxOpAdaptor::semantics() {
  auto attr = semanticsAttr();
  return attr.getValue();
}

::mlir::LogicalResult AtomicUMaxOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_memory_scope = odsAttrs.get("memory_scope");
    if (!tblgen_memory_scope)
      return emitError(loc, "'spv.AtomicUMax' op ""requires attribute 'memory_scope'");

    if (tblgen_memory_scope && !((((tblgen_memory_scope.isa<::mlir::IntegerAttr>())) && ((tblgen_memory_scope.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(tblgen_memory_scope.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.AtomicUMax' op ""attribute 'memory_scope' failed to satisfy constraint: valid SPIR-V Scope");
  }
  {
    auto tblgen_semantics = odsAttrs.get("semantics");
    if (!tblgen_semantics)
      return emitError(loc, "'spv.AtomicUMax' op ""requires attribute 'semantics'");

    if (tblgen_semantics && !((((tblgen_semantics.isa<::mlir::IntegerAttr>())) && ((tblgen_semantics.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics(tblgen_semantics.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.AtomicUMax' op ""attribute 'semantics' failed to satisfy constraint: valid SPIR-V MemorySemantics");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> AtomicUMaxOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AtomicUMaxOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicUMaxOp::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::Value AtomicUMaxOp::value() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange AtomicUMaxOp::pointerMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange AtomicUMaxOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> AtomicUMaxOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AtomicUMaxOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicUMaxOp::result() {
  return *getODSResults(0).begin();
}

::mlir::spirv::ScopeAttr AtomicUMaxOp::memory_scopeAttr() {
  return (*this)->getAttr(memory_scopeAttrName()).cast<::mlir::spirv::ScopeAttr>();
}

::mlir::spirv::Scope AtomicUMaxOp::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicUMaxOp::semanticsAttr() {
  return (*this)->getAttr(semanticsAttrName()).cast<::mlir::spirv::MemorySemanticsAttr>();
}

::mlir::spirv::MemorySemantics AtomicUMaxOp::semantics() {
  auto attr = semanticsAttr();
  return attr.getValue();
}

void AtomicUMaxOp::memory_scopeAttr(::mlir::spirv::ScopeAttr attr) {
  (*this)->setAttr(memory_scopeAttrName(), attr);
}

void AtomicUMaxOp::semanticsAttr(::mlir::spirv::MemorySemanticsAttr attr) {
  (*this)->setAttr(semanticsAttrName(), attr);
}

void AtomicUMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value pointer, ::mlir::spirv::Scope scope, ::mlir::spirv::MemorySemantics memory, Value value) {
build(odsBuilder, odsState, value.getType(), pointer, scope, memory, value);
}

void AtomicUMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pointer, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(semanticsAttrName(odsState.name), semantics);
  odsState.addTypes(result);
}

void AtomicUMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pointer, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(semanticsAttrName(odsState.name), semantics);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicUMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pointer, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), semantics));
  odsState.addTypes(result);
}

void AtomicUMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pointer, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), semantics));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicUMaxOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AtomicUMaxOp::verifyInvariantsImpl() {
  {
    auto tblgen_memory_scope = (*this)->getAttr(memory_scopeAttrName());
    if (!tblgen_memory_scope)
      return emitOpError("requires attribute 'memory_scope'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps1(*this, tblgen_memory_scope, "memory_scope")))
      return ::mlir::failure();
  }
  {
    auto tblgen_semantics = (*this)->getAttr(semanticsAttrName());
    if (!tblgen_semantics)
      return emitOpError("requires attribute 'semantics'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps2(*this, tblgen_semantics, "semantics")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps0(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult AtomicUMaxOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::AtomicUMaxOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::AtomicUMinOp definitions
//===----------------------------------------------------------------------===//

AtomicUMinOpAdaptor::AtomicUMinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

AtomicUMinOpAdaptor::AtomicUMinOpAdaptor(AtomicUMinOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange AtomicUMinOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AtomicUMinOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AtomicUMinOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicUMinOpAdaptor::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::Value AtomicUMinOpAdaptor::value() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr AtomicUMinOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ScopeAttr AtomicUMinOpAdaptor::memory_scopeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ScopeAttr attr = odsAttrs.get("memory_scope").cast<::mlir::spirv::ScopeAttr>();
  return attr;
}

::mlir::spirv::Scope AtomicUMinOpAdaptor::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicUMinOpAdaptor::semanticsAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::MemorySemanticsAttr attr = odsAttrs.get("semantics").cast<::mlir::spirv::MemorySemanticsAttr>();
  return attr;
}

::mlir::spirv::MemorySemantics AtomicUMinOpAdaptor::semantics() {
  auto attr = semanticsAttr();
  return attr.getValue();
}

::mlir::LogicalResult AtomicUMinOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_memory_scope = odsAttrs.get("memory_scope");
    if (!tblgen_memory_scope)
      return emitError(loc, "'spv.AtomicUMin' op ""requires attribute 'memory_scope'");

    if (tblgen_memory_scope && !((((tblgen_memory_scope.isa<::mlir::IntegerAttr>())) && ((tblgen_memory_scope.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(tblgen_memory_scope.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.AtomicUMin' op ""attribute 'memory_scope' failed to satisfy constraint: valid SPIR-V Scope");
  }
  {
    auto tblgen_semantics = odsAttrs.get("semantics");
    if (!tblgen_semantics)
      return emitError(loc, "'spv.AtomicUMin' op ""requires attribute 'semantics'");

    if (tblgen_semantics && !((((tblgen_semantics.isa<::mlir::IntegerAttr>())) && ((tblgen_semantics.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics(tblgen_semantics.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.AtomicUMin' op ""attribute 'semantics' failed to satisfy constraint: valid SPIR-V MemorySemantics");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> AtomicUMinOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AtomicUMinOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicUMinOp::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::Value AtomicUMinOp::value() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange AtomicUMinOp::pointerMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange AtomicUMinOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> AtomicUMinOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AtomicUMinOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicUMinOp::result() {
  return *getODSResults(0).begin();
}

::mlir::spirv::ScopeAttr AtomicUMinOp::memory_scopeAttr() {
  return (*this)->getAttr(memory_scopeAttrName()).cast<::mlir::spirv::ScopeAttr>();
}

::mlir::spirv::Scope AtomicUMinOp::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicUMinOp::semanticsAttr() {
  return (*this)->getAttr(semanticsAttrName()).cast<::mlir::spirv::MemorySemanticsAttr>();
}

::mlir::spirv::MemorySemantics AtomicUMinOp::semantics() {
  auto attr = semanticsAttr();
  return attr.getValue();
}

void AtomicUMinOp::memory_scopeAttr(::mlir::spirv::ScopeAttr attr) {
  (*this)->setAttr(memory_scopeAttrName(), attr);
}

void AtomicUMinOp::semanticsAttr(::mlir::spirv::MemorySemanticsAttr attr) {
  (*this)->setAttr(semanticsAttrName(), attr);
}

void AtomicUMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value pointer, ::mlir::spirv::Scope scope, ::mlir::spirv::MemorySemantics memory, Value value) {
build(odsBuilder, odsState, value.getType(), pointer, scope, memory, value);
}

void AtomicUMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pointer, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(semanticsAttrName(odsState.name), semantics);
  odsState.addTypes(result);
}

void AtomicUMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pointer, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(semanticsAttrName(odsState.name), semantics);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicUMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pointer, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), semantics));
  odsState.addTypes(result);
}

void AtomicUMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pointer, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), semantics));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicUMinOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AtomicUMinOp::verifyInvariantsImpl() {
  {
    auto tblgen_memory_scope = (*this)->getAttr(memory_scopeAttrName());
    if (!tblgen_memory_scope)
      return emitOpError("requires attribute 'memory_scope'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps1(*this, tblgen_memory_scope, "memory_scope")))
      return ::mlir::failure();
  }
  {
    auto tblgen_semantics = (*this)->getAttr(semanticsAttrName());
    if (!tblgen_semantics)
      return emitOpError("requires attribute 'semantics'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps2(*this, tblgen_semantics, "semantics")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps0(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult AtomicUMinOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::AtomicUMinOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::AtomicXorOp definitions
//===----------------------------------------------------------------------===//

AtomicXorOpAdaptor::AtomicXorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

AtomicXorOpAdaptor::AtomicXorOpAdaptor(AtomicXorOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange AtomicXorOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AtomicXorOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AtomicXorOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicXorOpAdaptor::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::Value AtomicXorOpAdaptor::value() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr AtomicXorOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ScopeAttr AtomicXorOpAdaptor::memory_scopeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ScopeAttr attr = odsAttrs.get("memory_scope").cast<::mlir::spirv::ScopeAttr>();
  return attr;
}

::mlir::spirv::Scope AtomicXorOpAdaptor::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicXorOpAdaptor::semanticsAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::MemorySemanticsAttr attr = odsAttrs.get("semantics").cast<::mlir::spirv::MemorySemanticsAttr>();
  return attr;
}

::mlir::spirv::MemorySemantics AtomicXorOpAdaptor::semantics() {
  auto attr = semanticsAttr();
  return attr.getValue();
}

::mlir::LogicalResult AtomicXorOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_memory_scope = odsAttrs.get("memory_scope");
    if (!tblgen_memory_scope)
      return emitError(loc, "'spv.AtomicXor' op ""requires attribute 'memory_scope'");

    if (tblgen_memory_scope && !((((tblgen_memory_scope.isa<::mlir::IntegerAttr>())) && ((tblgen_memory_scope.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(tblgen_memory_scope.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.AtomicXor' op ""attribute 'memory_scope' failed to satisfy constraint: valid SPIR-V Scope");
  }
  {
    auto tblgen_semantics = odsAttrs.get("semantics");
    if (!tblgen_semantics)
      return emitError(loc, "'spv.AtomicXor' op ""requires attribute 'semantics'");

    if (tblgen_semantics && !((((tblgen_semantics.isa<::mlir::IntegerAttr>())) && ((tblgen_semantics.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics(tblgen_semantics.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.AtomicXor' op ""attribute 'semantics' failed to satisfy constraint: valid SPIR-V MemorySemantics");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> AtomicXorOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AtomicXorOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicXorOp::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::Value AtomicXorOp::value() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange AtomicXorOp::pointerMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange AtomicXorOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> AtomicXorOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AtomicXorOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicXorOp::result() {
  return *getODSResults(0).begin();
}

::mlir::spirv::ScopeAttr AtomicXorOp::memory_scopeAttr() {
  return (*this)->getAttr(memory_scopeAttrName()).cast<::mlir::spirv::ScopeAttr>();
}

::mlir::spirv::Scope AtomicXorOp::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr AtomicXorOp::semanticsAttr() {
  return (*this)->getAttr(semanticsAttrName()).cast<::mlir::spirv::MemorySemanticsAttr>();
}

::mlir::spirv::MemorySemantics AtomicXorOp::semantics() {
  auto attr = semanticsAttr();
  return attr.getValue();
}

void AtomicXorOp::memory_scopeAttr(::mlir::spirv::ScopeAttr attr) {
  (*this)->setAttr(memory_scopeAttrName(), attr);
}

void AtomicXorOp::semanticsAttr(::mlir::spirv::MemorySemanticsAttr attr) {
  (*this)->setAttr(semanticsAttrName(), attr);
}

void AtomicXorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value pointer, ::mlir::spirv::Scope scope, ::mlir::spirv::MemorySemantics memory, Value value) {
build(odsBuilder, odsState, value.getType(), pointer, scope, memory, value);
}

void AtomicXorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pointer, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(semanticsAttrName(odsState.name), semantics);
  odsState.addTypes(result);
}

void AtomicXorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pointer, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(semanticsAttrName(odsState.name), semantics);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicXorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pointer, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), semantics));
  odsState.addTypes(result);
}

void AtomicXorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pointer, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics semantics, ::mlir::Value value) {
  odsState.addOperands(pointer);
  odsState.addOperands(value);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), semantics));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicXorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AtomicXorOp::verifyInvariantsImpl() {
  {
    auto tblgen_memory_scope = (*this)->getAttr(memory_scopeAttrName());
    if (!tblgen_memory_scope)
      return emitOpError("requires attribute 'memory_scope'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps1(*this, tblgen_memory_scope, "memory_scope")))
      return ::mlir::failure();
  }
  {
    auto tblgen_semantics = (*this)->getAttr(semanticsAttrName());
    if (!tblgen_semantics)
      return emitOpError("requires attribute 'semantics'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps2(*this, tblgen_semantics, "semantics")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps0(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult AtomicXorOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::AtomicXorOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::BitCountOp definitions
//===----------------------------------------------------------------------===//

BitCountOpAdaptor::BitCountOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

BitCountOpAdaptor::BitCountOpAdaptor(BitCountOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange BitCountOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> BitCountOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BitCountOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitCountOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr BitCountOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult BitCountOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> BitCountOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BitCountOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitCountOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange BitCountOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> BitCountOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BitCountOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitCountOp::result() {
  return *getODSResults(0).begin();
}

void BitCountOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void BitCountOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BitCountOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void BitCountOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void BitCountOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult BitCountOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult BitCountOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult BitCountOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void BitCountOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void BitCountOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::BitCountOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::BitFieldInsertOp definitions
//===----------------------------------------------------------------------===//

BitFieldInsertOpAdaptor::BitFieldInsertOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

BitFieldInsertOpAdaptor::BitFieldInsertOpAdaptor(BitFieldInsertOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange BitFieldInsertOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> BitFieldInsertOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BitFieldInsertOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitFieldInsertOpAdaptor::base() {
  return *getODSOperands(0).begin();
}

::mlir::Value BitFieldInsertOpAdaptor::insert() {
  return *getODSOperands(1).begin();
}

::mlir::Value BitFieldInsertOpAdaptor::offset() {
  return *getODSOperands(2).begin();
}

::mlir::Value BitFieldInsertOpAdaptor::count() {
  return *getODSOperands(3).begin();
}

::mlir::DictionaryAttr BitFieldInsertOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult BitFieldInsertOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> BitFieldInsertOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BitFieldInsertOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitFieldInsertOp::base() {
  return *getODSOperands(0).begin();
}

::mlir::Value BitFieldInsertOp::insert() {
  return *getODSOperands(1).begin();
}

::mlir::Value BitFieldInsertOp::offset() {
  return *getODSOperands(2).begin();
}

::mlir::Value BitFieldInsertOp::count() {
  return *getODSOperands(3).begin();
}

::mlir::MutableOperandRange BitFieldInsertOp::baseMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange BitFieldInsertOp::insertMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange BitFieldInsertOp::offsetMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange BitFieldInsertOp::countMutable() {
  auto range = getODSOperandIndexAndLength(3);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> BitFieldInsertOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BitFieldInsertOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitFieldInsertOp::result() {
  return *getODSResults(0).begin();
}

void BitFieldInsertOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value base, ::mlir::Value insert, ::mlir::Value offset, ::mlir::Value count) {
  odsState.addOperands(base);
  odsState.addOperands(insert);
  odsState.addOperands(offset);
  odsState.addOperands(count);
  odsState.addTypes(result);
}

void BitFieldInsertOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value base, ::mlir::Value insert, ::mlir::Value offset, ::mlir::Value count) {
  odsState.addOperands(base);
  odsState.addOperands(insert);
  odsState.addOperands(offset);
  odsState.addOperands(count);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(BitFieldInsertOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      /*regions=*/{}, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void BitFieldInsertOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value base, ::mlir::Value insert, ::mlir::Value offset, ::mlir::Value count) {
  odsState.addOperands(base);
  odsState.addOperands(insert);
  odsState.addOperands(offset);
  odsState.addOperands(count);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BitFieldInsertOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 4u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void BitFieldInsertOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 4u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  ::mlir::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(BitFieldInsertOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::mlir::LogicalResult BitFieldInsertOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((::llvm::is_splat(::llvm::makeArrayRef({(*this->getODSOperands(0).begin()).getType(), (*this->getODSOperands(1).begin()).getType(), (*this->getODSResults(0).begin()).getType()})))))
    return emitOpError("failed to verify that all of {base, insert, result} have same type");
  return ::mlir::success();
}

::mlir::LogicalResult BitFieldInsertOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::LogicalResult BitFieldInsertOp::inferReturnTypes(::mlir::MLIRContext *context, ::llvm::Optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  inferredReturnTypes[0] = operands[1].getType();
  return ::mlir::success();
}

::mlir::ParseResult BitFieldInsertOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type baseRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> baseTypes(baseRawTypes);
  ::mlir::Type offsetRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> offsetTypes(offsetRawTypes);
  ::mlir::Type countRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> countTypes(countRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    baseRawTypes[0] = type;
  }
  if (parser.parseComma())
    return ::mlir::failure();

  {
    ::mlir::IntegerType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    offsetRawTypes[0] = type;
  }
  if (parser.parseComma())
    return ::mlir::failure();

  {
    ::mlir::IntegerType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    countRawTypes[0] = type;
  }
  result.addTypes(baseTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(baseTypes), ::llvm::ArrayRef<::mlir::Type>(baseTypes), ::llvm::ArrayRef<::mlir::Type>(offsetTypes), ::llvm::ArrayRef<::mlir::Type>(countTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void BitFieldInsertOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = base().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';
  {
    auto type = offset().getType();
    if (auto validType = type.dyn_cast<::mlir::IntegerType>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';
  {
    auto type = count().getType();
    if (auto validType = type.dyn_cast<::mlir::IntegerType>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void BitFieldInsertOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::BitFieldInsertOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::BitFieldSExtractOp definitions
//===----------------------------------------------------------------------===//

BitFieldSExtractOpAdaptor::BitFieldSExtractOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

BitFieldSExtractOpAdaptor::BitFieldSExtractOpAdaptor(BitFieldSExtractOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange BitFieldSExtractOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> BitFieldSExtractOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BitFieldSExtractOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitFieldSExtractOpAdaptor::base() {
  return *getODSOperands(0).begin();
}

::mlir::Value BitFieldSExtractOpAdaptor::offset() {
  return *getODSOperands(1).begin();
}

::mlir::Value BitFieldSExtractOpAdaptor::count() {
  return *getODSOperands(2).begin();
}

::mlir::DictionaryAttr BitFieldSExtractOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult BitFieldSExtractOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> BitFieldSExtractOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BitFieldSExtractOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitFieldSExtractOp::base() {
  return *getODSOperands(0).begin();
}

::mlir::Value BitFieldSExtractOp::offset() {
  return *getODSOperands(1).begin();
}

::mlir::Value BitFieldSExtractOp::count() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange BitFieldSExtractOp::baseMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange BitFieldSExtractOp::offsetMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange BitFieldSExtractOp::countMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> BitFieldSExtractOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BitFieldSExtractOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitFieldSExtractOp::result() {
  return *getODSResults(0).begin();
}

void BitFieldSExtractOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value base, ::mlir::Value offset, ::mlir::Value count) {
  odsState.addOperands(base);
  odsState.addOperands(offset);
  odsState.addOperands(count);
  odsState.addTypes(result);
}

void BitFieldSExtractOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value base, ::mlir::Value offset, ::mlir::Value count) {
  odsState.addOperands(base);
  odsState.addOperands(offset);
  odsState.addOperands(count);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(BitFieldSExtractOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      /*regions=*/{}, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void BitFieldSExtractOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value base, ::mlir::Value offset, ::mlir::Value count) {
  odsState.addOperands(base);
  odsState.addOperands(offset);
  odsState.addOperands(count);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BitFieldSExtractOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void BitFieldSExtractOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  ::mlir::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(BitFieldSExtractOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::mlir::LogicalResult BitFieldSExtractOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((::llvm::is_splat(::llvm::makeArrayRef({(*this->getODSOperands(0).begin()).getType(), (*this->getODSResults(0).begin()).getType()})))))
    return emitOpError("failed to verify that all of {base, result} have same type");
  return ::mlir::success();
}

::mlir::LogicalResult BitFieldSExtractOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::LogicalResult BitFieldSExtractOp::inferReturnTypes(::mlir::MLIRContext *context, ::llvm::Optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  inferredReturnTypes[0] = operands[0].getType();
  return ::mlir::success();
}

::mlir::ParseResult BitFieldSExtractOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type baseRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> baseTypes(baseRawTypes);
  ::mlir::Type offsetRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> offsetTypes(offsetRawTypes);
  ::mlir::Type countRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> countTypes(countRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    baseRawTypes[0] = type;
  }
  if (parser.parseComma())
    return ::mlir::failure();

  {
    ::mlir::IntegerType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    offsetRawTypes[0] = type;
  }
  if (parser.parseComma())
    return ::mlir::failure();

  {
    ::mlir::IntegerType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    countRawTypes[0] = type;
  }
  result.addTypes(baseTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(baseTypes), ::llvm::ArrayRef<::mlir::Type>(offsetTypes), ::llvm::ArrayRef<::mlir::Type>(countTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void BitFieldSExtractOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = base().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';
  {
    auto type = offset().getType();
    if (auto validType = type.dyn_cast<::mlir::IntegerType>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';
  {
    auto type = count().getType();
    if (auto validType = type.dyn_cast<::mlir::IntegerType>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void BitFieldSExtractOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::BitFieldSExtractOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::BitFieldUExtractOp definitions
//===----------------------------------------------------------------------===//

BitFieldUExtractOpAdaptor::BitFieldUExtractOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

BitFieldUExtractOpAdaptor::BitFieldUExtractOpAdaptor(BitFieldUExtractOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange BitFieldUExtractOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> BitFieldUExtractOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BitFieldUExtractOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitFieldUExtractOpAdaptor::base() {
  return *getODSOperands(0).begin();
}

::mlir::Value BitFieldUExtractOpAdaptor::offset() {
  return *getODSOperands(1).begin();
}

::mlir::Value BitFieldUExtractOpAdaptor::count() {
  return *getODSOperands(2).begin();
}

::mlir::DictionaryAttr BitFieldUExtractOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult BitFieldUExtractOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> BitFieldUExtractOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BitFieldUExtractOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitFieldUExtractOp::base() {
  return *getODSOperands(0).begin();
}

::mlir::Value BitFieldUExtractOp::offset() {
  return *getODSOperands(1).begin();
}

::mlir::Value BitFieldUExtractOp::count() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange BitFieldUExtractOp::baseMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange BitFieldUExtractOp::offsetMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange BitFieldUExtractOp::countMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> BitFieldUExtractOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BitFieldUExtractOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitFieldUExtractOp::result() {
  return *getODSResults(0).begin();
}

void BitFieldUExtractOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value base, ::mlir::Value offset, ::mlir::Value count) {
  odsState.addOperands(base);
  odsState.addOperands(offset);
  odsState.addOperands(count);
  odsState.addTypes(result);
}

void BitFieldUExtractOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value base, ::mlir::Value offset, ::mlir::Value count) {
  odsState.addOperands(base);
  odsState.addOperands(offset);
  odsState.addOperands(count);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(BitFieldUExtractOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      /*regions=*/{}, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void BitFieldUExtractOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value base, ::mlir::Value offset, ::mlir::Value count) {
  odsState.addOperands(base);
  odsState.addOperands(offset);
  odsState.addOperands(count);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BitFieldUExtractOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void BitFieldUExtractOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  ::mlir::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(BitFieldUExtractOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::mlir::LogicalResult BitFieldUExtractOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((::llvm::is_splat(::llvm::makeArrayRef({(*this->getODSOperands(0).begin()).getType(), (*this->getODSResults(0).begin()).getType()})))))
    return emitOpError("failed to verify that all of {base, result} have same type");
  return ::mlir::success();
}

::mlir::LogicalResult BitFieldUExtractOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::LogicalResult BitFieldUExtractOp::inferReturnTypes(::mlir::MLIRContext *context, ::llvm::Optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  inferredReturnTypes[0] = operands[0].getType();
  return ::mlir::success();
}

::mlir::ParseResult BitFieldUExtractOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type baseRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> baseTypes(baseRawTypes);
  ::mlir::Type offsetRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> offsetTypes(offsetRawTypes);
  ::mlir::Type countRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> countTypes(countRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    baseRawTypes[0] = type;
  }
  if (parser.parseComma())
    return ::mlir::failure();

  {
    ::mlir::IntegerType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    offsetRawTypes[0] = type;
  }
  if (parser.parseComma())
    return ::mlir::failure();

  {
    ::mlir::IntegerType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    countRawTypes[0] = type;
  }
  result.addTypes(baseTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(baseTypes), ::llvm::ArrayRef<::mlir::Type>(offsetTypes), ::llvm::ArrayRef<::mlir::Type>(countTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void BitFieldUExtractOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = base().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';
  {
    auto type = offset().getType();
    if (auto validType = type.dyn_cast<::mlir::IntegerType>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';
  {
    auto type = count().getType();
    if (auto validType = type.dyn_cast<::mlir::IntegerType>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void BitFieldUExtractOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::BitFieldUExtractOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::BitReverseOp definitions
//===----------------------------------------------------------------------===//

BitReverseOpAdaptor::BitReverseOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

BitReverseOpAdaptor::BitReverseOpAdaptor(BitReverseOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange BitReverseOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> BitReverseOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BitReverseOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitReverseOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr BitReverseOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult BitReverseOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> BitReverseOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BitReverseOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitReverseOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange BitReverseOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> BitReverseOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BitReverseOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitReverseOp::result() {
  return *getODSResults(0).begin();
}

void BitReverseOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void BitReverseOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BitReverseOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void BitReverseOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void BitReverseOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult BitReverseOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult BitReverseOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult BitReverseOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void BitReverseOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void BitReverseOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::BitReverseOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::BitcastOp definitions
//===----------------------------------------------------------------------===//

BitcastOpAdaptor::BitcastOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

BitcastOpAdaptor::BitcastOpAdaptor(BitcastOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange BitcastOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> BitcastOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BitcastOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitcastOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr BitcastOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult BitcastOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> BitcastOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BitcastOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitcastOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange BitcastOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> BitcastOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BitcastOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitcastOp::result() {
  return *getODSResults(0).begin();
}

void BitcastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void BitcastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BitcastOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult BitcastOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps5(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult BitcastOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult BitcastOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseKeyword("to"))
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void BitcastOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ' << "to";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void BitcastOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::BitcastOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::BitwiseAndOp definitions
//===----------------------------------------------------------------------===//

BitwiseAndOpAdaptor::BitwiseAndOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

BitwiseAndOpAdaptor::BitwiseAndOpAdaptor(BitwiseAndOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange BitwiseAndOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> BitwiseAndOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BitwiseAndOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitwiseAndOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value BitwiseAndOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr BitwiseAndOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult BitwiseAndOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> BitwiseAndOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BitwiseAndOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitwiseAndOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value BitwiseAndOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange BitwiseAndOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange BitwiseAndOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> BitwiseAndOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BitwiseAndOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitwiseAndOp::result() {
  return *getODSResults(0).begin();
}

void BitwiseAndOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void BitwiseAndOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BitwiseAndOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void BitwiseAndOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes({operand1.getType()});

}

void BitwiseAndOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult BitwiseAndOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult BitwiseAndOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult BitwiseAndOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(resultTypes), ::llvm::ArrayRef<::mlir::Type>(resultTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void BitwiseAndOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void BitwiseAndOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::BitwiseAndOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::BitwiseOrOp definitions
//===----------------------------------------------------------------------===//

BitwiseOrOpAdaptor::BitwiseOrOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

BitwiseOrOpAdaptor::BitwiseOrOpAdaptor(BitwiseOrOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange BitwiseOrOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> BitwiseOrOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BitwiseOrOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitwiseOrOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value BitwiseOrOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr BitwiseOrOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult BitwiseOrOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> BitwiseOrOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BitwiseOrOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitwiseOrOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value BitwiseOrOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange BitwiseOrOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange BitwiseOrOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> BitwiseOrOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BitwiseOrOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitwiseOrOp::result() {
  return *getODSResults(0).begin();
}

void BitwiseOrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void BitwiseOrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BitwiseOrOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void BitwiseOrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes({operand1.getType()});

}

void BitwiseOrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult BitwiseOrOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult BitwiseOrOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult BitwiseOrOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(resultTypes), ::llvm::ArrayRef<::mlir::Type>(resultTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void BitwiseOrOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void BitwiseOrOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::BitwiseOrOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::BitwiseXorOp definitions
//===----------------------------------------------------------------------===//

BitwiseXorOpAdaptor::BitwiseXorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

BitwiseXorOpAdaptor::BitwiseXorOpAdaptor(BitwiseXorOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange BitwiseXorOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> BitwiseXorOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BitwiseXorOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitwiseXorOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value BitwiseXorOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr BitwiseXorOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult BitwiseXorOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> BitwiseXorOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BitwiseXorOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitwiseXorOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value BitwiseXorOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange BitwiseXorOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange BitwiseXorOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> BitwiseXorOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BitwiseXorOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitwiseXorOp::result() {
  return *getODSResults(0).begin();
}

void BitwiseXorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void BitwiseXorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BitwiseXorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void BitwiseXorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes({operand1.getType()});

}

void BitwiseXorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult BitwiseXorOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult BitwiseXorOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult BitwiseXorOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(resultTypes), ::llvm::ArrayRef<::mlir::Type>(resultTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void BitwiseXorOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void BitwiseXorOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::BitwiseXorOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::BranchConditionalOp definitions
//===----------------------------------------------------------------------===//

BranchConditionalOpAdaptor::BranchConditionalOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

BranchConditionalOpAdaptor::BranchConditionalOpAdaptor(BranchConditionalOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange BranchConditionalOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> BranchConditionalOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  const uint32_t *sizeAttrValueIt = &*sizeAttr.value_begin<uint32_t>();
  if (sizeAttr.isSplat())
    return {*sizeAttrValueIt * index, *sizeAttrValueIt};

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttrValueIt[i];
  return {start, sizeAttrValueIt[index]};
}

::mlir::ValueRange BranchConditionalOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BranchConditionalOpAdaptor::condition() {
  return *getODSOperands(0).begin();
}

::mlir::ValueRange BranchConditionalOpAdaptor::trueTargetOperands() {
  return getODSOperands(1);
}

::mlir::ValueRange BranchConditionalOpAdaptor::falseTargetOperands() {
  return getODSOperands(2);
}

::mlir::DictionaryAttr BranchConditionalOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::ArrayAttr BranchConditionalOpAdaptor::branch_weightsAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("branch_weights").dyn_cast_or_null<::mlir::ArrayAttr>();
  return attr;
}

::llvm::Optional< ::mlir::ArrayAttr > BranchConditionalOpAdaptor::branch_weights() {
  auto attr = branch_weightsAttr();
  return attr ? ::llvm::Optional< ::mlir::ArrayAttr >(attr) : (::llvm::None);
}

::mlir::LogicalResult BranchConditionalOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").dyn_cast<::mlir::DenseIntElementsAttr>();
    if (!sizeAttr)
      return emitError(loc, "'spv.BranchConditional' op ""missing segment sizes attribute 'operand_segment_sizes'");
    auto numElements =
        sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 3)
      return emitError(loc, "'spv.BranchConditional' op ""'operand_segment_sizes' attribute for specifying operand segments must have 3 "
                "elements, but got ") << numElements;
  }
    {
    auto tblgen_branch_weights = odsAttrs.get("branch_weights");
    if (tblgen_branch_weights && !(((tblgen_branch_weights.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_branch_weights.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32))); }))))
      return emitError(loc, "'spv.BranchConditional' op ""attribute 'branch_weights' failed to satisfy constraint: 32-bit integer array attribute");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> BranchConditionalOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr =
      (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  const uint32_t *sizeAttrValueIt = &*sizeAttr.value_begin<uint32_t>();
  if (sizeAttr.isSplat())
    return {*sizeAttrValueIt * index, *sizeAttrValueIt};

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttrValueIt[i];
  return {start, sizeAttrValueIt[index]};
}

::mlir::Operation::operand_range BranchConditionalOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BranchConditionalOp::condition() {
  return *getODSOperands(0).begin();
}

::mlir::Operation::operand_range BranchConditionalOp::trueTargetOperands() {
  return getODSOperands(1);
}

::mlir::Operation::operand_range BranchConditionalOp::falseTargetOperands() {
  return getODSOperands(2);
}

::mlir::MutableOperandRange BranchConditionalOp::conditionMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
  return mutableRange;
}

::mlir::MutableOperandRange BranchConditionalOp::trueTargetOperandsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
  return mutableRange;
}

::mlir::MutableOperandRange BranchConditionalOp::falseTargetOperandsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
  return mutableRange;
}

std::pair<unsigned, unsigned> BranchConditionalOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BranchConditionalOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Block *BranchConditionalOp::trueTarget() {
  return (*this)->getSuccessor(0);
}

::mlir::Block *BranchConditionalOp::falseTarget() {
  return (*this)->getSuccessor(1);
}

::mlir::ArrayAttr BranchConditionalOp::branch_weightsAttr() {
  return (*this)->getAttr(branch_weightsAttrName()).dyn_cast_or_null<::mlir::ArrayAttr>();
}

::llvm::Optional< ::mlir::ArrayAttr > BranchConditionalOp::branch_weights() {
  auto attr = branch_weightsAttr();
  return attr ? ::llvm::Optional< ::mlir::ArrayAttr >(attr) : (::llvm::None);
}

void BranchConditionalOp::branch_weightsAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(branch_weightsAttrName(), attr);
}

::mlir::Attribute BranchConditionalOp::removeBranch_weightsAttr() {
  return (*this)->removeAttr(branch_weightsAttrName());
}

void BranchConditionalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value condition, Block *trueBlock, ValueRange trueArguments, Block *falseBlock, ValueRange falseArguments, Optional<std::pair<uint32_t, uint32_t>> weights) {
      ArrayAttr weightsAttr;
      if (weights) {
        weightsAttr =
            odsBuilder.getI32ArrayAttr({static_cast<int32_t>(weights->first),
                                     static_cast<int32_t>(weights->second)});
      }
      build(odsBuilder, odsState, condition, trueArguments, falseArguments,
            weightsAttr, trueBlock, falseBlock);
    
}

void BranchConditionalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value condition, ::mlir::ValueRange trueTargetOperands, ::mlir::ValueRange falseTargetOperands, /*optional*/::mlir::ArrayAttr branch_weights, ::mlir::Block *trueTarget, ::mlir::Block *falseTarget) {
  odsState.addOperands(condition);
  odsState.addOperands(trueTargetOperands);
  odsState.addOperands(falseTargetOperands);
  odsState.addAttribute(operand_segment_sizesAttrName(odsState.name), odsBuilder.getI32VectorAttr({1, static_cast<int32_t>(trueTargetOperands.size()), static_cast<int32_t>(falseTargetOperands.size())}));
  if (branch_weights) {
  odsState.addAttribute(branch_weightsAttrName(odsState.name), branch_weights);
  }
  odsState.addSuccessors(trueTarget);
  odsState.addSuccessors(falseTarget);
}

void BranchConditionalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value condition, ::mlir::ValueRange trueTargetOperands, ::mlir::ValueRange falseTargetOperands, /*optional*/::mlir::ArrayAttr branch_weights, ::mlir::Block *trueTarget, ::mlir::Block *falseTarget) {
  odsState.addOperands(condition);
  odsState.addOperands(trueTargetOperands);
  odsState.addOperands(falseTargetOperands);
  odsState.addAttribute(operand_segment_sizesAttrName(odsState.name), odsBuilder.getI32VectorAttr({1, static_cast<int32_t>(trueTargetOperands.size()), static_cast<int32_t>(falseTargetOperands.size())}));
  if (branch_weights) {
  odsState.addAttribute(branch_weightsAttrName(odsState.name), branch_weights);
  }
  odsState.addSuccessors(trueTarget);
  odsState.addSuccessors(falseTarget);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BranchConditionalOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult BranchConditionalOp::verifyInvariantsImpl() {
  {
    auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).dyn_cast<::mlir::DenseIntElementsAttr>();
    if (!sizeAttr)
      return emitOpError("missing segment sizes attribute 'operand_segment_sizes'");
    auto numElements =
        sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 3)
      return emitOpError("'operand_segment_sizes' attribute for specifying operand segments must have 3 "
                "elements, but got ") << numElements;
  }
    {
    auto tblgen_branch_weights = (*this)->getAttr(branch_weightsAttrName());
    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps3(*this, tblgen_branch_weights, "branch_weights")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps6(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps7(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps7(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  if (!((isNestedInFunctionOpInterface((*this->getOperation()).getParentOp()))))
    return emitOpError("failed to verify that op must appear in a function-like op's block");
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

::mlir::LogicalResult BranchConditionalOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

void BranchConditionalOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::BranchConditionalOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::BranchOp definitions
//===----------------------------------------------------------------------===//

BranchOpAdaptor::BranchOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

BranchOpAdaptor::BranchOpAdaptor(BranchOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange BranchOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> BranchOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange BranchOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange BranchOpAdaptor::targetOperands() {
  return getODSOperands(0);
}

::mlir::DictionaryAttr BranchOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult BranchOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> BranchOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range BranchOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range BranchOp::targetOperands() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange BranchOp::targetOperandsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> BranchOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BranchOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Block *BranchOp::target() {
  return (*this)->getSuccessor(0);
}

void BranchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Block *successor, ValueRange arguments) {
      odsState.addSuccessors(successor);
      odsState.addOperands(arguments);
    
}

::mlir::LogicalResult BranchOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps7(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  if (!((isNestedInFunctionOpInterface((*this->getOperation()).getParentOp()))))
    return emitOpError("failed to verify that op must appear in a function-like op's block");
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

::mlir::LogicalResult BranchOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult BranchOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::Block *targetSuccessor = nullptr;
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> targetOperandsOperands;
  ::llvm::SMLoc targetOperandsOperandsLoc;
  (void)targetOperandsOperandsLoc;
  ::mlir::SmallVector<::mlir::Type, 1> targetOperandsTypes;

  if (parser.parseSuccessor(targetSuccessor))
    return ::mlir::failure();
  if (succeeded(parser.parseOptionalLParen())) {

  targetOperandsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(targetOperandsOperands))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(targetOperandsTypes))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addSuccessors(targetSuccessor);
  if (parser.resolveOperands(targetOperandsOperands, targetOperandsTypes, targetOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void BranchOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << target();
  if (!targetOperands().empty()) {
  _odsPrinter << "(";
  _odsPrinter << targetOperands();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << targetOperands().getTypes();
  _odsPrinter << ")";
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void BranchOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::BranchOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::CompositeConstructOp definitions
//===----------------------------------------------------------------------===//

CompositeConstructOpAdaptor::CompositeConstructOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

CompositeConstructOpAdaptor::CompositeConstructOpAdaptor(CompositeConstructOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange CompositeConstructOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> CompositeConstructOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange CompositeConstructOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange CompositeConstructOpAdaptor::constituents() {
  return getODSOperands(0);
}

::mlir::DictionaryAttr CompositeConstructOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult CompositeConstructOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> CompositeConstructOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range CompositeConstructOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range CompositeConstructOp::constituents() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange CompositeConstructOp::constituentsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> CompositeConstructOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CompositeConstructOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CompositeConstructOp::result() {
  return *getODSResults(0).begin();
}

void CompositeConstructOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::ValueRange constituents) {
  odsState.addOperands(constituents);
  odsState.addTypes(result);
}

void CompositeConstructOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CompositeConstructOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps7(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps8(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult CompositeConstructOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

void CompositeConstructOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::CompositeConstructOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::CompositeExtractOp definitions
//===----------------------------------------------------------------------===//

CompositeExtractOpAdaptor::CompositeExtractOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

CompositeExtractOpAdaptor::CompositeExtractOpAdaptor(CompositeExtractOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange CompositeExtractOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> CompositeExtractOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CompositeExtractOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CompositeExtractOpAdaptor::composite() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr CompositeExtractOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::ArrayAttr CompositeExtractOpAdaptor::indicesAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("indices").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr CompositeExtractOpAdaptor::indices() {
  auto attr = indicesAttr();
  return attr;
}

::mlir::LogicalResult CompositeExtractOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_indices = odsAttrs.get("indices");
    if (!tblgen_indices)
      return emitError(loc, "'spv.CompositeExtract' op ""requires attribute 'indices'");

    if (tblgen_indices && !(((tblgen_indices.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_indices.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32))); }))))
      return emitError(loc, "'spv.CompositeExtract' op ""attribute 'indices' failed to satisfy constraint: 32-bit integer array attribute");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> CompositeExtractOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CompositeExtractOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CompositeExtractOp::composite() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange CompositeExtractOp::compositeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> CompositeExtractOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CompositeExtractOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CompositeExtractOp::component() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr CompositeExtractOp::indicesAttr() {
  return (*this)->getAttr(indicesAttrName()).cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr CompositeExtractOp::indices() {
  auto attr = indicesAttr();
  return attr;
}

void CompositeExtractOp::indicesAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(indicesAttrName(), attr);
}

void CompositeExtractOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type component, ::mlir::Value composite, ::mlir::ArrayAttr indices) {
  odsState.addOperands(composite);
  odsState.addAttribute(indicesAttrName(odsState.name), indices);
  odsState.addTypes(component);
}

void CompositeExtractOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value composite, ::mlir::ArrayAttr indices) {
  odsState.addOperands(composite);
  odsState.addAttribute(indicesAttrName(odsState.name), indices);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CompositeExtractOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CompositeExtractOp::verifyInvariantsImpl() {
  {
    auto tblgen_indices = (*this)->getAttr(indicesAttrName());
    if (!tblgen_indices)
      return emitOpError("requires attribute 'indices'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps3(*this, tblgen_indices, "indices")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps8(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps7(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult CompositeExtractOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

void CompositeExtractOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::CompositeExtractOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::CompositeInsertOp definitions
//===----------------------------------------------------------------------===//

CompositeInsertOpAdaptor::CompositeInsertOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

CompositeInsertOpAdaptor::CompositeInsertOpAdaptor(CompositeInsertOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange CompositeInsertOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> CompositeInsertOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CompositeInsertOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CompositeInsertOpAdaptor::object() {
  return *getODSOperands(0).begin();
}

::mlir::Value CompositeInsertOpAdaptor::composite() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr CompositeInsertOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::ArrayAttr CompositeInsertOpAdaptor::indicesAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("indices").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr CompositeInsertOpAdaptor::indices() {
  auto attr = indicesAttr();
  return attr;
}

::mlir::LogicalResult CompositeInsertOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_indices = odsAttrs.get("indices");
    if (!tblgen_indices)
      return emitError(loc, "'spv.CompositeInsert' op ""requires attribute 'indices'");

    if (tblgen_indices && !(((tblgen_indices.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_indices.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32))); }))))
      return emitError(loc, "'spv.CompositeInsert' op ""attribute 'indices' failed to satisfy constraint: 32-bit integer array attribute");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> CompositeInsertOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CompositeInsertOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CompositeInsertOp::object() {
  return *getODSOperands(0).begin();
}

::mlir::Value CompositeInsertOp::composite() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange CompositeInsertOp::objectMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange CompositeInsertOp::compositeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> CompositeInsertOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CompositeInsertOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CompositeInsertOp::result() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr CompositeInsertOp::indicesAttr() {
  return (*this)->getAttr(indicesAttrName()).cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr CompositeInsertOp::indices() {
  auto attr = indicesAttr();
  return attr;
}

void CompositeInsertOp::indicesAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(indicesAttrName(), attr);
}

void CompositeInsertOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value object, ::mlir::Value composite, ::mlir::ArrayAttr indices) {
  odsState.addOperands(object);
  odsState.addOperands(composite);
  odsState.addAttribute(indicesAttrName(odsState.name), indices);
  odsState.addTypes(result);
}

void CompositeInsertOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value object, ::mlir::Value composite, ::mlir::ArrayAttr indices) {
  odsState.addOperands(object);
  odsState.addOperands(composite);
  odsState.addAttribute(indicesAttrName(odsState.name), indices);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CompositeInsertOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CompositeInsertOp::verifyInvariantsImpl() {
  {
    auto tblgen_indices = (*this)->getAttr(indicesAttrName());
    if (!tblgen_indices)
      return emitOpError("requires attribute 'indices'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps3(*this, tblgen_indices, "indices")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps7(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps8(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps8(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult CompositeInsertOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

void CompositeInsertOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::CompositeInsertOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::ConstantOp definitions
//===----------------------------------------------------------------------===//

ConstantOpAdaptor::ConstantOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

ConstantOpAdaptor::ConstantOpAdaptor(ConstantOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange ConstantOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ConstantOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ConstantOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr ConstantOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::Attribute ConstantOpAdaptor::valueAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::Attribute attr = odsAttrs.get("value").cast<::mlir::Attribute>();
  return attr;
}

::mlir::Attribute ConstantOpAdaptor::value() {
  auto attr = valueAttr();
  return attr;
}

::mlir::LogicalResult ConstantOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_value = odsAttrs.get("value");
    if (!tblgen_value)
      return emitError(loc, "'spv.Constant' op ""requires attribute 'value'");

    if (tblgen_value && !((true)))
      return emitError(loc, "'spv.Constant' op ""attribute 'value' failed to satisfy constraint: any attribute");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> ConstantOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ConstantOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> ConstantOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ConstantOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConstantOp::constant() {
  return *getODSResults(0).begin();
}

::mlir::Attribute ConstantOp::valueAttr() {
  return (*this)->getAttr(valueAttrName()).cast<::mlir::Attribute>();
}

::mlir::Attribute ConstantOp::value() {
  auto attr = valueAttr();
  return attr;
}

void ConstantOp::valueAttr(::mlir::Attribute attr) {
  (*this)->setAttr(valueAttrName(), attr);
}

void ConstantOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type constant, ::mlir::Attribute value) {
  odsState.addAttribute(valueAttrName(odsState.name), value);
  odsState.addTypes(constant);
}

void ConstantOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Attribute value) {
  odsState.addAttribute(valueAttrName(odsState.name), value);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ConstantOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ConstantOp::verifyInvariantsImpl() {
  {
    auto tblgen_value = (*this)->getAttr(valueAttrName());
    if (!tblgen_value)
      return emitOpError("requires attribute 'value'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps4(*this, tblgen_value, "value")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps7(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult ConstantOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

void ConstantOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::ConstantOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::ControlBarrierOp definitions
//===----------------------------------------------------------------------===//

ControlBarrierOpAdaptor::ControlBarrierOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

ControlBarrierOpAdaptor::ControlBarrierOpAdaptor(ControlBarrierOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange ControlBarrierOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ControlBarrierOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ControlBarrierOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr ControlBarrierOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ScopeAttr ControlBarrierOpAdaptor::execution_scopeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ScopeAttr attr = odsAttrs.get("execution_scope").cast<::mlir::spirv::ScopeAttr>();
  return attr;
}

::mlir::spirv::Scope ControlBarrierOpAdaptor::execution_scope() {
  auto attr = execution_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::ScopeAttr ControlBarrierOpAdaptor::memory_scopeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ScopeAttr attr = odsAttrs.get("memory_scope").cast<::mlir::spirv::ScopeAttr>();
  return attr;
}

::mlir::spirv::Scope ControlBarrierOpAdaptor::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr ControlBarrierOpAdaptor::memory_semanticsAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::MemorySemanticsAttr attr = odsAttrs.get("memory_semantics").cast<::mlir::spirv::MemorySemanticsAttr>();
  return attr;
}

::mlir::spirv::MemorySemantics ControlBarrierOpAdaptor::memory_semantics() {
  auto attr = memory_semanticsAttr();
  return attr.getValue();
}

::mlir::LogicalResult ControlBarrierOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_execution_scope = odsAttrs.get("execution_scope");
    if (!tblgen_execution_scope)
      return emitError(loc, "'spv.ControlBarrier' op ""requires attribute 'execution_scope'");

    if (tblgen_execution_scope && !((((tblgen_execution_scope.isa<::mlir::IntegerAttr>())) && ((tblgen_execution_scope.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(tblgen_execution_scope.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.ControlBarrier' op ""attribute 'execution_scope' failed to satisfy constraint: valid SPIR-V Scope");
  }
  {
    auto tblgen_memory_scope = odsAttrs.get("memory_scope");
    if (!tblgen_memory_scope)
      return emitError(loc, "'spv.ControlBarrier' op ""requires attribute 'memory_scope'");

    if (tblgen_memory_scope && !((((tblgen_memory_scope.isa<::mlir::IntegerAttr>())) && ((tblgen_memory_scope.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(tblgen_memory_scope.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.ControlBarrier' op ""attribute 'memory_scope' failed to satisfy constraint: valid SPIR-V Scope");
  }
  {
    auto tblgen_memory_semantics = odsAttrs.get("memory_semantics");
    if (!tblgen_memory_semantics)
      return emitError(loc, "'spv.ControlBarrier' op ""requires attribute 'memory_semantics'");

    if (tblgen_memory_semantics && !((((tblgen_memory_semantics.isa<::mlir::IntegerAttr>())) && ((tblgen_memory_semantics.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics(tblgen_memory_semantics.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.ControlBarrier' op ""attribute 'memory_semantics' failed to satisfy constraint: valid SPIR-V MemorySemantics");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> ControlBarrierOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ControlBarrierOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> ControlBarrierOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ControlBarrierOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::spirv::ScopeAttr ControlBarrierOp::execution_scopeAttr() {
  return (*this)->getAttr(execution_scopeAttrName()).cast<::mlir::spirv::ScopeAttr>();
}

::mlir::spirv::Scope ControlBarrierOp::execution_scope() {
  auto attr = execution_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::ScopeAttr ControlBarrierOp::memory_scopeAttr() {
  return (*this)->getAttr(memory_scopeAttrName()).cast<::mlir::spirv::ScopeAttr>();
}

::mlir::spirv::Scope ControlBarrierOp::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr ControlBarrierOp::memory_semanticsAttr() {
  return (*this)->getAttr(memory_semanticsAttrName()).cast<::mlir::spirv::MemorySemanticsAttr>();
}

::mlir::spirv::MemorySemantics ControlBarrierOp::memory_semantics() {
  auto attr = memory_semanticsAttr();
  return attr.getValue();
}

void ControlBarrierOp::execution_scopeAttr(::mlir::spirv::ScopeAttr attr) {
  (*this)->setAttr(execution_scopeAttrName(), attr);
}

void ControlBarrierOp::memory_scopeAttr(::mlir::spirv::ScopeAttr attr) {
  (*this)->setAttr(memory_scopeAttrName(), attr);
}

void ControlBarrierOp::memory_semanticsAttr(::mlir::spirv::MemorySemanticsAttr attr) {
  (*this)->setAttr(memory_semanticsAttrName(), attr);
}

void ControlBarrierOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::spirv::ScopeAttr execution_scope, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr memory_semantics) {
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(memory_semanticsAttrName(odsState.name), memory_semantics);
}

void ControlBarrierOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::ScopeAttr execution_scope, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr memory_semantics) {
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(memory_semanticsAttrName(odsState.name), memory_semantics);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ControlBarrierOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::spirv::Scope execution_scope, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics memory_semantics) {
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(memory_semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), memory_semantics));
}

void ControlBarrierOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::Scope execution_scope, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics memory_semantics) {
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(memory_semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), memory_semantics));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ControlBarrierOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ControlBarrierOp::verifyInvariantsImpl() {
  {
    auto tblgen_execution_scope = (*this)->getAttr(execution_scopeAttrName());
    if (!tblgen_execution_scope)
      return emitOpError("requires attribute 'execution_scope'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps1(*this, tblgen_execution_scope, "execution_scope")))
      return ::mlir::failure();
  }
  {
    auto tblgen_memory_scope = (*this)->getAttr(memory_scopeAttrName());
    if (!tblgen_memory_scope)
      return emitOpError("requires attribute 'memory_scope'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps1(*this, tblgen_memory_scope, "memory_scope")))
      return ::mlir::failure();
  }
  {
    auto tblgen_memory_semantics = (*this)->getAttr(memory_semanticsAttrName());
    if (!tblgen_memory_semantics)
      return emitOpError("requires attribute 'memory_semantics'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps2(*this, tblgen_memory_semantics, "memory_semantics")))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::LogicalResult ControlBarrierOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult ControlBarrierOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::spirv::ScopeAttr execution_scopeAttr;
  ::mlir::spirv::ScopeAttr memory_scopeAttr;
  ::mlir::spirv::MemorySemanticsAttr memory_semanticsAttr;

  {
    ::llvm::StringRef attrStr;
    ::mlir::NamedAttrList attrStorage;
    auto loc = parser.getCurrentLocation();
    if (parser.parseOptionalKeyword(&attrStr, {"CrossDevice","Device","Workgroup","Subgroup","Invocation","QueueFamily","ShaderCallKHR"})) {
      ::mlir::StringAttr attrVal;
      ::mlir::OptionalParseResult parseResult =
        parser.parseOptionalAttribute(attrVal,
                                      parser.getBuilder().getNoneType(),
                                      "execution_scope", attrStorage);
      if (parseResult.hasValue()) {
        if (failed(*parseResult))
          return ::mlir::failure();
        attrStr = attrVal.getValue();
      } else {
        return parser.emitError(loc, "expected string or keyword containing one of the following enum values for attribute 'execution_scope' [CrossDevice, Device, Workgroup, Subgroup, Invocation, QueueFamily, ShaderCallKHR]");
      }
    }
    if (!attrStr.empty()) {
      auto attrOptional = ::mlir::spirv::symbolizeScope(attrStr);
      if (!attrOptional)
        return parser.emitError(loc, "invalid ")
               << "execution_scope attribute specification: \"" << attrStr << '"';;

      execution_scopeAttr = ::mlir::spirv::ScopeAttr::get(parser.getBuilder().getContext(), attrOptional.getValue());
      result.addAttribute("execution_scope", execution_scopeAttr);
    }
  }
  if (parser.parseComma())
    return ::mlir::failure();

  {
    ::llvm::StringRef attrStr;
    ::mlir::NamedAttrList attrStorage;
    auto loc = parser.getCurrentLocation();
    if (parser.parseOptionalKeyword(&attrStr, {"CrossDevice","Device","Workgroup","Subgroup","Invocation","QueueFamily","ShaderCallKHR"})) {
      ::mlir::StringAttr attrVal;
      ::mlir::OptionalParseResult parseResult =
        parser.parseOptionalAttribute(attrVal,
                                      parser.getBuilder().getNoneType(),
                                      "memory_scope", attrStorage);
      if (parseResult.hasValue()) {
        if (failed(*parseResult))
          return ::mlir::failure();
        attrStr = attrVal.getValue();
      } else {
        return parser.emitError(loc, "expected string or keyword containing one of the following enum values for attribute 'memory_scope' [CrossDevice, Device, Workgroup, Subgroup, Invocation, QueueFamily, ShaderCallKHR]");
      }
    }
    if (!attrStr.empty()) {
      auto attrOptional = ::mlir::spirv::symbolizeScope(attrStr);
      if (!attrOptional)
        return parser.emitError(loc, "invalid ")
               << "memory_scope attribute specification: \"" << attrStr << '"';;

      memory_scopeAttr = ::mlir::spirv::ScopeAttr::get(parser.getBuilder().getContext(), attrOptional.getValue());
      result.addAttribute("memory_scope", memory_scopeAttr);
    }
  }
  if (parser.parseComma())
    return ::mlir::failure();

  {
    ::llvm::StringRef attrStr;
    ::mlir::NamedAttrList attrStorage;
    auto loc = parser.getCurrentLocation();
    if (parser.parseOptionalKeyword(&attrStr, {"None","Acquire","Release","AcquireRelease","SequentiallyConsistent","UniformMemory","SubgroupMemory","WorkgroupMemory","CrossWorkgroupMemory","AtomicCounterMemory","ImageMemory","OutputMemory","MakeAvailable","MakeVisible","Volatile"})) {
      ::mlir::StringAttr attrVal;
      ::mlir::OptionalParseResult parseResult =
        parser.parseOptionalAttribute(attrVal,
                                      parser.getBuilder().getNoneType(),
                                      "memory_semantics", attrStorage);
      if (parseResult.hasValue()) {
        if (failed(*parseResult))
          return ::mlir::failure();
        attrStr = attrVal.getValue();
      } else {
        return parser.emitError(loc, "expected string or keyword containing one of the following enum values for attribute 'memory_semantics' [None, Acquire, Release, AcquireRelease, SequentiallyConsistent, UniformMemory, SubgroupMemory, WorkgroupMemory, CrossWorkgroupMemory, AtomicCounterMemory, ImageMemory, OutputMemory, MakeAvailable, MakeVisible, Volatile]");
      }
    }
    if (!attrStr.empty()) {
      auto attrOptional = ::mlir::spirv::symbolizeMemorySemantics(attrStr);
      if (!attrOptional)
        return parser.emitError(loc, "invalid ")
               << "memory_semantics attribute specification: \"" << attrStr << '"';;

      memory_semanticsAttr = ::mlir::spirv::MemorySemanticsAttr::get(parser.getBuilder().getContext(), attrOptional.getValue());
      result.addAttribute("memory_semantics", memory_semanticsAttr);
    }
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  return ::mlir::success();
}

void ControlBarrierOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';

  {
    auto caseValue = execution_scope();
    auto caseValueStr = stringifyScope(caseValue);
    _odsPrinter << caseValueStr;
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';

  {
    auto caseValue = memory_scope();
    auto caseValueStr = stringifyScope(caseValue);
    _odsPrinter << caseValueStr;
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';

  {
    auto caseValue = memory_semantics();
    auto caseValueStr = stringifyMemorySemantics(caseValue);
    switch (caseValue) {
    case ::mlir::spirv::MemorySemantics::Acquire:
    case ::mlir::spirv::MemorySemantics::Release:
    case ::mlir::spirv::MemorySemantics::AcquireRelease:
    case ::mlir::spirv::MemorySemantics::SequentiallyConsistent:
    case ::mlir::spirv::MemorySemantics::UniformMemory:
    case ::mlir::spirv::MemorySemantics::SubgroupMemory:
    case ::mlir::spirv::MemorySemantics::WorkgroupMemory:
    case ::mlir::spirv::MemorySemantics::CrossWorkgroupMemory:
    case ::mlir::spirv::MemorySemantics::AtomicCounterMemory:
    case ::mlir::spirv::MemorySemantics::ImageMemory:
    case ::mlir::spirv::MemorySemantics::OutputMemory:
    case ::mlir::spirv::MemorySemantics::MakeAvailable:
    case ::mlir::spirv::MemorySemantics::MakeVisible:
    case ::mlir::spirv::MemorySemantics::Volatile:
      _odsPrinter << caseValueStr;
      break;
    default:
      _odsPrinter << '"' << caseValueStr << '"';
      break;
    }
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"execution_scope", "memory_scope", "memory_semantics"});
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::ControlBarrierOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::ConvertFToSOp definitions
//===----------------------------------------------------------------------===//

ConvertFToSOpAdaptor::ConvertFToSOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

ConvertFToSOpAdaptor::ConvertFToSOpAdaptor(ConvertFToSOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange ConvertFToSOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ConvertFToSOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ConvertFToSOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConvertFToSOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr ConvertFToSOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult ConvertFToSOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> ConvertFToSOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ConvertFToSOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConvertFToSOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ConvertFToSOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> ConvertFToSOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ConvertFToSOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConvertFToSOp::result() {
  return *getODSResults(0).begin();
}

void ConvertFToSOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void ConvertFToSOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ConvertFToSOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ConvertFToSOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps10(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult ConvertFToSOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult ConvertFToSOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseKeyword("to"))
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ConvertFToSOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ' << "to";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void ConvertFToSOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::ConvertFToSOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::ConvertFToUOp definitions
//===----------------------------------------------------------------------===//

ConvertFToUOpAdaptor::ConvertFToUOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

ConvertFToUOpAdaptor::ConvertFToUOpAdaptor(ConvertFToUOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange ConvertFToUOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ConvertFToUOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ConvertFToUOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConvertFToUOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr ConvertFToUOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult ConvertFToUOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> ConvertFToUOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ConvertFToUOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConvertFToUOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ConvertFToUOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> ConvertFToUOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ConvertFToUOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConvertFToUOp::result() {
  return *getODSResults(0).begin();
}

void ConvertFToUOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void ConvertFToUOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ConvertFToUOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ConvertFToUOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps10(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult ConvertFToUOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult ConvertFToUOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseKeyword("to"))
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ConvertFToUOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ' << "to";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void ConvertFToUOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::ConvertFToUOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::ConvertSToFOp definitions
//===----------------------------------------------------------------------===//

ConvertSToFOpAdaptor::ConvertSToFOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

ConvertSToFOpAdaptor::ConvertSToFOpAdaptor(ConvertSToFOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange ConvertSToFOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ConvertSToFOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ConvertSToFOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConvertSToFOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr ConvertSToFOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult ConvertSToFOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> ConvertSToFOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ConvertSToFOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConvertSToFOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ConvertSToFOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> ConvertSToFOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ConvertSToFOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConvertSToFOp::result() {
  return *getODSResults(0).begin();
}

void ConvertSToFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void ConvertSToFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ConvertSToFOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ConvertSToFOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps10(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps9(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult ConvertSToFOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult ConvertSToFOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseKeyword("to"))
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ConvertSToFOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ' << "to";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void ConvertSToFOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::ConvertSToFOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::ConvertUToFOp definitions
//===----------------------------------------------------------------------===//

ConvertUToFOpAdaptor::ConvertUToFOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

ConvertUToFOpAdaptor::ConvertUToFOpAdaptor(ConvertUToFOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange ConvertUToFOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ConvertUToFOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ConvertUToFOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConvertUToFOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr ConvertUToFOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult ConvertUToFOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> ConvertUToFOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ConvertUToFOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConvertUToFOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ConvertUToFOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> ConvertUToFOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ConvertUToFOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConvertUToFOp::result() {
  return *getODSResults(0).begin();
}

void ConvertUToFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void ConvertUToFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ConvertUToFOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ConvertUToFOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps10(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps9(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult ConvertUToFOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult ConvertUToFOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseKeyword("to"))
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ConvertUToFOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ' << "to";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void ConvertUToFOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::ConvertUToFOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::CooperativeMatrixLengthNVOp definitions
//===----------------------------------------------------------------------===//

CooperativeMatrixLengthNVOpAdaptor::CooperativeMatrixLengthNVOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

CooperativeMatrixLengthNVOpAdaptor::CooperativeMatrixLengthNVOpAdaptor(CooperativeMatrixLengthNVOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange CooperativeMatrixLengthNVOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> CooperativeMatrixLengthNVOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CooperativeMatrixLengthNVOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr CooperativeMatrixLengthNVOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::TypeAttr CooperativeMatrixLengthNVOpAdaptor::typeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::TypeAttr attr = odsAttrs.get("type").cast<::mlir::TypeAttr>();
  return attr;
}

::mlir::Type CooperativeMatrixLengthNVOpAdaptor::type() {
  auto attr = typeAttr();
  return attr.getValue().cast<::mlir::Type>();
}

::mlir::LogicalResult CooperativeMatrixLengthNVOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_type = odsAttrs.get("type");
    if (!tblgen_type)
      return emitError(loc, "'spv.CooperativeMatrixLengthNV' op ""requires attribute 'type'");

    if (tblgen_type && !(((tblgen_type.isa<::mlir::TypeAttr>())) && ((tblgen_type.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>()))))
      return emitError(loc, "'spv.CooperativeMatrixLengthNV' op ""attribute 'type' failed to satisfy constraint: any type attribute");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> CooperativeMatrixLengthNVOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CooperativeMatrixLengthNVOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> CooperativeMatrixLengthNVOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CooperativeMatrixLengthNVOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CooperativeMatrixLengthNVOp::result() {
  return *getODSResults(0).begin();
}

::mlir::TypeAttr CooperativeMatrixLengthNVOp::typeAttr() {
  return (*this)->getAttr(typeAttrName()).cast<::mlir::TypeAttr>();
}

::mlir::Type CooperativeMatrixLengthNVOp::type() {
  auto attr = typeAttr();
  return attr.getValue().cast<::mlir::Type>();
}

void CooperativeMatrixLengthNVOp::typeAttr(::mlir::TypeAttr attr) {
  (*this)->setAttr(typeAttrName(), attr);
}

void CooperativeMatrixLengthNVOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::TypeAttr type) {
  odsState.addAttribute(typeAttrName(odsState.name), type);
  odsState.addTypes(result);
}

void CooperativeMatrixLengthNVOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeAttr type) {
  odsState.addAttribute(typeAttrName(odsState.name), type);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(CooperativeMatrixLengthNVOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      /*regions=*/{}, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void CooperativeMatrixLengthNVOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::TypeAttr type) {
  odsState.addAttribute(typeAttrName(odsState.name), type);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CooperativeMatrixLengthNVOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Type type) {
  odsState.addAttribute(typeAttrName(odsState.name), ::mlir::TypeAttr::get(type));
  odsState.addTypes(result);
}

void CooperativeMatrixLengthNVOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type type) {
  odsState.addAttribute(typeAttrName(odsState.name), ::mlir::TypeAttr::get(type));

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(CooperativeMatrixLengthNVOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      /*regions=*/{}, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void CooperativeMatrixLengthNVOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Type type) {
  odsState.addAttribute(typeAttrName(odsState.name), ::mlir::TypeAttr::get(type));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CooperativeMatrixLengthNVOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void CooperativeMatrixLengthNVOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  ::mlir::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(CooperativeMatrixLengthNVOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::mlir::LogicalResult CooperativeMatrixLengthNVOp::verifyInvariantsImpl() {
  {
    auto tblgen_type = (*this)->getAttr(typeAttrName());
    if (!tblgen_type)
      return emitOpError("requires attribute 'type'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps5(*this, tblgen_type, "type")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps11(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult CooperativeMatrixLengthNVOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::LogicalResult CooperativeMatrixLengthNVOp::inferReturnTypes(::mlir::MLIRContext *context, ::llvm::Optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  inferredReturnTypes[0] = odsBuilder.getIntegerType(32);
  return ::mlir::success();
}

::mlir::ParseResult CooperativeMatrixLengthNVOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::TypeAttr typeAttr;
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseCustomAttributeWithFallback(typeAttr, parser.getBuilder().getType<::mlir::NoneType>(), "type",
          result.attributes)) {
    return ::mlir::failure();
  }
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getIntegerType(32);
  result.addTypes(odsBuildableType0);
  return ::mlir::success();
}

void CooperativeMatrixLengthNVOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"type"});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter.printAttributeWithoutType(typeAttr());
}

void CooperativeMatrixLengthNVOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::CooperativeMatrixLengthNVOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::CooperativeMatrixLoadNVOp definitions
//===----------------------------------------------------------------------===//

CooperativeMatrixLoadNVOpAdaptor::CooperativeMatrixLoadNVOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

CooperativeMatrixLoadNVOpAdaptor::CooperativeMatrixLoadNVOpAdaptor(CooperativeMatrixLoadNVOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange CooperativeMatrixLoadNVOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> CooperativeMatrixLoadNVOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CooperativeMatrixLoadNVOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CooperativeMatrixLoadNVOpAdaptor::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::Value CooperativeMatrixLoadNVOpAdaptor::stride() {
  return *getODSOperands(1).begin();
}

::mlir::Value CooperativeMatrixLoadNVOpAdaptor::columnmajor() {
  return *getODSOperands(2).begin();
}

::mlir::DictionaryAttr CooperativeMatrixLoadNVOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::MemoryAccessAttr CooperativeMatrixLoadNVOpAdaptor::memory_accessAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::MemoryAccessAttr attr = odsAttrs.get("memory_access").dyn_cast_or_null<::mlir::spirv::MemoryAccessAttr>();
  return attr;
}

::llvm::Optional<::mlir::spirv::MemoryAccess> CooperativeMatrixLoadNVOpAdaptor::memory_access() {
  auto attr = memory_accessAttr();
  return attr ? ::llvm::Optional<::mlir::spirv::MemoryAccess>(attr.getValue()) : (::llvm::None);
}

::mlir::LogicalResult CooperativeMatrixLoadNVOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_memory_access = odsAttrs.get("memory_access");
    if (tblgen_memory_access && !((((tblgen_memory_access.isa<::mlir::IntegerAttr>())) && ((tblgen_memory_access.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemoryAccess(tblgen_memory_access.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.CooperativeMatrixLoadNV' op ""attribute 'memory_access' failed to satisfy constraint: valid SPIR-V MemoryAccess");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> CooperativeMatrixLoadNVOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CooperativeMatrixLoadNVOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CooperativeMatrixLoadNVOp::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::Value CooperativeMatrixLoadNVOp::stride() {
  return *getODSOperands(1).begin();
}

::mlir::Value CooperativeMatrixLoadNVOp::columnmajor() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange CooperativeMatrixLoadNVOp::pointerMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange CooperativeMatrixLoadNVOp::strideMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange CooperativeMatrixLoadNVOp::columnmajorMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> CooperativeMatrixLoadNVOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CooperativeMatrixLoadNVOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CooperativeMatrixLoadNVOp::result() {
  return *getODSResults(0).begin();
}

::mlir::spirv::MemoryAccessAttr CooperativeMatrixLoadNVOp::memory_accessAttr() {
  return (*this)->getAttr(memory_accessAttrName()).dyn_cast_or_null<::mlir::spirv::MemoryAccessAttr>();
}

::llvm::Optional<::mlir::spirv::MemoryAccess> CooperativeMatrixLoadNVOp::memory_access() {
  auto attr = memory_accessAttr();
  return attr ? ::llvm::Optional<::mlir::spirv::MemoryAccess>(attr.getValue()) : (::llvm::None);
}

void CooperativeMatrixLoadNVOp::memory_accessAttr(::mlir::spirv::MemoryAccessAttr attr) {
  (*this)->setAttr(memory_accessAttrName(), attr);
}

::mlir::Attribute CooperativeMatrixLoadNVOp::removeMemory_accessAttr() {
  return (*this)->removeAttr(memory_accessAttrName());
}

void CooperativeMatrixLoadNVOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pointer, ::mlir::Value stride, ::mlir::Value columnmajor, /*optional*/::mlir::spirv::MemoryAccessAttr memory_access) {
  odsState.addOperands(pointer);
  odsState.addOperands(stride);
  odsState.addOperands(columnmajor);
  if (memory_access) {
  odsState.addAttribute(memory_accessAttrName(odsState.name), memory_access);
  }
  odsState.addTypes(result);
}

void CooperativeMatrixLoadNVOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pointer, ::mlir::Value stride, ::mlir::Value columnmajor, /*optional*/::mlir::spirv::MemoryAccessAttr memory_access) {
  odsState.addOperands(pointer);
  odsState.addOperands(stride);
  odsState.addOperands(columnmajor);
  if (memory_access) {
  odsState.addAttribute(memory_accessAttrName(odsState.name), memory_access);
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CooperativeMatrixLoadNVOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CooperativeMatrixLoadNVOp::verifyInvariantsImpl() {
  {
    auto tblgen_memory_access = (*this)->getAttr(memory_accessAttrName());
    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps6(*this, tblgen_memory_access, "memory_access")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps0(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps6(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps12(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult CooperativeMatrixLoadNVOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::CooperativeMatrixLoadNVOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::CooperativeMatrixMulAddNVOp definitions
//===----------------------------------------------------------------------===//

CooperativeMatrixMulAddNVOpAdaptor::CooperativeMatrixMulAddNVOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

CooperativeMatrixMulAddNVOpAdaptor::CooperativeMatrixMulAddNVOpAdaptor(CooperativeMatrixMulAddNVOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange CooperativeMatrixMulAddNVOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> CooperativeMatrixMulAddNVOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CooperativeMatrixMulAddNVOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CooperativeMatrixMulAddNVOpAdaptor::a() {
  return *getODSOperands(0).begin();
}

::mlir::Value CooperativeMatrixMulAddNVOpAdaptor::b() {
  return *getODSOperands(1).begin();
}

::mlir::Value CooperativeMatrixMulAddNVOpAdaptor::c() {
  return *getODSOperands(2).begin();
}

::mlir::DictionaryAttr CooperativeMatrixMulAddNVOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult CooperativeMatrixMulAddNVOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> CooperativeMatrixMulAddNVOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CooperativeMatrixMulAddNVOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CooperativeMatrixMulAddNVOp::a() {
  return *getODSOperands(0).begin();
}

::mlir::Value CooperativeMatrixMulAddNVOp::b() {
  return *getODSOperands(1).begin();
}

::mlir::Value CooperativeMatrixMulAddNVOp::c() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange CooperativeMatrixMulAddNVOp::aMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange CooperativeMatrixMulAddNVOp::bMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange CooperativeMatrixMulAddNVOp::cMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> CooperativeMatrixMulAddNVOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CooperativeMatrixMulAddNVOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CooperativeMatrixMulAddNVOp::result() {
  return *getODSResults(0).begin();
}

void CooperativeMatrixMulAddNVOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value a, ::mlir::Value b, ::mlir::Value c) {
  odsState.addOperands(a);
  odsState.addOperands(b);
  odsState.addOperands(c);
  odsState.addTypes(result);
}

void CooperativeMatrixMulAddNVOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value a, ::mlir::Value b, ::mlir::Value c) {
  odsState.addOperands(a);
  odsState.addOperands(b);
  odsState.addOperands(c);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(CooperativeMatrixMulAddNVOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      /*regions=*/{}, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void CooperativeMatrixMulAddNVOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::Value b, ::mlir::Value c) {
  odsState.addOperands(a);
  odsState.addOperands(b);
  odsState.addOperands(c);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CooperativeMatrixMulAddNVOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void CooperativeMatrixMulAddNVOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  ::mlir::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(CooperativeMatrixMulAddNVOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::mlir::LogicalResult CooperativeMatrixMulAddNVOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps12(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps12(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps12(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps12(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((::llvm::is_splat(::llvm::makeArrayRef({(*this->getODSOperands(2).begin()).getType(), (*this->getODSResults(0).begin()).getType()})))))
    return emitOpError("failed to verify that all of {c, result} have same type");
  return ::mlir::success();
}

::mlir::LogicalResult CooperativeMatrixMulAddNVOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::LogicalResult CooperativeMatrixMulAddNVOp::inferReturnTypes(::mlir::MLIRContext *context, ::llvm::Optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  inferredReturnTypes[0] = operands[2].getType();
  return ::mlir::success();
}

::mlir::ParseResult CooperativeMatrixMulAddNVOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type aRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> aTypes(aRawTypes);
  ::mlir::Type bRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> bTypes(bRawTypes);
  ::mlir::Type cRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> cTypes(cRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    aRawTypes[0] = type;
  }
  if (parser.parseComma())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    bRawTypes[0] = type;
  }
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    cRawTypes[0] = type;
  }
  result.addTypes(cTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(aTypes), ::llvm::ArrayRef<::mlir::Type>(bTypes), ::llvm::ArrayRef<::mlir::Type>(cTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void CooperativeMatrixMulAddNVOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = a().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';
  {
    auto type = b().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ' << "->";
  _odsPrinter << ' ';
  {
    auto type = c().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void CooperativeMatrixMulAddNVOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::CooperativeMatrixMulAddNVOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::CooperativeMatrixStoreNVOp definitions
//===----------------------------------------------------------------------===//

CooperativeMatrixStoreNVOpAdaptor::CooperativeMatrixStoreNVOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

CooperativeMatrixStoreNVOpAdaptor::CooperativeMatrixStoreNVOpAdaptor(CooperativeMatrixStoreNVOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange CooperativeMatrixStoreNVOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> CooperativeMatrixStoreNVOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CooperativeMatrixStoreNVOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CooperativeMatrixStoreNVOpAdaptor::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::Value CooperativeMatrixStoreNVOpAdaptor::object() {
  return *getODSOperands(1).begin();
}

::mlir::Value CooperativeMatrixStoreNVOpAdaptor::stride() {
  return *getODSOperands(2).begin();
}

::mlir::Value CooperativeMatrixStoreNVOpAdaptor::columnmajor() {
  return *getODSOperands(3).begin();
}

::mlir::DictionaryAttr CooperativeMatrixStoreNVOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::MemoryAccessAttr CooperativeMatrixStoreNVOpAdaptor::memory_accessAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::MemoryAccessAttr attr = odsAttrs.get("memory_access").dyn_cast_or_null<::mlir::spirv::MemoryAccessAttr>();
  return attr;
}

::llvm::Optional<::mlir::spirv::MemoryAccess> CooperativeMatrixStoreNVOpAdaptor::memory_access() {
  auto attr = memory_accessAttr();
  return attr ? ::llvm::Optional<::mlir::spirv::MemoryAccess>(attr.getValue()) : (::llvm::None);
}

::mlir::LogicalResult CooperativeMatrixStoreNVOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_memory_access = odsAttrs.get("memory_access");
    if (tblgen_memory_access && !((((tblgen_memory_access.isa<::mlir::IntegerAttr>())) && ((tblgen_memory_access.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemoryAccess(tblgen_memory_access.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.CooperativeMatrixStoreNV' op ""attribute 'memory_access' failed to satisfy constraint: valid SPIR-V MemoryAccess");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> CooperativeMatrixStoreNVOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CooperativeMatrixStoreNVOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CooperativeMatrixStoreNVOp::pointer() {
  return *getODSOperands(0).begin();
}

::mlir::Value CooperativeMatrixStoreNVOp::object() {
  return *getODSOperands(1).begin();
}

::mlir::Value CooperativeMatrixStoreNVOp::stride() {
  return *getODSOperands(2).begin();
}

::mlir::Value CooperativeMatrixStoreNVOp::columnmajor() {
  return *getODSOperands(3).begin();
}

::mlir::MutableOperandRange CooperativeMatrixStoreNVOp::pointerMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange CooperativeMatrixStoreNVOp::objectMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange CooperativeMatrixStoreNVOp::strideMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange CooperativeMatrixStoreNVOp::columnmajorMutable() {
  auto range = getODSOperandIndexAndLength(3);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> CooperativeMatrixStoreNVOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CooperativeMatrixStoreNVOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::spirv::MemoryAccessAttr CooperativeMatrixStoreNVOp::memory_accessAttr() {
  return (*this)->getAttr(memory_accessAttrName()).dyn_cast_or_null<::mlir::spirv::MemoryAccessAttr>();
}

::llvm::Optional<::mlir::spirv::MemoryAccess> CooperativeMatrixStoreNVOp::memory_access() {
  auto attr = memory_accessAttr();
  return attr ? ::llvm::Optional<::mlir::spirv::MemoryAccess>(attr.getValue()) : (::llvm::None);
}

void CooperativeMatrixStoreNVOp::memory_accessAttr(::mlir::spirv::MemoryAccessAttr attr) {
  (*this)->setAttr(memory_accessAttrName(), attr);
}

::mlir::Attribute CooperativeMatrixStoreNVOp::removeMemory_accessAttr() {
  return (*this)->removeAttr(memory_accessAttrName());
}

void CooperativeMatrixStoreNVOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value pointer, ::mlir::Value object, ::mlir::Value stride, ::mlir::Value columnmajor, /*optional*/::mlir::spirv::MemoryAccessAttr memory_access) {
  odsState.addOperands(pointer);
  odsState.addOperands(object);
  odsState.addOperands(stride);
  odsState.addOperands(columnmajor);
  if (memory_access) {
  odsState.addAttribute(memory_accessAttrName(odsState.name), memory_access);
  }
}

void CooperativeMatrixStoreNVOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pointer, ::mlir::Value object, ::mlir::Value stride, ::mlir::Value columnmajor, /*optional*/::mlir::spirv::MemoryAccessAttr memory_access) {
  odsState.addOperands(pointer);
  odsState.addOperands(object);
  odsState.addOperands(stride);
  odsState.addOperands(columnmajor);
  if (memory_access) {
  odsState.addAttribute(memory_accessAttrName(odsState.name), memory_access);
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CooperativeMatrixStoreNVOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 4u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CooperativeMatrixStoreNVOp::verifyInvariantsImpl() {
  {
    auto tblgen_memory_access = (*this)->getAttr(memory_accessAttrName());
    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps6(*this, tblgen_memory_access, "memory_access")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps0(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps12(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps6(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult CooperativeMatrixStoreNVOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::CooperativeMatrixStoreNVOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::CopyMemoryOp definitions
//===----------------------------------------------------------------------===//

CopyMemoryOpAdaptor::CopyMemoryOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

CopyMemoryOpAdaptor::CopyMemoryOpAdaptor(CopyMemoryOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange CopyMemoryOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> CopyMemoryOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CopyMemoryOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CopyMemoryOpAdaptor::target() {
  return *getODSOperands(0).begin();
}

::mlir::Value CopyMemoryOpAdaptor::source() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr CopyMemoryOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::MemoryAccessAttr CopyMemoryOpAdaptor::memory_accessAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::MemoryAccessAttr attr = odsAttrs.get("memory_access").dyn_cast_or_null<::mlir::spirv::MemoryAccessAttr>();
  return attr;
}

::llvm::Optional<::mlir::spirv::MemoryAccess> CopyMemoryOpAdaptor::memory_access() {
  auto attr = memory_accessAttr();
  return attr ? ::llvm::Optional<::mlir::spirv::MemoryAccess>(attr.getValue()) : (::llvm::None);
}

::mlir::IntegerAttr CopyMemoryOpAdaptor::alignmentAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("alignment").dyn_cast_or_null<::mlir::IntegerAttr>();
  return attr;
}

::llvm::Optional<uint32_t> CopyMemoryOpAdaptor::alignment() {
  auto attr = alignmentAttr();
  return attr ? ::llvm::Optional<uint32_t>(attr.getValue().getZExtValue()) : (::llvm::None);
}

::mlir::spirv::MemoryAccessAttr CopyMemoryOpAdaptor::source_memory_accessAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::MemoryAccessAttr attr = odsAttrs.get("source_memory_access").dyn_cast_or_null<::mlir::spirv::MemoryAccessAttr>();
  return attr;
}

::llvm::Optional<::mlir::spirv::MemoryAccess> CopyMemoryOpAdaptor::source_memory_access() {
  auto attr = source_memory_accessAttr();
  return attr ? ::llvm::Optional<::mlir::spirv::MemoryAccess>(attr.getValue()) : (::llvm::None);
}

::mlir::IntegerAttr CopyMemoryOpAdaptor::source_alignmentAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("source_alignment").dyn_cast_or_null<::mlir::IntegerAttr>();
  return attr;
}

::llvm::Optional<uint32_t> CopyMemoryOpAdaptor::source_alignment() {
  auto attr = source_alignmentAttr();
  return attr ? ::llvm::Optional<uint32_t>(attr.getValue().getZExtValue()) : (::llvm::None);
}

::mlir::LogicalResult CopyMemoryOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_memory_access = odsAttrs.get("memory_access");
    if (tblgen_memory_access && !((((tblgen_memory_access.isa<::mlir::IntegerAttr>())) && ((tblgen_memory_access.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemoryAccess(tblgen_memory_access.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.CopyMemory' op ""attribute 'memory_access' failed to satisfy constraint: valid SPIR-V MemoryAccess");
  }
  {
    auto tblgen_alignment = odsAttrs.get("alignment");
    if (tblgen_alignment && !(((tblgen_alignment.isa<::mlir::IntegerAttr>())) && ((tblgen_alignment.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))))
      return emitError(loc, "'spv.CopyMemory' op ""attribute 'alignment' failed to satisfy constraint: 32-bit signless integer attribute");
  }
  {
    auto tblgen_source_memory_access = odsAttrs.get("source_memory_access");
    if (tblgen_source_memory_access && !((((tblgen_source_memory_access.isa<::mlir::IntegerAttr>())) && ((tblgen_source_memory_access.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemoryAccess(tblgen_source_memory_access.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.CopyMemory' op ""attribute 'source_memory_access' failed to satisfy constraint: valid SPIR-V MemoryAccess");
  }
  {
    auto tblgen_source_alignment = odsAttrs.get("source_alignment");
    if (tblgen_source_alignment && !(((tblgen_source_alignment.isa<::mlir::IntegerAttr>())) && ((tblgen_source_alignment.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))))
      return emitError(loc, "'spv.CopyMemory' op ""attribute 'source_alignment' failed to satisfy constraint: 32-bit signless integer attribute");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> CopyMemoryOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CopyMemoryOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CopyMemoryOp::target() {
  return *getODSOperands(0).begin();
}

::mlir::Value CopyMemoryOp::source() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange CopyMemoryOp::targetMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange CopyMemoryOp::sourceMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> CopyMemoryOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CopyMemoryOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::spirv::MemoryAccessAttr CopyMemoryOp::memory_accessAttr() {
  return (*this)->getAttr(memory_accessAttrName()).dyn_cast_or_null<::mlir::spirv::MemoryAccessAttr>();
}

::llvm::Optional<::mlir::spirv::MemoryAccess> CopyMemoryOp::memory_access() {
  auto attr = memory_accessAttr();
  return attr ? ::llvm::Optional<::mlir::spirv::MemoryAccess>(attr.getValue()) : (::llvm::None);
}

::mlir::IntegerAttr CopyMemoryOp::alignmentAttr() {
  return (*this)->getAttr(alignmentAttrName()).dyn_cast_or_null<::mlir::IntegerAttr>();
}

::llvm::Optional<uint32_t> CopyMemoryOp::alignment() {
  auto attr = alignmentAttr();
  return attr ? ::llvm::Optional<uint32_t>(attr.getValue().getZExtValue()) : (::llvm::None);
}

::mlir::spirv::MemoryAccessAttr CopyMemoryOp::source_memory_accessAttr() {
  return (*this)->getAttr(source_memory_accessAttrName()).dyn_cast_or_null<::mlir::spirv::MemoryAccessAttr>();
}

::llvm::Optional<::mlir::spirv::MemoryAccess> CopyMemoryOp::source_memory_access() {
  auto attr = source_memory_accessAttr();
  return attr ? ::llvm::Optional<::mlir::spirv::MemoryAccess>(attr.getValue()) : (::llvm::None);
}

::mlir::IntegerAttr CopyMemoryOp::source_alignmentAttr() {
  return (*this)->getAttr(source_alignmentAttrName()).dyn_cast_or_null<::mlir::IntegerAttr>();
}

::llvm::Optional<uint32_t> CopyMemoryOp::source_alignment() {
  auto attr = source_alignmentAttr();
  return attr ? ::llvm::Optional<uint32_t>(attr.getValue().getZExtValue()) : (::llvm::None);
}

void CopyMemoryOp::memory_accessAttr(::mlir::spirv::MemoryAccessAttr attr) {
  (*this)->setAttr(memory_accessAttrName(), attr);
}

void CopyMemoryOp::alignmentAttr(::mlir::IntegerAttr attr) {
  (*this)->setAttr(alignmentAttrName(), attr);
}

void CopyMemoryOp::source_memory_accessAttr(::mlir::spirv::MemoryAccessAttr attr) {
  (*this)->setAttr(source_memory_accessAttrName(), attr);
}

void CopyMemoryOp::source_alignmentAttr(::mlir::IntegerAttr attr) {
  (*this)->setAttr(source_alignmentAttrName(), attr);
}

::mlir::Attribute CopyMemoryOp::removeMemory_accessAttr() {
  return (*this)->removeAttr(memory_accessAttrName());
}

::mlir::Attribute CopyMemoryOp::removeAlignmentAttr() {
  return (*this)->removeAttr(alignmentAttrName());
}

::mlir::Attribute CopyMemoryOp::removeSource_memory_accessAttr() {
  return (*this)->removeAttr(source_memory_accessAttrName());
}

::mlir::Attribute CopyMemoryOp::removeSource_alignmentAttr() {
  return (*this)->removeAttr(source_alignmentAttrName());
}

void CopyMemoryOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value target, ::mlir::Value source, /*optional*/::mlir::spirv::MemoryAccessAttr memory_access, /*optional*/::mlir::IntegerAttr alignment, /*optional*/::mlir::spirv::MemoryAccessAttr source_memory_access, /*optional*/::mlir::IntegerAttr source_alignment) {
  odsState.addOperands(target);
  odsState.addOperands(source);
  if (memory_access) {
  odsState.addAttribute(memory_accessAttrName(odsState.name), memory_access);
  }
  if (alignment) {
  odsState.addAttribute(alignmentAttrName(odsState.name), alignment);
  }
  if (source_memory_access) {
  odsState.addAttribute(source_memory_accessAttrName(odsState.name), source_memory_access);
  }
  if (source_alignment) {
  odsState.addAttribute(source_alignmentAttrName(odsState.name), source_alignment);
  }
}

void CopyMemoryOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value target, ::mlir::Value source, /*optional*/::mlir::spirv::MemoryAccessAttr memory_access, /*optional*/::mlir::IntegerAttr alignment, /*optional*/::mlir::spirv::MemoryAccessAttr source_memory_access, /*optional*/::mlir::IntegerAttr source_alignment) {
  odsState.addOperands(target);
  odsState.addOperands(source);
  if (memory_access) {
  odsState.addAttribute(memory_accessAttrName(odsState.name), memory_access);
  }
  if (alignment) {
  odsState.addAttribute(alignmentAttrName(odsState.name), alignment);
  }
  if (source_memory_access) {
  odsState.addAttribute(source_memory_accessAttrName(odsState.name), source_memory_access);
  }
  if (source_alignment) {
  odsState.addAttribute(source_alignmentAttrName(odsState.name), source_alignment);
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CopyMemoryOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CopyMemoryOp::verifyInvariantsImpl() {
  {
    auto tblgen_memory_access = (*this)->getAttr(memory_accessAttrName());
    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps6(*this, tblgen_memory_access, "memory_access")))
      return ::mlir::failure();
  }
  {
    auto tblgen_alignment = (*this)->getAttr(alignmentAttrName());
    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps7(*this, tblgen_alignment, "alignment")))
      return ::mlir::failure();
  }
  {
    auto tblgen_source_memory_access = (*this)->getAttr(source_memory_accessAttrName());
    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps6(*this, tblgen_source_memory_access, "source_memory_access")))
      return ::mlir::failure();
  }
  {
    auto tblgen_source_alignment = (*this)->getAttr(source_alignmentAttrName());
    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps7(*this, tblgen_source_alignment, "source_alignment")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps0(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps0(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult CopyMemoryOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::CopyMemoryOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::EntryPointOp definitions
//===----------------------------------------------------------------------===//

EntryPointOpAdaptor::EntryPointOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

EntryPointOpAdaptor::EntryPointOpAdaptor(EntryPointOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange EntryPointOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> EntryPointOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange EntryPointOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr EntryPointOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ExecutionModelAttr EntryPointOpAdaptor::execution_modelAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ExecutionModelAttr attr = odsAttrs.get("execution_model").cast<::mlir::spirv::ExecutionModelAttr>();
  return attr;
}

::mlir::spirv::ExecutionModel EntryPointOpAdaptor::execution_model() {
  auto attr = execution_modelAttr();
  return attr.getValue();
}

::mlir::FlatSymbolRefAttr EntryPointOpAdaptor::fnAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FlatSymbolRefAttr attr = odsAttrs.get("fn").cast<::mlir::FlatSymbolRefAttr>();
  return attr;
}

::llvm::StringRef EntryPointOpAdaptor::fn() {
  auto attr = fnAttr();
  return attr.getValue();
}

::mlir::ArrayAttr EntryPointOpAdaptor::interfaceAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("interface").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr EntryPointOpAdaptor::interface() {
  auto attr = interfaceAttr();
  return attr;
}

::mlir::LogicalResult EntryPointOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_execution_model = odsAttrs.get("execution_model");
    if (!tblgen_execution_model)
      return emitError(loc, "'spv.EntryPoint' op ""requires attribute 'execution_model'");

    if (tblgen_execution_model && !((((tblgen_execution_model.isa<::mlir::IntegerAttr>())) && ((tblgen_execution_model.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeExecutionModel(tblgen_execution_model.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.EntryPoint' op ""attribute 'execution_model' failed to satisfy constraint: valid SPIR-V ExecutionModel");
  }
  {
    auto tblgen_fn = odsAttrs.get("fn");
    if (!tblgen_fn)
      return emitError(loc, "'spv.EntryPoint' op ""requires attribute 'fn'");

    if (tblgen_fn && !((tblgen_fn.isa<::mlir::FlatSymbolRefAttr>())))
      return emitError(loc, "'spv.EntryPoint' op ""attribute 'fn' failed to satisfy constraint: flat symbol reference attribute");
  }
  {
    auto tblgen_interface = odsAttrs.get("interface");
    if (!tblgen_interface)
      return emitError(loc, "'spv.EntryPoint' op ""requires attribute 'interface'");

    if (tblgen_interface && !(((tblgen_interface.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_interface.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return (attr.isa<::mlir::SymbolRefAttr>()); }))))
      return emitError(loc, "'spv.EntryPoint' op ""attribute 'interface' failed to satisfy constraint: symbol ref array attribute");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> EntryPointOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range EntryPointOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> EntryPointOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range EntryPointOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::spirv::ExecutionModelAttr EntryPointOp::execution_modelAttr() {
  return (*this)->getAttr(execution_modelAttrName()).cast<::mlir::spirv::ExecutionModelAttr>();
}

::mlir::spirv::ExecutionModel EntryPointOp::execution_model() {
  auto attr = execution_modelAttr();
  return attr.getValue();
}

::mlir::FlatSymbolRefAttr EntryPointOp::fnAttr() {
  return (*this)->getAttr(fnAttrName()).cast<::mlir::FlatSymbolRefAttr>();
}

::llvm::StringRef EntryPointOp::fn() {
  auto attr = fnAttr();
  return attr.getValue();
}

::mlir::ArrayAttr EntryPointOp::interfaceAttr() {
  return (*this)->getAttr(interfaceAttrName()).cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr EntryPointOp::interface() {
  auto attr = interfaceAttr();
  return attr;
}

void EntryPointOp::execution_modelAttr(::mlir::spirv::ExecutionModelAttr attr) {
  (*this)->setAttr(execution_modelAttrName(), attr);
}

void EntryPointOp::fnAttr(::mlir::FlatSymbolRefAttr attr) {
  (*this)->setAttr(fnAttrName(), attr);
}

void EntryPointOp::interfaceAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(interfaceAttrName(), attr);
}

void EntryPointOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::spirv::ExecutionModelAttr execution_model, ::mlir::FlatSymbolRefAttr fn, ::mlir::ArrayAttr interface) {
  odsState.addAttribute(execution_modelAttrName(odsState.name), execution_model);
  odsState.addAttribute(fnAttrName(odsState.name), fn);
  odsState.addAttribute(interfaceAttrName(odsState.name), interface);
}

void EntryPointOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::ExecutionModelAttr execution_model, ::mlir::FlatSymbolRefAttr fn, ::mlir::ArrayAttr interface) {
  odsState.addAttribute(execution_modelAttrName(odsState.name), execution_model);
  odsState.addAttribute(fnAttrName(odsState.name), fn);
  odsState.addAttribute(interfaceAttrName(odsState.name), interface);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void EntryPointOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::spirv::ExecutionModel execution_model, ::llvm::StringRef fn, ::mlir::ArrayAttr interface) {
  odsState.addAttribute(execution_modelAttrName(odsState.name), ::mlir::spirv::ExecutionModelAttr::get(odsBuilder.getContext(), execution_model));
  odsState.addAttribute(fnAttrName(odsState.name), ::mlir::SymbolRefAttr::get(odsBuilder.getContext(), fn));
  odsState.addAttribute(interfaceAttrName(odsState.name), interface);
}

void EntryPointOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::ExecutionModel execution_model, ::llvm::StringRef fn, ::mlir::ArrayAttr interface) {
  odsState.addAttribute(execution_modelAttrName(odsState.name), ::mlir::spirv::ExecutionModelAttr::get(odsBuilder.getContext(), execution_model));
  odsState.addAttribute(fnAttrName(odsState.name), ::mlir::SymbolRefAttr::get(odsBuilder.getContext(), fn));
  odsState.addAttribute(interfaceAttrName(odsState.name), interface);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void EntryPointOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult EntryPointOp::verifyInvariantsImpl() {
  {
    auto tblgen_execution_model = (*this)->getAttr(execution_modelAttrName());
    if (!tblgen_execution_model)
      return emitOpError("requires attribute 'execution_model'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps8(*this, tblgen_execution_model, "execution_model")))
      return ::mlir::failure();
  }
  {
    auto tblgen_fn = (*this)->getAttr(fnAttrName());
    if (!tblgen_fn)
      return emitOpError("requires attribute 'fn'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps0(*this, tblgen_fn, "fn")))
      return ::mlir::failure();
  }
  {
    auto tblgen_interface = (*this)->getAttr(interfaceAttrName());
    if (!tblgen_interface)
      return emitOpError("requires attribute 'interface'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps9(*this, tblgen_interface, "interface")))
      return ::mlir::failure();
  }
  if (!((isDirectInModuleLikeOp((*this->getOperation()).getParentOp()))))
    return emitOpError("failed to verify that op must appear in a module-like op's block");
  return ::mlir::success();
}

::mlir::LogicalResult EntryPointOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::EntryPointOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::ExecutionModeOp definitions
//===----------------------------------------------------------------------===//

ExecutionModeOpAdaptor::ExecutionModeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

ExecutionModeOpAdaptor::ExecutionModeOpAdaptor(ExecutionModeOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange ExecutionModeOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ExecutionModeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ExecutionModeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr ExecutionModeOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::FlatSymbolRefAttr ExecutionModeOpAdaptor::fnAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FlatSymbolRefAttr attr = odsAttrs.get("fn").cast<::mlir::FlatSymbolRefAttr>();
  return attr;
}

::llvm::StringRef ExecutionModeOpAdaptor::fn() {
  auto attr = fnAttr();
  return attr.getValue();
}

::mlir::spirv::ExecutionModeAttr ExecutionModeOpAdaptor::execution_modeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ExecutionModeAttr attr = odsAttrs.get("execution_mode").cast<::mlir::spirv::ExecutionModeAttr>();
  return attr;
}

::mlir::spirv::ExecutionMode ExecutionModeOpAdaptor::execution_mode() {
  auto attr = execution_modeAttr();
  return attr.getValue();
}

::mlir::ArrayAttr ExecutionModeOpAdaptor::valuesAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("values").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr ExecutionModeOpAdaptor::values() {
  auto attr = valuesAttr();
  return attr;
}

::mlir::LogicalResult ExecutionModeOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_fn = odsAttrs.get("fn");
    if (!tblgen_fn)
      return emitError(loc, "'spv.ExecutionMode' op ""requires attribute 'fn'");

    if (tblgen_fn && !((tblgen_fn.isa<::mlir::FlatSymbolRefAttr>())))
      return emitError(loc, "'spv.ExecutionMode' op ""attribute 'fn' failed to satisfy constraint: flat symbol reference attribute");
  }
  {
    auto tblgen_execution_mode = odsAttrs.get("execution_mode");
    if (!tblgen_execution_mode)
      return emitError(loc, "'spv.ExecutionMode' op ""requires attribute 'execution_mode'");

    if (tblgen_execution_mode && !((((tblgen_execution_mode.isa<::mlir::IntegerAttr>())) && ((tblgen_execution_mode.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeExecutionMode(tblgen_execution_mode.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.ExecutionMode' op ""attribute 'execution_mode' failed to satisfy constraint: valid SPIR-V ExecutionMode");
  }
  {
    auto tblgen_values = odsAttrs.get("values");
    if (!tblgen_values)
      return emitError(loc, "'spv.ExecutionMode' op ""requires attribute 'values'");

    if (tblgen_values && !(((tblgen_values.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_values.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32))); }))))
      return emitError(loc, "'spv.ExecutionMode' op ""attribute 'values' failed to satisfy constraint: 32-bit integer array attribute");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> ExecutionModeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ExecutionModeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> ExecutionModeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ExecutionModeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::FlatSymbolRefAttr ExecutionModeOp::fnAttr() {
  return (*this)->getAttr(fnAttrName()).cast<::mlir::FlatSymbolRefAttr>();
}

::llvm::StringRef ExecutionModeOp::fn() {
  auto attr = fnAttr();
  return attr.getValue();
}

::mlir::spirv::ExecutionModeAttr ExecutionModeOp::execution_modeAttr() {
  return (*this)->getAttr(execution_modeAttrName()).cast<::mlir::spirv::ExecutionModeAttr>();
}

::mlir::spirv::ExecutionMode ExecutionModeOp::execution_mode() {
  auto attr = execution_modeAttr();
  return attr.getValue();
}

::mlir::ArrayAttr ExecutionModeOp::valuesAttr() {
  return (*this)->getAttr(valuesAttrName()).cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr ExecutionModeOp::values() {
  auto attr = valuesAttr();
  return attr;
}

void ExecutionModeOp::fnAttr(::mlir::FlatSymbolRefAttr attr) {
  (*this)->setAttr(fnAttrName(), attr);
}

void ExecutionModeOp::execution_modeAttr(::mlir::spirv::ExecutionModeAttr attr) {
  (*this)->setAttr(execution_modeAttrName(), attr);
}

void ExecutionModeOp::valuesAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(valuesAttrName(), attr);
}

void ExecutionModeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::FlatSymbolRefAttr fn, ::mlir::spirv::ExecutionModeAttr execution_mode, ::mlir::ArrayAttr values) {
  odsState.addAttribute(fnAttrName(odsState.name), fn);
  odsState.addAttribute(execution_modeAttrName(odsState.name), execution_mode);
  odsState.addAttribute(valuesAttrName(odsState.name), values);
}

void ExecutionModeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::FlatSymbolRefAttr fn, ::mlir::spirv::ExecutionModeAttr execution_mode, ::mlir::ArrayAttr values) {
  odsState.addAttribute(fnAttrName(odsState.name), fn);
  odsState.addAttribute(execution_modeAttrName(odsState.name), execution_mode);
  odsState.addAttribute(valuesAttrName(odsState.name), values);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ExecutionModeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::llvm::StringRef fn, ::mlir::spirv::ExecutionMode execution_mode, ::mlir::ArrayAttr values) {
  odsState.addAttribute(fnAttrName(odsState.name), ::mlir::SymbolRefAttr::get(odsBuilder.getContext(), fn));
  odsState.addAttribute(execution_modeAttrName(odsState.name), ::mlir::spirv::ExecutionModeAttr::get(odsBuilder.getContext(), execution_mode));
  odsState.addAttribute(valuesAttrName(odsState.name), values);
}

void ExecutionModeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef fn, ::mlir::spirv::ExecutionMode execution_mode, ::mlir::ArrayAttr values) {
  odsState.addAttribute(fnAttrName(odsState.name), ::mlir::SymbolRefAttr::get(odsBuilder.getContext(), fn));
  odsState.addAttribute(execution_modeAttrName(odsState.name), ::mlir::spirv::ExecutionModeAttr::get(odsBuilder.getContext(), execution_mode));
  odsState.addAttribute(valuesAttrName(odsState.name), values);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ExecutionModeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ExecutionModeOp::verifyInvariantsImpl() {
  {
    auto tblgen_fn = (*this)->getAttr(fnAttrName());
    if (!tblgen_fn)
      return emitOpError("requires attribute 'fn'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps0(*this, tblgen_fn, "fn")))
      return ::mlir::failure();
  }
  {
    auto tblgen_execution_mode = (*this)->getAttr(execution_modeAttrName());
    if (!tblgen_execution_mode)
      return emitOpError("requires attribute 'execution_mode'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps10(*this, tblgen_execution_mode, "execution_mode")))
      return ::mlir::failure();
  }
  {
    auto tblgen_values = (*this)->getAttr(valuesAttrName());
    if (!tblgen_values)
      return emitOpError("requires attribute 'values'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps3(*this, tblgen_values, "values")))
      return ::mlir::failure();
  }
  if (!((isDirectInModuleLikeOp((*this->getOperation()).getParentOp()))))
    return emitOpError("failed to verify that op must appear in a module-like op's block");
  return ::mlir::success();
}

::mlir::LogicalResult ExecutionModeOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::ExecutionModeOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::FAddOp definitions
//===----------------------------------------------------------------------===//

FAddOpAdaptor::FAddOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

FAddOpAdaptor::FAddOpAdaptor(FAddOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange FAddOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FAddOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FAddOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FAddOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FAddOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr FAddOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult FAddOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> FAddOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FAddOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FAddOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FAddOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange FAddOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange FAddOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> FAddOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FAddOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FAddOp::result() {
  return *getODSResults(0).begin();
}

void FAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void FAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FAddOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void FAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes({operand1.getType()});

}

void FAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult FAddOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps9(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult FAddOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult FAddOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(resultTypes), ::llvm::ArrayRef<::mlir::Type>(resultTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FAddOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void FAddOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::FAddOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::FConvertOp definitions
//===----------------------------------------------------------------------===//

FConvertOpAdaptor::FConvertOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

FConvertOpAdaptor::FConvertOpAdaptor(FConvertOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange FConvertOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FConvertOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FConvertOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FConvertOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr FConvertOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult FConvertOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> FConvertOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FConvertOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FConvertOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange FConvertOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> FConvertOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FConvertOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FConvertOp::result() {
  return *getODSResults(0).begin();
}

void FConvertOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void FConvertOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FConvertOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FConvertOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps9(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult FConvertOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult FConvertOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseKeyword("to"))
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FConvertOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ' << "to";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void FConvertOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::FConvertOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::FDivOp definitions
//===----------------------------------------------------------------------===//

FDivOpAdaptor::FDivOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

FDivOpAdaptor::FDivOpAdaptor(FDivOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange FDivOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FDivOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FDivOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FDivOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FDivOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr FDivOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult FDivOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> FDivOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FDivOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FDivOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FDivOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange FDivOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange FDivOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> FDivOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FDivOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FDivOp::result() {
  return *getODSResults(0).begin();
}

void FDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void FDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FDivOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void FDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes({operand1.getType()});

}

void FDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult FDivOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps9(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult FDivOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult FDivOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(resultTypes), ::llvm::ArrayRef<::mlir::Type>(resultTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FDivOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void FDivOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::FDivOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::FModOp definitions
//===----------------------------------------------------------------------===//

FModOpAdaptor::FModOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

FModOpAdaptor::FModOpAdaptor(FModOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange FModOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FModOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FModOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FModOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FModOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr FModOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult FModOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> FModOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FModOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FModOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FModOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange FModOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange FModOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> FModOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FModOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FModOp::result() {
  return *getODSResults(0).begin();
}

void FModOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void FModOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FModOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void FModOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes({operand1.getType()});

}

void FModOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult FModOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps9(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult FModOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult FModOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(resultTypes), ::llvm::ArrayRef<::mlir::Type>(resultTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FModOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void FModOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::FModOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::FMulOp definitions
//===----------------------------------------------------------------------===//

FMulOpAdaptor::FMulOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

FMulOpAdaptor::FMulOpAdaptor(FMulOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange FMulOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FMulOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FMulOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FMulOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FMulOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr FMulOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult FMulOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> FMulOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FMulOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FMulOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FMulOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange FMulOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange FMulOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> FMulOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FMulOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FMulOp::result() {
  return *getODSResults(0).begin();
}

void FMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void FMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FMulOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void FMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes({operand1.getType()});

}

void FMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult FMulOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps9(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult FMulOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult FMulOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(resultTypes), ::llvm::ArrayRef<::mlir::Type>(resultTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FMulOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void FMulOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::FMulOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::FNegateOp definitions
//===----------------------------------------------------------------------===//

FNegateOpAdaptor::FNegateOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

FNegateOpAdaptor::FNegateOpAdaptor(FNegateOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange FNegateOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FNegateOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FNegateOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FNegateOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr FNegateOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult FNegateOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> FNegateOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FNegateOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FNegateOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange FNegateOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> FNegateOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FNegateOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FNegateOp::result() {
  return *getODSResults(0).begin();
}

void FNegateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void FNegateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FNegateOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void FNegateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void FNegateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult FNegateOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult FNegateOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult FNegateOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FNegateOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void FNegateOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::FNegateOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::FOrdEqualOp definitions
//===----------------------------------------------------------------------===//

FOrdEqualOpAdaptor::FOrdEqualOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

FOrdEqualOpAdaptor::FOrdEqualOpAdaptor(FOrdEqualOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange FOrdEqualOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FOrdEqualOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FOrdEqualOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FOrdEqualOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FOrdEqualOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr FOrdEqualOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult FOrdEqualOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> FOrdEqualOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FOrdEqualOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FOrdEqualOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FOrdEqualOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange FOrdEqualOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange FOrdEqualOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> FOrdEqualOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FOrdEqualOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FOrdEqualOp::result() {
  return *getODSResults(0).begin();
}

void FOrdEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value lhs, Value rhs) {
::buildLogicalBinaryOp(odsBuilder, odsState, lhs, rhs);
}

void FOrdEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void FOrdEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FOrdEqualOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FOrdEqualOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(getUnaryOpResultType((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of result to correspond to the `i1` equivalent of the operand");
  return ::mlir::success();
}

::mlir::LogicalResult FOrdEqualOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult FOrdEqualOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operand1RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand1Operands(operand1RawOperands);  ::llvm::SMLoc operand1OperandsLoc;
  (void)operand1OperandsLoc;
  ::mlir::OpAsmParser::OperandType operand2RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand2Operands(operand2RawOperands);  ::llvm::SMLoc operand2OperandsLoc;
  (void)operand2OperandsLoc;
  ::mlir::Type operand1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand1Types(operand1RawTypes);

  operand1OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand1RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  operand2OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand2RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand1RawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  for (::mlir::Type type : operand1Types) {
    (void)type;
    if (!((((type.isF16())) || ((type.isF32())) || ((type.isF64()))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isF16())) || ((elementType.isF32())) || ((elementType.isF64())); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
      return parser.emitError(parser.getNameLoc()) << "'operand1' must be 16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(getUnaryOpResultType(operand1Types[0]));
  if (parser.resolveOperands(operand1Operands, operand1Types, operand1OperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(operand2Operands, operand1Types[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FOrdEqualOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand1();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << operand2();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand1().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void FOrdEqualOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::FOrdEqualOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::FOrdGreaterThanEqualOp definitions
//===----------------------------------------------------------------------===//

FOrdGreaterThanEqualOpAdaptor::FOrdGreaterThanEqualOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

FOrdGreaterThanEqualOpAdaptor::FOrdGreaterThanEqualOpAdaptor(FOrdGreaterThanEqualOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange FOrdGreaterThanEqualOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FOrdGreaterThanEqualOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FOrdGreaterThanEqualOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FOrdGreaterThanEqualOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FOrdGreaterThanEqualOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr FOrdGreaterThanEqualOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult FOrdGreaterThanEqualOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> FOrdGreaterThanEqualOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FOrdGreaterThanEqualOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FOrdGreaterThanEqualOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FOrdGreaterThanEqualOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange FOrdGreaterThanEqualOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange FOrdGreaterThanEqualOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> FOrdGreaterThanEqualOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FOrdGreaterThanEqualOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FOrdGreaterThanEqualOp::result() {
  return *getODSResults(0).begin();
}

void FOrdGreaterThanEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value lhs, Value rhs) {
::buildLogicalBinaryOp(odsBuilder, odsState, lhs, rhs);
}

void FOrdGreaterThanEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void FOrdGreaterThanEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FOrdGreaterThanEqualOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FOrdGreaterThanEqualOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(getUnaryOpResultType((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of result to correspond to the `i1` equivalent of the operand");
  return ::mlir::success();
}

::mlir::LogicalResult FOrdGreaterThanEqualOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult FOrdGreaterThanEqualOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operand1RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand1Operands(operand1RawOperands);  ::llvm::SMLoc operand1OperandsLoc;
  (void)operand1OperandsLoc;
  ::mlir::OpAsmParser::OperandType operand2RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand2Operands(operand2RawOperands);  ::llvm::SMLoc operand2OperandsLoc;
  (void)operand2OperandsLoc;
  ::mlir::Type operand1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand1Types(operand1RawTypes);

  operand1OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand1RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  operand2OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand2RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand1RawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  for (::mlir::Type type : operand1Types) {
    (void)type;
    if (!((((type.isF16())) || ((type.isF32())) || ((type.isF64()))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isF16())) || ((elementType.isF32())) || ((elementType.isF64())); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
      return parser.emitError(parser.getNameLoc()) << "'operand1' must be 16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(getUnaryOpResultType(operand1Types[0]));
  if (parser.resolveOperands(operand1Operands, operand1Types, operand1OperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(operand2Operands, operand1Types[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FOrdGreaterThanEqualOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand1();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << operand2();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand1().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void FOrdGreaterThanEqualOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::FOrdGreaterThanEqualOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::FOrdGreaterThanOp definitions
//===----------------------------------------------------------------------===//

FOrdGreaterThanOpAdaptor::FOrdGreaterThanOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

FOrdGreaterThanOpAdaptor::FOrdGreaterThanOpAdaptor(FOrdGreaterThanOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange FOrdGreaterThanOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FOrdGreaterThanOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FOrdGreaterThanOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FOrdGreaterThanOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FOrdGreaterThanOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr FOrdGreaterThanOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult FOrdGreaterThanOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> FOrdGreaterThanOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FOrdGreaterThanOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FOrdGreaterThanOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FOrdGreaterThanOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange FOrdGreaterThanOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange FOrdGreaterThanOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> FOrdGreaterThanOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FOrdGreaterThanOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FOrdGreaterThanOp::result() {
  return *getODSResults(0).begin();
}

void FOrdGreaterThanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value lhs, Value rhs) {
::buildLogicalBinaryOp(odsBuilder, odsState, lhs, rhs);
}

void FOrdGreaterThanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void FOrdGreaterThanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FOrdGreaterThanOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FOrdGreaterThanOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(getUnaryOpResultType((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of result to correspond to the `i1` equivalent of the operand");
  return ::mlir::success();
}

::mlir::LogicalResult FOrdGreaterThanOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult FOrdGreaterThanOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operand1RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand1Operands(operand1RawOperands);  ::llvm::SMLoc operand1OperandsLoc;
  (void)operand1OperandsLoc;
  ::mlir::OpAsmParser::OperandType operand2RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand2Operands(operand2RawOperands);  ::llvm::SMLoc operand2OperandsLoc;
  (void)operand2OperandsLoc;
  ::mlir::Type operand1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand1Types(operand1RawTypes);

  operand1OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand1RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  operand2OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand2RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand1RawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  for (::mlir::Type type : operand1Types) {
    (void)type;
    if (!((((type.isF16())) || ((type.isF32())) || ((type.isF64()))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isF16())) || ((elementType.isF32())) || ((elementType.isF64())); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
      return parser.emitError(parser.getNameLoc()) << "'operand1' must be 16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(getUnaryOpResultType(operand1Types[0]));
  if (parser.resolveOperands(operand1Operands, operand1Types, operand1OperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(operand2Operands, operand1Types[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FOrdGreaterThanOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand1();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << operand2();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand1().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void FOrdGreaterThanOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::FOrdGreaterThanOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::FOrdLessThanEqualOp definitions
//===----------------------------------------------------------------------===//

FOrdLessThanEqualOpAdaptor::FOrdLessThanEqualOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

FOrdLessThanEqualOpAdaptor::FOrdLessThanEqualOpAdaptor(FOrdLessThanEqualOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange FOrdLessThanEqualOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FOrdLessThanEqualOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FOrdLessThanEqualOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FOrdLessThanEqualOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FOrdLessThanEqualOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr FOrdLessThanEqualOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult FOrdLessThanEqualOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> FOrdLessThanEqualOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FOrdLessThanEqualOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FOrdLessThanEqualOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FOrdLessThanEqualOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange FOrdLessThanEqualOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange FOrdLessThanEqualOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> FOrdLessThanEqualOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FOrdLessThanEqualOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FOrdLessThanEqualOp::result() {
  return *getODSResults(0).begin();
}

void FOrdLessThanEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value lhs, Value rhs) {
::buildLogicalBinaryOp(odsBuilder, odsState, lhs, rhs);
}

void FOrdLessThanEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void FOrdLessThanEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FOrdLessThanEqualOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FOrdLessThanEqualOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(getUnaryOpResultType((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of result to correspond to the `i1` equivalent of the operand");
  return ::mlir::success();
}

::mlir::LogicalResult FOrdLessThanEqualOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult FOrdLessThanEqualOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operand1RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand1Operands(operand1RawOperands);  ::llvm::SMLoc operand1OperandsLoc;
  (void)operand1OperandsLoc;
  ::mlir::OpAsmParser::OperandType operand2RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand2Operands(operand2RawOperands);  ::llvm::SMLoc operand2OperandsLoc;
  (void)operand2OperandsLoc;
  ::mlir::Type operand1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand1Types(operand1RawTypes);

  operand1OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand1RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  operand2OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand2RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand1RawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  for (::mlir::Type type : operand1Types) {
    (void)type;
    if (!((((type.isF16())) || ((type.isF32())) || ((type.isF64()))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isF16())) || ((elementType.isF32())) || ((elementType.isF64())); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
      return parser.emitError(parser.getNameLoc()) << "'operand1' must be 16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(getUnaryOpResultType(operand1Types[0]));
  if (parser.resolveOperands(operand1Operands, operand1Types, operand1OperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(operand2Operands, operand1Types[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FOrdLessThanEqualOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand1();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << operand2();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand1().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void FOrdLessThanEqualOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::FOrdLessThanEqualOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::FOrdLessThanOp definitions
//===----------------------------------------------------------------------===//

FOrdLessThanOpAdaptor::FOrdLessThanOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

FOrdLessThanOpAdaptor::FOrdLessThanOpAdaptor(FOrdLessThanOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange FOrdLessThanOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FOrdLessThanOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FOrdLessThanOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FOrdLessThanOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FOrdLessThanOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr FOrdLessThanOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult FOrdLessThanOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> FOrdLessThanOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FOrdLessThanOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FOrdLessThanOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FOrdLessThanOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange FOrdLessThanOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange FOrdLessThanOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> FOrdLessThanOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FOrdLessThanOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FOrdLessThanOp::result() {
  return *getODSResults(0).begin();
}

void FOrdLessThanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value lhs, Value rhs) {
::buildLogicalBinaryOp(odsBuilder, odsState, lhs, rhs);
}

void FOrdLessThanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void FOrdLessThanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FOrdLessThanOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FOrdLessThanOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(getUnaryOpResultType((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of result to correspond to the `i1` equivalent of the operand");
  return ::mlir::success();
}

::mlir::LogicalResult FOrdLessThanOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult FOrdLessThanOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operand1RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand1Operands(operand1RawOperands);  ::llvm::SMLoc operand1OperandsLoc;
  (void)operand1OperandsLoc;
  ::mlir::OpAsmParser::OperandType operand2RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand2Operands(operand2RawOperands);  ::llvm::SMLoc operand2OperandsLoc;
  (void)operand2OperandsLoc;
  ::mlir::Type operand1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand1Types(operand1RawTypes);

  operand1OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand1RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  operand2OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand2RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand1RawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  for (::mlir::Type type : operand1Types) {
    (void)type;
    if (!((((type.isF16())) || ((type.isF32())) || ((type.isF64()))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isF16())) || ((elementType.isF32())) || ((elementType.isF64())); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
      return parser.emitError(parser.getNameLoc()) << "'operand1' must be 16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(getUnaryOpResultType(operand1Types[0]));
  if (parser.resolveOperands(operand1Operands, operand1Types, operand1OperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(operand2Operands, operand1Types[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FOrdLessThanOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand1();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << operand2();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand1().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void FOrdLessThanOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::FOrdLessThanOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::FOrdNotEqualOp definitions
//===----------------------------------------------------------------------===//

FOrdNotEqualOpAdaptor::FOrdNotEqualOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

FOrdNotEqualOpAdaptor::FOrdNotEqualOpAdaptor(FOrdNotEqualOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange FOrdNotEqualOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FOrdNotEqualOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FOrdNotEqualOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FOrdNotEqualOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FOrdNotEqualOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr FOrdNotEqualOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult FOrdNotEqualOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> FOrdNotEqualOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FOrdNotEqualOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FOrdNotEqualOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FOrdNotEqualOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange FOrdNotEqualOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange FOrdNotEqualOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> FOrdNotEqualOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FOrdNotEqualOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FOrdNotEqualOp::result() {
  return *getODSResults(0).begin();
}

void FOrdNotEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value lhs, Value rhs) {
::buildLogicalBinaryOp(odsBuilder, odsState, lhs, rhs);
}

void FOrdNotEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void FOrdNotEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FOrdNotEqualOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FOrdNotEqualOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(getUnaryOpResultType((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of result to correspond to the `i1` equivalent of the operand");
  return ::mlir::success();
}

::mlir::LogicalResult FOrdNotEqualOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult FOrdNotEqualOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operand1RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand1Operands(operand1RawOperands);  ::llvm::SMLoc operand1OperandsLoc;
  (void)operand1OperandsLoc;
  ::mlir::OpAsmParser::OperandType operand2RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand2Operands(operand2RawOperands);  ::llvm::SMLoc operand2OperandsLoc;
  (void)operand2OperandsLoc;
  ::mlir::Type operand1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand1Types(operand1RawTypes);

  operand1OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand1RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  operand2OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand2RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand1RawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  for (::mlir::Type type : operand1Types) {
    (void)type;
    if (!((((type.isF16())) || ((type.isF32())) || ((type.isF64()))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isF16())) || ((elementType.isF32())) || ((elementType.isF64())); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
      return parser.emitError(parser.getNameLoc()) << "'operand1' must be 16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(getUnaryOpResultType(operand1Types[0]));
  if (parser.resolveOperands(operand1Operands, operand1Types, operand1OperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(operand2Operands, operand1Types[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FOrdNotEqualOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand1();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << operand2();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand1().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void FOrdNotEqualOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::FOrdNotEqualOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::FRemOp definitions
//===----------------------------------------------------------------------===//

FRemOpAdaptor::FRemOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

FRemOpAdaptor::FRemOpAdaptor(FRemOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange FRemOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FRemOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FRemOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FRemOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FRemOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr FRemOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult FRemOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> FRemOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FRemOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FRemOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FRemOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange FRemOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange FRemOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> FRemOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FRemOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FRemOp::result() {
  return *getODSResults(0).begin();
}

void FRemOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void FRemOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FRemOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void FRemOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes({operand1.getType()});

}

void FRemOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult FRemOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps9(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult FRemOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult FRemOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(resultTypes), ::llvm::ArrayRef<::mlir::Type>(resultTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FRemOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void FRemOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::FRemOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::FSubOp definitions
//===----------------------------------------------------------------------===//

FSubOpAdaptor::FSubOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

FSubOpAdaptor::FSubOpAdaptor(FSubOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange FSubOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FSubOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FSubOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FSubOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FSubOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr FSubOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult FSubOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> FSubOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FSubOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FSubOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FSubOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange FSubOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange FSubOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> FSubOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FSubOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FSubOp::result() {
  return *getODSResults(0).begin();
}

void FSubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void FSubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FSubOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void FSubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes({operand1.getType()});

}

void FSubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult FSubOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps9(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult FSubOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult FSubOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(resultTypes), ::llvm::ArrayRef<::mlir::Type>(resultTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FSubOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void FSubOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::FSubOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::FUnordEqualOp definitions
//===----------------------------------------------------------------------===//

FUnordEqualOpAdaptor::FUnordEqualOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

FUnordEqualOpAdaptor::FUnordEqualOpAdaptor(FUnordEqualOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange FUnordEqualOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FUnordEqualOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FUnordEqualOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FUnordEqualOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FUnordEqualOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr FUnordEqualOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult FUnordEqualOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> FUnordEqualOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FUnordEqualOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FUnordEqualOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FUnordEqualOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange FUnordEqualOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange FUnordEqualOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> FUnordEqualOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FUnordEqualOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FUnordEqualOp::result() {
  return *getODSResults(0).begin();
}

void FUnordEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value lhs, Value rhs) {
::buildLogicalBinaryOp(odsBuilder, odsState, lhs, rhs);
}

void FUnordEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void FUnordEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FUnordEqualOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FUnordEqualOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(getUnaryOpResultType((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of result to correspond to the `i1` equivalent of the operand");
  return ::mlir::success();
}

::mlir::LogicalResult FUnordEqualOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult FUnordEqualOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operand1RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand1Operands(operand1RawOperands);  ::llvm::SMLoc operand1OperandsLoc;
  (void)operand1OperandsLoc;
  ::mlir::OpAsmParser::OperandType operand2RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand2Operands(operand2RawOperands);  ::llvm::SMLoc operand2OperandsLoc;
  (void)operand2OperandsLoc;
  ::mlir::Type operand1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand1Types(operand1RawTypes);

  operand1OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand1RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  operand2OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand2RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand1RawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  for (::mlir::Type type : operand1Types) {
    (void)type;
    if (!((((type.isF16())) || ((type.isF32())) || ((type.isF64()))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isF16())) || ((elementType.isF32())) || ((elementType.isF64())); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
      return parser.emitError(parser.getNameLoc()) << "'operand1' must be 16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(getUnaryOpResultType(operand1Types[0]));
  if (parser.resolveOperands(operand1Operands, operand1Types, operand1OperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(operand2Operands, operand1Types[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FUnordEqualOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand1();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << operand2();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand1().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void FUnordEqualOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::FUnordEqualOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::FUnordGreaterThanEqualOp definitions
//===----------------------------------------------------------------------===//

FUnordGreaterThanEqualOpAdaptor::FUnordGreaterThanEqualOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

FUnordGreaterThanEqualOpAdaptor::FUnordGreaterThanEqualOpAdaptor(FUnordGreaterThanEqualOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange FUnordGreaterThanEqualOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FUnordGreaterThanEqualOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FUnordGreaterThanEqualOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FUnordGreaterThanEqualOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FUnordGreaterThanEqualOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr FUnordGreaterThanEqualOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult FUnordGreaterThanEqualOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> FUnordGreaterThanEqualOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FUnordGreaterThanEqualOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FUnordGreaterThanEqualOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FUnordGreaterThanEqualOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange FUnordGreaterThanEqualOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange FUnordGreaterThanEqualOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> FUnordGreaterThanEqualOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FUnordGreaterThanEqualOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FUnordGreaterThanEqualOp::result() {
  return *getODSResults(0).begin();
}

void FUnordGreaterThanEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value lhs, Value rhs) {
::buildLogicalBinaryOp(odsBuilder, odsState, lhs, rhs);
}

void FUnordGreaterThanEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void FUnordGreaterThanEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FUnordGreaterThanEqualOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FUnordGreaterThanEqualOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(getUnaryOpResultType((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of result to correspond to the `i1` equivalent of the operand");
  return ::mlir::success();
}

::mlir::LogicalResult FUnordGreaterThanEqualOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult FUnordGreaterThanEqualOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operand1RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand1Operands(operand1RawOperands);  ::llvm::SMLoc operand1OperandsLoc;
  (void)operand1OperandsLoc;
  ::mlir::OpAsmParser::OperandType operand2RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand2Operands(operand2RawOperands);  ::llvm::SMLoc operand2OperandsLoc;
  (void)operand2OperandsLoc;
  ::mlir::Type operand1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand1Types(operand1RawTypes);

  operand1OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand1RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  operand2OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand2RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand1RawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  for (::mlir::Type type : operand1Types) {
    (void)type;
    if (!((((type.isF16())) || ((type.isF32())) || ((type.isF64()))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isF16())) || ((elementType.isF32())) || ((elementType.isF64())); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
      return parser.emitError(parser.getNameLoc()) << "'operand1' must be 16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(getUnaryOpResultType(operand1Types[0]));
  if (parser.resolveOperands(operand1Operands, operand1Types, operand1OperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(operand2Operands, operand1Types[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FUnordGreaterThanEqualOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand1();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << operand2();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand1().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void FUnordGreaterThanEqualOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::FUnordGreaterThanEqualOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::FUnordGreaterThanOp definitions
//===----------------------------------------------------------------------===//

FUnordGreaterThanOpAdaptor::FUnordGreaterThanOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

FUnordGreaterThanOpAdaptor::FUnordGreaterThanOpAdaptor(FUnordGreaterThanOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange FUnordGreaterThanOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FUnordGreaterThanOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FUnordGreaterThanOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FUnordGreaterThanOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FUnordGreaterThanOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr FUnordGreaterThanOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult FUnordGreaterThanOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> FUnordGreaterThanOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FUnordGreaterThanOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FUnordGreaterThanOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FUnordGreaterThanOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange FUnordGreaterThanOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange FUnordGreaterThanOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> FUnordGreaterThanOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FUnordGreaterThanOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FUnordGreaterThanOp::result() {
  return *getODSResults(0).begin();
}

void FUnordGreaterThanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value lhs, Value rhs) {
::buildLogicalBinaryOp(odsBuilder, odsState, lhs, rhs);
}

void FUnordGreaterThanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void FUnordGreaterThanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FUnordGreaterThanOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FUnordGreaterThanOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(getUnaryOpResultType((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of result to correspond to the `i1` equivalent of the operand");
  return ::mlir::success();
}

::mlir::LogicalResult FUnordGreaterThanOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult FUnordGreaterThanOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operand1RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand1Operands(operand1RawOperands);  ::llvm::SMLoc operand1OperandsLoc;
  (void)operand1OperandsLoc;
  ::mlir::OpAsmParser::OperandType operand2RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand2Operands(operand2RawOperands);  ::llvm::SMLoc operand2OperandsLoc;
  (void)operand2OperandsLoc;
  ::mlir::Type operand1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand1Types(operand1RawTypes);

  operand1OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand1RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  operand2OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand2RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand1RawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  for (::mlir::Type type : operand1Types) {
    (void)type;
    if (!((((type.isF16())) || ((type.isF32())) || ((type.isF64()))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isF16())) || ((elementType.isF32())) || ((elementType.isF64())); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
      return parser.emitError(parser.getNameLoc()) << "'operand1' must be 16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(getUnaryOpResultType(operand1Types[0]));
  if (parser.resolveOperands(operand1Operands, operand1Types, operand1OperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(operand2Operands, operand1Types[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FUnordGreaterThanOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand1();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << operand2();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand1().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void FUnordGreaterThanOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::FUnordGreaterThanOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::FUnordLessThanEqualOp definitions
//===----------------------------------------------------------------------===//

FUnordLessThanEqualOpAdaptor::FUnordLessThanEqualOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

FUnordLessThanEqualOpAdaptor::FUnordLessThanEqualOpAdaptor(FUnordLessThanEqualOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange FUnordLessThanEqualOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FUnordLessThanEqualOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FUnordLessThanEqualOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FUnordLessThanEqualOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FUnordLessThanEqualOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr FUnordLessThanEqualOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult FUnordLessThanEqualOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> FUnordLessThanEqualOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FUnordLessThanEqualOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FUnordLessThanEqualOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FUnordLessThanEqualOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange FUnordLessThanEqualOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange FUnordLessThanEqualOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> FUnordLessThanEqualOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FUnordLessThanEqualOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FUnordLessThanEqualOp::result() {
  return *getODSResults(0).begin();
}

void FUnordLessThanEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value lhs, Value rhs) {
::buildLogicalBinaryOp(odsBuilder, odsState, lhs, rhs);
}

void FUnordLessThanEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void FUnordLessThanEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FUnordLessThanEqualOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FUnordLessThanEqualOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(getUnaryOpResultType((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of result to correspond to the `i1` equivalent of the operand");
  return ::mlir::success();
}

::mlir::LogicalResult FUnordLessThanEqualOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult FUnordLessThanEqualOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operand1RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand1Operands(operand1RawOperands);  ::llvm::SMLoc operand1OperandsLoc;
  (void)operand1OperandsLoc;
  ::mlir::OpAsmParser::OperandType operand2RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand2Operands(operand2RawOperands);  ::llvm::SMLoc operand2OperandsLoc;
  (void)operand2OperandsLoc;
  ::mlir::Type operand1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand1Types(operand1RawTypes);

  operand1OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand1RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  operand2OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand2RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand1RawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  for (::mlir::Type type : operand1Types) {
    (void)type;
    if (!((((type.isF16())) || ((type.isF32())) || ((type.isF64()))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isF16())) || ((elementType.isF32())) || ((elementType.isF64())); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
      return parser.emitError(parser.getNameLoc()) << "'operand1' must be 16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(getUnaryOpResultType(operand1Types[0]));
  if (parser.resolveOperands(operand1Operands, operand1Types, operand1OperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(operand2Operands, operand1Types[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FUnordLessThanEqualOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand1();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << operand2();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand1().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void FUnordLessThanEqualOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::FUnordLessThanEqualOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::FUnordLessThanOp definitions
//===----------------------------------------------------------------------===//

FUnordLessThanOpAdaptor::FUnordLessThanOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

FUnordLessThanOpAdaptor::FUnordLessThanOpAdaptor(FUnordLessThanOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange FUnordLessThanOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FUnordLessThanOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FUnordLessThanOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FUnordLessThanOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FUnordLessThanOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr FUnordLessThanOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult FUnordLessThanOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> FUnordLessThanOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FUnordLessThanOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FUnordLessThanOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FUnordLessThanOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange FUnordLessThanOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange FUnordLessThanOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> FUnordLessThanOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FUnordLessThanOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FUnordLessThanOp::result() {
  return *getODSResults(0).begin();
}

void FUnordLessThanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value lhs, Value rhs) {
::buildLogicalBinaryOp(odsBuilder, odsState, lhs, rhs);
}

void FUnordLessThanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void FUnordLessThanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FUnordLessThanOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FUnordLessThanOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(getUnaryOpResultType((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of result to correspond to the `i1` equivalent of the operand");
  return ::mlir::success();
}

::mlir::LogicalResult FUnordLessThanOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult FUnordLessThanOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operand1RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand1Operands(operand1RawOperands);  ::llvm::SMLoc operand1OperandsLoc;
  (void)operand1OperandsLoc;
  ::mlir::OpAsmParser::OperandType operand2RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand2Operands(operand2RawOperands);  ::llvm::SMLoc operand2OperandsLoc;
  (void)operand2OperandsLoc;
  ::mlir::Type operand1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand1Types(operand1RawTypes);

  operand1OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand1RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  operand2OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand2RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand1RawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  for (::mlir::Type type : operand1Types) {
    (void)type;
    if (!((((type.isF16())) || ((type.isF32())) || ((type.isF64()))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isF16())) || ((elementType.isF32())) || ((elementType.isF64())); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
      return parser.emitError(parser.getNameLoc()) << "'operand1' must be 16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(getUnaryOpResultType(operand1Types[0]));
  if (parser.resolveOperands(operand1Operands, operand1Types, operand1OperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(operand2Operands, operand1Types[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FUnordLessThanOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand1();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << operand2();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand1().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void FUnordLessThanOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::FUnordLessThanOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::FUnordNotEqualOp definitions
//===----------------------------------------------------------------------===//

FUnordNotEqualOpAdaptor::FUnordNotEqualOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

FUnordNotEqualOpAdaptor::FUnordNotEqualOpAdaptor(FUnordNotEqualOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange FUnordNotEqualOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FUnordNotEqualOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FUnordNotEqualOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FUnordNotEqualOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FUnordNotEqualOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr FUnordNotEqualOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult FUnordNotEqualOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> FUnordNotEqualOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FUnordNotEqualOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FUnordNotEqualOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value FUnordNotEqualOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange FUnordNotEqualOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange FUnordNotEqualOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> FUnordNotEqualOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FUnordNotEqualOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FUnordNotEqualOp::result() {
  return *getODSResults(0).begin();
}

void FUnordNotEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value lhs, Value rhs) {
::buildLogicalBinaryOp(odsBuilder, odsState, lhs, rhs);
}

void FUnordNotEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void FUnordNotEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FUnordNotEqualOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FUnordNotEqualOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(getUnaryOpResultType((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of result to correspond to the `i1` equivalent of the operand");
  return ::mlir::success();
}

::mlir::LogicalResult FUnordNotEqualOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult FUnordNotEqualOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operand1RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand1Operands(operand1RawOperands);  ::llvm::SMLoc operand1OperandsLoc;
  (void)operand1OperandsLoc;
  ::mlir::OpAsmParser::OperandType operand2RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand2Operands(operand2RawOperands);  ::llvm::SMLoc operand2OperandsLoc;
  (void)operand2OperandsLoc;
  ::mlir::Type operand1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand1Types(operand1RawTypes);

  operand1OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand1RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  operand2OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand2RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand1RawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  for (::mlir::Type type : operand1Types) {
    (void)type;
    if (!((((type.isF16())) || ((type.isF32())) || ((type.isF64()))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isF16())) || ((elementType.isF32())) || ((elementType.isF64())); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
      return parser.emitError(parser.getNameLoc()) << "'operand1' must be 16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(getUnaryOpResultType(operand1Types[0]));
  if (parser.resolveOperands(operand1Operands, operand1Types, operand1OperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(operand2Operands, operand1Types[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FUnordNotEqualOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand1();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << operand2();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand1().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void FUnordNotEqualOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::FUnordNotEqualOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::FuncOp definitions
//===----------------------------------------------------------------------===//

FuncOpAdaptor::FuncOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

FuncOpAdaptor::FuncOpAdaptor(FuncOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange FuncOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FuncOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FuncOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr FuncOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::TypeAttr FuncOpAdaptor::typeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::TypeAttr attr = odsAttrs.get("type").cast<::mlir::TypeAttr>();
  return attr;
}

::mlir::Type FuncOpAdaptor::type() {
  auto attr = typeAttr();
  return attr.getValue().cast<::mlir::Type>();
}

::mlir::StringAttr FuncOpAdaptor::sym_nameAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("sym_name").cast<::mlir::StringAttr>();
  return attr;
}

::llvm::StringRef FuncOpAdaptor::sym_name() {
  auto attr = sym_nameAttr();
  return attr.getValue();
}

::mlir::spirv::FunctionControlAttr FuncOpAdaptor::function_controlAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::FunctionControlAttr attr = odsAttrs.get("function_control").cast<::mlir::spirv::FunctionControlAttr>();
  return attr;
}

::mlir::spirv::FunctionControl FuncOpAdaptor::function_control() {
  auto attr = function_controlAttr();
  return attr.getValue();
}

::mlir::RegionRange FuncOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &FuncOpAdaptor::body() {
  return *odsRegions[0];
}

::mlir::LogicalResult FuncOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_type = odsAttrs.get("type");
    if (!tblgen_type)
      return emitError(loc, "'spv.func' op ""requires attribute 'type'");

    if (tblgen_type && !(((tblgen_type.isa<::mlir::TypeAttr>())) && ((tblgen_type.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>()))))
      return emitError(loc, "'spv.func' op ""attribute 'type' failed to satisfy constraint: any type attribute");
  }
  {
    auto tblgen_sym_name = odsAttrs.get("sym_name");
    if (!tblgen_sym_name)
      return emitError(loc, "'spv.func' op ""requires attribute 'sym_name'");

    if (tblgen_sym_name && !((tblgen_sym_name.isa<::mlir::StringAttr>())))
      return emitError(loc, "'spv.func' op ""attribute 'sym_name' failed to satisfy constraint: string attribute");
  }
  {
    auto tblgen_function_control = odsAttrs.get("function_control");
    if (!tblgen_function_control)
      return emitError(loc, "'spv.func' op ""requires attribute 'function_control'");

    if (tblgen_function_control && !((((tblgen_function_control.isa<::mlir::IntegerAttr>())) && ((tblgen_function_control.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeFunctionControl(tblgen_function_control.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.func' op ""attribute 'function_control' failed to satisfy constraint: valid SPIR-V FunctionControl");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> FuncOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FuncOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> FuncOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FuncOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Region &FuncOp::body() {
  return (*this)->getRegion(0);
}

::mlir::TypeAttr FuncOp::typeAttr() {
  return (*this)->getAttr(typeAttrName()).cast<::mlir::TypeAttr>();
}

::mlir::Type FuncOp::type() {
  auto attr = typeAttr();
  return attr.getValue().cast<::mlir::Type>();
}

::mlir::StringAttr FuncOp::sym_nameAttr() {
  return (*this)->getAttr(sym_nameAttrName()).cast<::mlir::StringAttr>();
}

::llvm::StringRef FuncOp::sym_name() {
  auto attr = sym_nameAttr();
  return attr.getValue();
}

::mlir::spirv::FunctionControlAttr FuncOp::function_controlAttr() {
  return (*this)->getAttr(function_controlAttrName()).cast<::mlir::spirv::FunctionControlAttr>();
}

::mlir::spirv::FunctionControl FuncOp::function_control() {
  auto attr = function_controlAttr();
  return attr.getValue();
}

void FuncOp::typeAttr(::mlir::TypeAttr attr) {
  (*this)->setAttr(typeAttrName(), attr);
}

void FuncOp::sym_nameAttr(::mlir::StringAttr attr) {
  (*this)->setAttr(sym_nameAttrName(), attr);
}

void FuncOp::function_controlAttr(::mlir::spirv::FunctionControlAttr attr) {
  (*this)->setAttr(function_controlAttrName(), attr);
}

void FuncOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeAttr type, ::mlir::StringAttr sym_name, ::mlir::spirv::FunctionControlAttr function_control) {
  odsState.addAttribute(typeAttrName(odsState.name), type);
  odsState.addAttribute(sym_nameAttrName(odsState.name), sym_name);
  odsState.addAttribute(function_controlAttrName(odsState.name), function_control);
  (void)odsState.addRegion();
}

void FuncOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::TypeAttr type, ::mlir::StringAttr sym_name, ::mlir::spirv::FunctionControlAttr function_control) {
  odsState.addAttribute(typeAttrName(odsState.name), type);
  odsState.addAttribute(sym_nameAttrName(odsState.name), sym_name);
  odsState.addAttribute(function_controlAttrName(odsState.name), function_control);
  (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FuncOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type type, ::llvm::StringRef sym_name, ::mlir::spirv::FunctionControl function_control) {
  odsState.addAttribute(typeAttrName(odsState.name), ::mlir::TypeAttr::get(type));
  odsState.addAttribute(sym_nameAttrName(odsState.name), odsBuilder.getStringAttr(sym_name));
  odsState.addAttribute(function_controlAttrName(odsState.name), ::mlir::spirv::FunctionControlAttr::get(odsBuilder.getContext(), function_control));
  (void)odsState.addRegion();
}

void FuncOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Type type, ::llvm::StringRef sym_name, ::mlir::spirv::FunctionControl function_control) {
  odsState.addAttribute(typeAttrName(odsState.name), ::mlir::TypeAttr::get(type));
  odsState.addAttribute(sym_nameAttrName(odsState.name), odsBuilder.getStringAttr(sym_name));
  odsState.addAttribute(function_controlAttrName(odsState.name), ::mlir::spirv::FunctionControlAttr::get(odsBuilder.getContext(), function_control));
  (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FuncOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 1; ++i)
    (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FuncOp::verifyInvariantsImpl() {
  {
    auto tblgen_type = (*this)->getAttr(typeAttrName());
    if (!tblgen_type)
      return emitOpError("requires attribute 'type'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps5(*this, tblgen_type, "type")))
      return ::mlir::failure();
  }
  {
    auto tblgen_sym_name = (*this)->getAttr(sym_nameAttrName());
    if (!tblgen_sym_name)
      return emitOpError("requires attribute 'sym_name'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps11(*this, tblgen_sym_name, "sym_name")))
      return ::mlir::failure();
  }
  {
    auto tblgen_function_control = (*this)->getAttr(function_controlAttrName());
    if (!tblgen_function_control)
      return emitOpError("requires attribute 'function_control'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps12(*this, tblgen_function_control, "function_control")))
      return ::mlir::failure();
  }
  if (!((isDirectInModuleLikeOp((*this->getOperation()).getParentOp()))))
    return emitOpError("failed to verify that op must appear in a module-like op's block");
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::makeMutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_SPIRVOps0(*this, region, "body", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::LogicalResult FuncOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::FuncOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::FunctionCallOp definitions
//===----------------------------------------------------------------------===//

FunctionCallOpAdaptor::FunctionCallOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

FunctionCallOpAdaptor::FunctionCallOpAdaptor(FunctionCallOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange FunctionCallOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FunctionCallOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange FunctionCallOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange FunctionCallOpAdaptor::arguments() {
  return getODSOperands(0);
}

::mlir::DictionaryAttr FunctionCallOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::FlatSymbolRefAttr FunctionCallOpAdaptor::calleeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FlatSymbolRefAttr attr = odsAttrs.get("callee").cast<::mlir::FlatSymbolRefAttr>();
  return attr;
}

::llvm::StringRef FunctionCallOpAdaptor::callee() {
  auto attr = calleeAttr();
  return attr.getValue();
}

::mlir::LogicalResult FunctionCallOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_callee = odsAttrs.get("callee");
    if (!tblgen_callee)
      return emitError(loc, "'spv.FunctionCall' op ""requires attribute 'callee'");

    if (tblgen_callee && !((tblgen_callee.isa<::mlir::FlatSymbolRefAttr>())))
      return emitError(loc, "'spv.FunctionCall' op ""attribute 'callee' failed to satisfy constraint: flat symbol reference attribute");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> FunctionCallOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range FunctionCallOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range FunctionCallOp::arguments() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange FunctionCallOp::argumentsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> FunctionCallOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range FunctionCallOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FunctionCallOp::result() {
  auto results = getODSResults(0);
  return results.empty() ? ::mlir::Value() : *results.begin();
}

::mlir::FlatSymbolRefAttr FunctionCallOp::calleeAttr() {
  return (*this)->getAttr(calleeAttrName()).cast<::mlir::FlatSymbolRefAttr>();
}

::llvm::StringRef FunctionCallOp::callee() {
  auto attr = calleeAttr();
  return attr.getValue();
}

void FunctionCallOp::calleeAttr(::mlir::FlatSymbolRefAttr attr) {
  (*this)->setAttr(calleeAttrName(), attr);
}

void FunctionCallOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Type result, ::mlir::FlatSymbolRefAttr callee, ::mlir::ValueRange arguments) {
  odsState.addOperands(arguments);
  odsState.addAttribute(calleeAttrName(odsState.name), callee);
  if (result)
    odsState.addTypes(result);
}

void FunctionCallOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::FlatSymbolRefAttr callee, ::mlir::ValueRange arguments) {
  odsState.addOperands(arguments);
  odsState.addAttribute(calleeAttrName(odsState.name), callee);
  odsState.addTypes(resultTypes);
}

void FunctionCallOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Type result, ::llvm::StringRef callee, ::mlir::ValueRange arguments) {
  odsState.addOperands(arguments);
  odsState.addAttribute(calleeAttrName(odsState.name), ::mlir::SymbolRefAttr::get(odsBuilder.getContext(), callee));
  if (result)
    odsState.addTypes(result);
}

void FunctionCallOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef callee, ::mlir::ValueRange arguments) {
  odsState.addOperands(arguments);
  odsState.addAttribute(calleeAttrName(odsState.name), ::mlir::SymbolRefAttr::get(odsBuilder.getContext(), callee));
  odsState.addTypes(resultTypes);
}

void FunctionCallOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FunctionCallOp::verifyInvariantsImpl() {
  {
    auto tblgen_callee = (*this)->getAttr(calleeAttrName());
    if (!tblgen_callee)
      return emitOpError("requires attribute 'callee'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps0(*this, tblgen_callee, "callee")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps7(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    if (valueGroup0.size() > 1) {
      return emitOpError("result group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup0.size();
    }

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps7(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((isNestedInFunctionOpInterface((*this->getOperation()).getParentOp()))))
    return emitOpError("failed to verify that op must appear in a function-like op's block");
  return ::mlir::success();
}

::mlir::LogicalResult FunctionCallOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult FunctionCallOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::FlatSymbolRefAttr calleeAttr;
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> argumentsOperands;
  ::llvm::SMLoc argumentsOperandsLoc;
  (void)argumentsOperandsLoc;
  ::llvm::ArrayRef<::mlir::Type> argumentsTypes;
  ::llvm::ArrayRef<::mlir::Type> allResultTypes;

  if (parser.parseCustomAttributeWithFallback(calleeAttr, parser.getBuilder().getType<::mlir::NoneType>(), "callee",
          result.attributes)) {
    return ::mlir::failure();
  }
  if (parser.parseLParen())
    return ::mlir::failure();

  argumentsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(argumentsOperands))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  ::mlir::FunctionType arguments__allResult_functionType;
  if (parser.parseType(arguments__allResult_functionType))
    return ::mlir::failure();
  argumentsTypes = arguments__allResult_functionType.getInputs();
  allResultTypes = arguments__allResult_functionType.getResults();
  result.addTypes(allResultTypes);
  if (parser.resolveOperands(argumentsOperands, argumentsTypes, argumentsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FunctionCallOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter.printAttributeWithoutType(calleeAttr());
  _odsPrinter << "(";
  _odsPrinter << arguments();
  _odsPrinter << ")";
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"callee"});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter.printFunctionalType(arguments().getTypes(), getOperation()->getResultTypes());
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::FunctionCallOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLAcosOp definitions
//===----------------------------------------------------------------------===//

GLSLAcosOpAdaptor::GLSLAcosOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLAcosOpAdaptor::GLSLAcosOpAdaptor(GLSLAcosOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLAcosOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLAcosOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLAcosOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLAcosOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr GLSLAcosOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLAcosOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLAcosOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLAcosOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLAcosOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange GLSLAcosOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLAcosOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLAcosOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLAcosOp::result() {
  return *getODSResults(0).begin();
}

void GLSLAcosOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void GLSLAcosOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLAcosOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void GLSLAcosOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void GLSLAcosOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult GLSLAcosOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps15(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps15(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GLSLAcosOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult GLSLAcosOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GLSLAcosOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void GLSLAcosOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLAcosOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLAsinOp definitions
//===----------------------------------------------------------------------===//

GLSLAsinOpAdaptor::GLSLAsinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLAsinOpAdaptor::GLSLAsinOpAdaptor(GLSLAsinOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLAsinOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLAsinOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLAsinOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLAsinOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr GLSLAsinOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLAsinOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLAsinOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLAsinOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLAsinOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange GLSLAsinOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLAsinOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLAsinOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLAsinOp::result() {
  return *getODSResults(0).begin();
}

void GLSLAsinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void GLSLAsinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLAsinOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void GLSLAsinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void GLSLAsinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult GLSLAsinOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps15(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps15(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GLSLAsinOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult GLSLAsinOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GLSLAsinOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void GLSLAsinOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLAsinOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLAtanOp definitions
//===----------------------------------------------------------------------===//

GLSLAtanOpAdaptor::GLSLAtanOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLAtanOpAdaptor::GLSLAtanOpAdaptor(GLSLAtanOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLAtanOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLAtanOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLAtanOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLAtanOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr GLSLAtanOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLAtanOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLAtanOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLAtanOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLAtanOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange GLSLAtanOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLAtanOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLAtanOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLAtanOp::result() {
  return *getODSResults(0).begin();
}

void GLSLAtanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void GLSLAtanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLAtanOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void GLSLAtanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void GLSLAtanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult GLSLAtanOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps15(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps15(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GLSLAtanOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult GLSLAtanOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GLSLAtanOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void GLSLAtanOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLAtanOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLCeilOp definitions
//===----------------------------------------------------------------------===//

GLSLCeilOpAdaptor::GLSLCeilOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLCeilOpAdaptor::GLSLCeilOpAdaptor(GLSLCeilOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLCeilOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLCeilOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLCeilOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLCeilOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr GLSLCeilOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLCeilOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLCeilOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLCeilOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLCeilOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange GLSLCeilOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLCeilOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLCeilOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLCeilOp::result() {
  return *getODSResults(0).begin();
}

void GLSLCeilOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void GLSLCeilOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLCeilOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void GLSLCeilOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void GLSLCeilOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult GLSLCeilOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GLSLCeilOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult GLSLCeilOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GLSLCeilOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void GLSLCeilOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLCeilOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLCosOp definitions
//===----------------------------------------------------------------------===//

GLSLCosOpAdaptor::GLSLCosOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLCosOpAdaptor::GLSLCosOpAdaptor(GLSLCosOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLCosOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLCosOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLCosOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLCosOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr GLSLCosOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLCosOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLCosOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLCosOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLCosOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange GLSLCosOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLCosOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLCosOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLCosOp::result() {
  return *getODSResults(0).begin();
}

void GLSLCosOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void GLSLCosOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLCosOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void GLSLCosOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void GLSLCosOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult GLSLCosOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps15(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps15(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GLSLCosOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult GLSLCosOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GLSLCosOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void GLSLCosOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLCosOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLCoshOp definitions
//===----------------------------------------------------------------------===//

GLSLCoshOpAdaptor::GLSLCoshOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLCoshOpAdaptor::GLSLCoshOpAdaptor(GLSLCoshOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLCoshOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLCoshOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLCoshOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLCoshOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr GLSLCoshOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLCoshOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLCoshOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLCoshOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLCoshOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange GLSLCoshOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLCoshOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLCoshOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLCoshOp::result() {
  return *getODSResults(0).begin();
}

void GLSLCoshOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void GLSLCoshOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLCoshOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void GLSLCoshOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void GLSLCoshOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult GLSLCoshOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps15(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps15(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GLSLCoshOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult GLSLCoshOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GLSLCoshOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void GLSLCoshOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLCoshOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLExpOp definitions
//===----------------------------------------------------------------------===//

GLSLExpOpAdaptor::GLSLExpOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLExpOpAdaptor::GLSLExpOpAdaptor(GLSLExpOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLExpOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLExpOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLExpOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLExpOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr GLSLExpOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLExpOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLExpOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLExpOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLExpOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange GLSLExpOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLExpOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLExpOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLExpOp::result() {
  return *getODSResults(0).begin();
}

void GLSLExpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void GLSLExpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLExpOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void GLSLExpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void GLSLExpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult GLSLExpOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps15(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps15(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GLSLExpOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult GLSLExpOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GLSLExpOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void GLSLExpOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLExpOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLFAbsOp definitions
//===----------------------------------------------------------------------===//

GLSLFAbsOpAdaptor::GLSLFAbsOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLFAbsOpAdaptor::GLSLFAbsOpAdaptor(GLSLFAbsOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLFAbsOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLFAbsOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLFAbsOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLFAbsOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr GLSLFAbsOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLFAbsOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLFAbsOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLFAbsOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLFAbsOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange GLSLFAbsOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLFAbsOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLFAbsOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLFAbsOp::result() {
  return *getODSResults(0).begin();
}

void GLSLFAbsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void GLSLFAbsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLFAbsOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void GLSLFAbsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void GLSLFAbsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult GLSLFAbsOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GLSLFAbsOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult GLSLFAbsOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GLSLFAbsOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void GLSLFAbsOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLFAbsOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLFClampOp definitions
//===----------------------------------------------------------------------===//

GLSLFClampOpAdaptor::GLSLFClampOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLFClampOpAdaptor::GLSLFClampOpAdaptor(GLSLFClampOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLFClampOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLFClampOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLFClampOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLFClampOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value GLSLFClampOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::Value GLSLFClampOpAdaptor::z() {
  return *getODSOperands(2).begin();
}

::mlir::DictionaryAttr GLSLFClampOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLFClampOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLFClampOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLFClampOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLFClampOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value GLSLFClampOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::Value GLSLFClampOp::z() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange GLSLFClampOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange GLSLFClampOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange GLSLFClampOp::zMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLFClampOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLFClampOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLFClampOp::result() {
  return *getODSResults(0).begin();
}

void GLSLFClampOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value x, ::mlir::Value y, ::mlir::Value z) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addOperands(z);
  odsState.addTypes(result);
}

void GLSLFClampOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y, ::mlir::Value z) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addOperands(z);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLFClampOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult GLSLFClampOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GLSLFClampOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

void GLSLFClampOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLFClampOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLFMaxOp definitions
//===----------------------------------------------------------------------===//

GLSLFMaxOpAdaptor::GLSLFMaxOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLFMaxOpAdaptor::GLSLFMaxOpAdaptor(GLSLFMaxOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLFMaxOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLFMaxOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLFMaxOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLFMaxOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value GLSLFMaxOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr GLSLFMaxOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLFMaxOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLFMaxOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLFMaxOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLFMaxOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value GLSLFMaxOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange GLSLFMaxOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange GLSLFMaxOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLFMaxOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLFMaxOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLFMaxOp::result() {
  return *getODSResults(0).begin();
}

void GLSLFMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void GLSLFMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLFMaxOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void GLSLFMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes({lhs.getType()});

}

void GLSLFMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult GLSLFMaxOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GLSLFMaxOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult GLSLFMaxOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(resultTypes), ::llvm::ArrayRef<::mlir::Type>(resultTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GLSLFMaxOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void GLSLFMaxOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLFMaxOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLFMinOp definitions
//===----------------------------------------------------------------------===//

GLSLFMinOpAdaptor::GLSLFMinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLFMinOpAdaptor::GLSLFMinOpAdaptor(GLSLFMinOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLFMinOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLFMinOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLFMinOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLFMinOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value GLSLFMinOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr GLSLFMinOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLFMinOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLFMinOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLFMinOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLFMinOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value GLSLFMinOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange GLSLFMinOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange GLSLFMinOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLFMinOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLFMinOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLFMinOp::result() {
  return *getODSResults(0).begin();
}

void GLSLFMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void GLSLFMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLFMinOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void GLSLFMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes({lhs.getType()});

}

void GLSLFMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult GLSLFMinOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GLSLFMinOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult GLSLFMinOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(resultTypes), ::llvm::ArrayRef<::mlir::Type>(resultTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GLSLFMinOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void GLSLFMinOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLFMinOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLFMixOp definitions
//===----------------------------------------------------------------------===//

GLSLFMixOpAdaptor::GLSLFMixOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLFMixOpAdaptor::GLSLFMixOpAdaptor(GLSLFMixOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLFMixOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLFMixOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLFMixOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLFMixOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value GLSLFMixOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::Value GLSLFMixOpAdaptor::a() {
  return *getODSOperands(2).begin();
}

::mlir::DictionaryAttr GLSLFMixOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLFMixOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLFMixOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLFMixOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLFMixOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value GLSLFMixOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::Value GLSLFMixOp::a() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange GLSLFMixOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange GLSLFMixOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange GLSLFMixOp::aMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLFMixOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLFMixOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLFMixOp::result() {
  return *getODSResults(0).begin();
}

void GLSLFMixOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value x, ::mlir::Value y, ::mlir::Value a) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addOperands(a);
  odsState.addTypes(result);
}

void GLSLFMixOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x, ::mlir::Value y, ::mlir::Value a) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addOperands(a);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(GLSLFMixOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      /*regions=*/{}, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void GLSLFMixOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y, ::mlir::Value a) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addOperands(a);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLFMixOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void GLSLFMixOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  ::mlir::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(GLSLFMixOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::mlir::LogicalResult GLSLFMixOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((::llvm::is_splat(::llvm::makeArrayRef({(*this->getODSOperands(0).begin()).getType(), (*this->getODSOperands(1).begin()).getType(), (*this->getODSOperands(2).begin()).getType(), (*this->getODSResults(0).begin()).getType()})))))
    return emitOpError("failed to verify that all of {x, y, a, result} have same type");
  return ::mlir::success();
}

::mlir::LogicalResult GLSLFMixOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::LogicalResult GLSLFMixOp::inferReturnTypes(::mlir::MLIRContext *context, ::llvm::Optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  inferredReturnTypes[0] = operands[2].getType();
  return ::mlir::success();
}

::mlir::ParseResult GLSLFMixOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType xRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> xOperands(xRawOperands);  ::llvm::SMLoc xOperandsLoc;
  (void)xOperandsLoc;
  ::mlir::Type xRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> xTypes(xRawTypes);
  ::mlir::OpAsmParser::OperandType yRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> yOperands(yRawOperands);  ::llvm::SMLoc yOperandsLoc;
  (void)yOperandsLoc;
  ::mlir::Type yRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> yTypes(yRawTypes);
  ::mlir::OpAsmParser::OperandType aRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> aOperands(aRawOperands);  ::llvm::SMLoc aOperandsLoc;
  (void)aOperandsLoc;
  ::mlir::Type aRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> aTypes(aRawTypes);
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();

  xOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(xRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    xRawTypes[0] = type;
  }
  if (parser.parseComma())
    return ::mlir::failure();

  yOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(yRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    yRawTypes[0] = type;
  }
  if (parser.parseComma())
    return ::mlir::failure();

  aOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(aRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    aRawTypes[0] = type;
  }
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(xOperands, xTypes, xOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(yOperands, yTypes, yOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(aOperands, aTypes, aOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GLSLFMixOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ';
  _odsPrinter << x();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = x().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << y();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = y().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << a();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = a().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ' << "->";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void GLSLFMixOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLFMixOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLFSignOp definitions
//===----------------------------------------------------------------------===//

GLSLFSignOpAdaptor::GLSLFSignOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLFSignOpAdaptor::GLSLFSignOpAdaptor(GLSLFSignOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLFSignOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLFSignOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLFSignOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLFSignOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr GLSLFSignOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLFSignOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLFSignOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLFSignOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLFSignOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange GLSLFSignOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLFSignOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLFSignOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLFSignOp::result() {
  return *getODSResults(0).begin();
}

void GLSLFSignOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void GLSLFSignOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLFSignOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void GLSLFSignOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void GLSLFSignOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult GLSLFSignOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GLSLFSignOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult GLSLFSignOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GLSLFSignOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void GLSLFSignOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLFSignOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLFloorOp definitions
//===----------------------------------------------------------------------===//

GLSLFloorOpAdaptor::GLSLFloorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLFloorOpAdaptor::GLSLFloorOpAdaptor(GLSLFloorOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLFloorOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLFloorOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLFloorOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLFloorOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr GLSLFloorOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLFloorOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLFloorOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLFloorOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLFloorOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange GLSLFloorOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLFloorOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLFloorOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLFloorOp::result() {
  return *getODSResults(0).begin();
}

void GLSLFloorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void GLSLFloorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLFloorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void GLSLFloorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void GLSLFloorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult GLSLFloorOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GLSLFloorOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult GLSLFloorOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GLSLFloorOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void GLSLFloorOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLFloorOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLFmaOp definitions
//===----------------------------------------------------------------------===//

GLSLFmaOpAdaptor::GLSLFmaOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLFmaOpAdaptor::GLSLFmaOpAdaptor(GLSLFmaOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLFmaOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLFmaOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLFmaOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLFmaOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value GLSLFmaOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::Value GLSLFmaOpAdaptor::z() {
  return *getODSOperands(2).begin();
}

::mlir::DictionaryAttr GLSLFmaOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLFmaOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLFmaOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLFmaOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLFmaOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value GLSLFmaOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::Value GLSLFmaOp::z() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange GLSLFmaOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange GLSLFmaOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange GLSLFmaOp::zMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLFmaOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLFmaOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLFmaOp::result() {
  return *getODSResults(0).begin();
}

void GLSLFmaOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value x, ::mlir::Value y, ::mlir::Value z) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addOperands(z);
  odsState.addTypes(result);
}

void GLSLFmaOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y, ::mlir::Value z) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addOperands(z);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLFmaOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult GLSLFmaOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GLSLFmaOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

void GLSLFmaOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLFmaOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLFrexpStructOp definitions
//===----------------------------------------------------------------------===//

GLSLFrexpStructOpAdaptor::GLSLFrexpStructOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLFrexpStructOpAdaptor::GLSLFrexpStructOpAdaptor(GLSLFrexpStructOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLFrexpStructOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLFrexpStructOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLFrexpStructOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLFrexpStructOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr GLSLFrexpStructOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLFrexpStructOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLFrexpStructOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLFrexpStructOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLFrexpStructOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange GLSLFrexpStructOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLFrexpStructOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLFrexpStructOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLFrexpStructOp::result() {
  return *getODSResults(0).begin();
}

void GLSLFrexpStructOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void GLSLFrexpStructOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLFrexpStructOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult GLSLFrexpStructOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps16(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GLSLFrexpStructOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult GLSLFrexpStructOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GLSLFrexpStructOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ' << "->";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void GLSLFrexpStructOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLFrexpStructOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLInverseSqrtOp definitions
//===----------------------------------------------------------------------===//

GLSLInverseSqrtOpAdaptor::GLSLInverseSqrtOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLInverseSqrtOpAdaptor::GLSLInverseSqrtOpAdaptor(GLSLInverseSqrtOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLInverseSqrtOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLInverseSqrtOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLInverseSqrtOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLInverseSqrtOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr GLSLInverseSqrtOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLInverseSqrtOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLInverseSqrtOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLInverseSqrtOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLInverseSqrtOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange GLSLInverseSqrtOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLInverseSqrtOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLInverseSqrtOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLInverseSqrtOp::result() {
  return *getODSResults(0).begin();
}

void GLSLInverseSqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void GLSLInverseSqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLInverseSqrtOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void GLSLInverseSqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void GLSLInverseSqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult GLSLInverseSqrtOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GLSLInverseSqrtOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult GLSLInverseSqrtOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GLSLInverseSqrtOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void GLSLInverseSqrtOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLInverseSqrtOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLLdexpOp definitions
//===----------------------------------------------------------------------===//

GLSLLdexpOpAdaptor::GLSLLdexpOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLLdexpOpAdaptor::GLSLLdexpOpAdaptor(GLSLLdexpOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLLdexpOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLLdexpOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLLdexpOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLLdexpOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value GLSLLdexpOpAdaptor::exp() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr GLSLLdexpOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLLdexpOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLLdexpOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLLdexpOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLLdexpOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value GLSLLdexpOp::exp() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange GLSLLdexpOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange GLSLLdexpOp::expMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLLdexpOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLLdexpOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLLdexpOp::y() {
  return *getODSResults(0).begin();
}

void GLSLLdexpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type y, ::mlir::Value x, ::mlir::Value exp) {
  odsState.addOperands(x);
  odsState.addOperands(exp);
  odsState.addTypes(y);
}

void GLSLLdexpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x, ::mlir::Value exp) {
  odsState.addOperands(x);
  odsState.addOperands(exp);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(GLSLLdexpOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      /*regions=*/{}, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void GLSLLdexpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value exp) {
  odsState.addOperands(x);
  odsState.addOperands(exp);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLLdexpOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void GLSLLdexpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  ::mlir::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(GLSLLdexpOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::mlir::LogicalResult GLSLLdexpOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((::llvm::is_splat(::llvm::makeArrayRef({(*this->getODSOperands(0).begin()).getType(), (*this->getODSResults(0).begin()).getType()})))))
    return emitOpError("failed to verify that all of {x, y} have same type");
  return ::mlir::success();
}

::mlir::LogicalResult GLSLLdexpOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::LogicalResult GLSLLdexpOp::inferReturnTypes(::mlir::MLIRContext *context, ::llvm::Optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  inferredReturnTypes[0] = operands[0].getType();
  return ::mlir::success();
}

::mlir::ParseResult GLSLLdexpOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType xRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> xOperands(xRawOperands);  ::llvm::SMLoc xOperandsLoc;
  (void)xOperandsLoc;
  ::mlir::Type xRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> xTypes(xRawTypes);
  ::mlir::OpAsmParser::OperandType expRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> expOperands(expRawOperands);  ::llvm::SMLoc expOperandsLoc;
  (void)expOperandsLoc;
  ::mlir::Type expRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> expTypes(expRawTypes);
  ::mlir::Type yRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> yTypes(yRawTypes);
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();

  xOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(xRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    xRawTypes[0] = type;
  }
  if (parser.parseComma())
    return ::mlir::failure();

  expOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(expRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    expRawTypes[0] = type;
  }
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    yRawTypes[0] = type;
  }
  result.addTypes(yTypes);
  if (parser.resolveOperands(xOperands, xTypes, xOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(expOperands, expTypes, expOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GLSLLdexpOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ';
  _odsPrinter << x();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = x().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << exp();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = exp().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ' << "->";
  _odsPrinter << ' ';
  {
    auto type = y().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void GLSLLdexpOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLLdexpOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLLogOp definitions
//===----------------------------------------------------------------------===//

GLSLLogOpAdaptor::GLSLLogOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLLogOpAdaptor::GLSLLogOpAdaptor(GLSLLogOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLLogOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLLogOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLLogOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLLogOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr GLSLLogOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLLogOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLLogOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLLogOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLLogOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange GLSLLogOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLLogOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLLogOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLLogOp::result() {
  return *getODSResults(0).begin();
}

void GLSLLogOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void GLSLLogOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLLogOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void GLSLLogOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void GLSLLogOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult GLSLLogOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps15(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps15(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GLSLLogOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult GLSLLogOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GLSLLogOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void GLSLLogOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLLogOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLPowOp definitions
//===----------------------------------------------------------------------===//

GLSLPowOpAdaptor::GLSLPowOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLPowOpAdaptor::GLSLPowOpAdaptor(GLSLPowOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLPowOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLPowOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLPowOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLPowOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value GLSLPowOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr GLSLPowOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLPowOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLPowOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLPowOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLPowOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value GLSLPowOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange GLSLPowOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange GLSLPowOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLPowOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLPowOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLPowOp::result() {
  return *getODSResults(0).begin();
}

void GLSLPowOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void GLSLPowOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLPowOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void GLSLPowOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes({lhs.getType()});

}

void GLSLPowOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult GLSLPowOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps15(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps15(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps15(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GLSLPowOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult GLSLPowOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(resultTypes), ::llvm::ArrayRef<::mlir::Type>(resultTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GLSLPowOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void GLSLPowOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLPowOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLRoundOp definitions
//===----------------------------------------------------------------------===//

GLSLRoundOpAdaptor::GLSLRoundOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLRoundOpAdaptor::GLSLRoundOpAdaptor(GLSLRoundOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLRoundOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLRoundOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLRoundOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLRoundOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr GLSLRoundOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLRoundOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLRoundOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLRoundOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLRoundOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange GLSLRoundOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLRoundOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLRoundOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLRoundOp::result() {
  return *getODSResults(0).begin();
}

void GLSLRoundOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void GLSLRoundOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLRoundOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void GLSLRoundOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void GLSLRoundOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult GLSLRoundOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GLSLRoundOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult GLSLRoundOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GLSLRoundOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void GLSLRoundOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLRoundOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLSAbsOp definitions
//===----------------------------------------------------------------------===//

GLSLSAbsOpAdaptor::GLSLSAbsOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLSAbsOpAdaptor::GLSLSAbsOpAdaptor(GLSLSAbsOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLSAbsOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLSAbsOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLSAbsOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLSAbsOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr GLSLSAbsOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLSAbsOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLSAbsOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLSAbsOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLSAbsOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange GLSLSAbsOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLSAbsOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLSAbsOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLSAbsOp::result() {
  return *getODSResults(0).begin();
}

void GLSLSAbsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void GLSLSAbsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLSAbsOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void GLSLSAbsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void GLSLSAbsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult GLSLSAbsOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GLSLSAbsOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult GLSLSAbsOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GLSLSAbsOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void GLSLSAbsOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLSAbsOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLSClampOp definitions
//===----------------------------------------------------------------------===//

GLSLSClampOpAdaptor::GLSLSClampOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLSClampOpAdaptor::GLSLSClampOpAdaptor(GLSLSClampOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLSClampOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLSClampOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLSClampOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLSClampOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value GLSLSClampOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::Value GLSLSClampOpAdaptor::z() {
  return *getODSOperands(2).begin();
}

::mlir::DictionaryAttr GLSLSClampOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLSClampOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLSClampOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLSClampOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLSClampOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value GLSLSClampOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::Value GLSLSClampOp::z() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange GLSLSClampOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange GLSLSClampOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange GLSLSClampOp::zMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLSClampOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLSClampOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLSClampOp::result() {
  return *getODSResults(0).begin();
}

void GLSLSClampOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value x, ::mlir::Value y, ::mlir::Value z) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addOperands(z);
  odsState.addTypes(result);
}

void GLSLSClampOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y, ::mlir::Value z) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addOperands(z);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLSClampOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult GLSLSClampOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps17(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps17(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps17(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps17(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GLSLSClampOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

void GLSLSClampOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLSClampOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLSMaxOp definitions
//===----------------------------------------------------------------------===//

GLSLSMaxOpAdaptor::GLSLSMaxOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLSMaxOpAdaptor::GLSLSMaxOpAdaptor(GLSLSMaxOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLSMaxOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLSMaxOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLSMaxOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLSMaxOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value GLSLSMaxOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr GLSLSMaxOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLSMaxOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLSMaxOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLSMaxOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLSMaxOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value GLSLSMaxOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange GLSLSMaxOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange GLSLSMaxOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLSMaxOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLSMaxOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLSMaxOp::result() {
  return *getODSResults(0).begin();
}

void GLSLSMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void GLSLSMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLSMaxOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void GLSLSMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes({lhs.getType()});

}

void GLSLSMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult GLSLSMaxOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GLSLSMaxOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult GLSLSMaxOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(resultTypes), ::llvm::ArrayRef<::mlir::Type>(resultTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GLSLSMaxOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void GLSLSMaxOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLSMaxOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLSMinOp definitions
//===----------------------------------------------------------------------===//

GLSLSMinOpAdaptor::GLSLSMinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLSMinOpAdaptor::GLSLSMinOpAdaptor(GLSLSMinOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLSMinOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLSMinOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLSMinOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLSMinOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value GLSLSMinOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr GLSLSMinOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLSMinOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLSMinOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLSMinOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLSMinOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value GLSLSMinOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange GLSLSMinOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange GLSLSMinOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLSMinOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLSMinOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLSMinOp::result() {
  return *getODSResults(0).begin();
}

void GLSLSMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void GLSLSMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLSMinOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void GLSLSMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes({lhs.getType()});

}

void GLSLSMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult GLSLSMinOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GLSLSMinOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult GLSLSMinOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(resultTypes), ::llvm::ArrayRef<::mlir::Type>(resultTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GLSLSMinOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void GLSLSMinOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLSMinOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLSSignOp definitions
//===----------------------------------------------------------------------===//

GLSLSSignOpAdaptor::GLSLSSignOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLSSignOpAdaptor::GLSLSSignOpAdaptor(GLSLSSignOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLSSignOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLSSignOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLSSignOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLSSignOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr GLSLSSignOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLSSignOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLSSignOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLSSignOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLSSignOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange GLSLSSignOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLSSignOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLSSignOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLSSignOp::result() {
  return *getODSResults(0).begin();
}

void GLSLSSignOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void GLSLSSignOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLSSignOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void GLSLSSignOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void GLSLSSignOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult GLSLSSignOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GLSLSSignOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult GLSLSSignOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GLSLSSignOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void GLSLSSignOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLSSignOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLSinOp definitions
//===----------------------------------------------------------------------===//

GLSLSinOpAdaptor::GLSLSinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLSinOpAdaptor::GLSLSinOpAdaptor(GLSLSinOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLSinOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLSinOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLSinOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLSinOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr GLSLSinOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLSinOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLSinOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLSinOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLSinOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange GLSLSinOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLSinOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLSinOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLSinOp::result() {
  return *getODSResults(0).begin();
}

void GLSLSinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void GLSLSinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLSinOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void GLSLSinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void GLSLSinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult GLSLSinOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps15(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps15(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GLSLSinOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult GLSLSinOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GLSLSinOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void GLSLSinOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLSinOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLSinhOp definitions
//===----------------------------------------------------------------------===//

GLSLSinhOpAdaptor::GLSLSinhOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLSinhOpAdaptor::GLSLSinhOpAdaptor(GLSLSinhOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLSinhOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLSinhOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLSinhOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLSinhOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr GLSLSinhOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLSinhOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLSinhOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLSinhOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLSinhOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange GLSLSinhOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLSinhOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLSinhOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLSinhOp::result() {
  return *getODSResults(0).begin();
}

void GLSLSinhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void GLSLSinhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLSinhOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void GLSLSinhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void GLSLSinhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult GLSLSinhOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps15(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps15(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GLSLSinhOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult GLSLSinhOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GLSLSinhOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void GLSLSinhOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLSinhOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLSqrtOp definitions
//===----------------------------------------------------------------------===//

GLSLSqrtOpAdaptor::GLSLSqrtOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLSqrtOpAdaptor::GLSLSqrtOpAdaptor(GLSLSqrtOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLSqrtOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLSqrtOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLSqrtOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLSqrtOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr GLSLSqrtOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLSqrtOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLSqrtOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLSqrtOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLSqrtOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange GLSLSqrtOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLSqrtOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLSqrtOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLSqrtOp::result() {
  return *getODSResults(0).begin();
}

void GLSLSqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void GLSLSqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLSqrtOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void GLSLSqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void GLSLSqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult GLSLSqrtOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GLSLSqrtOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult GLSLSqrtOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GLSLSqrtOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void GLSLSqrtOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLSqrtOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLTanOp definitions
//===----------------------------------------------------------------------===//

GLSLTanOpAdaptor::GLSLTanOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLTanOpAdaptor::GLSLTanOpAdaptor(GLSLTanOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLTanOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLTanOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLTanOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLTanOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr GLSLTanOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLTanOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLTanOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLTanOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLTanOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange GLSLTanOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLTanOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLTanOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLTanOp::result() {
  return *getODSResults(0).begin();
}

void GLSLTanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void GLSLTanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLTanOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void GLSLTanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void GLSLTanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult GLSLTanOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps15(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps15(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GLSLTanOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult GLSLTanOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GLSLTanOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void GLSLTanOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLTanOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLTanhOp definitions
//===----------------------------------------------------------------------===//

GLSLTanhOpAdaptor::GLSLTanhOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLTanhOpAdaptor::GLSLTanhOpAdaptor(GLSLTanhOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLTanhOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLTanhOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLTanhOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLTanhOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr GLSLTanhOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLTanhOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLTanhOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLTanhOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLTanhOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange GLSLTanhOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLTanhOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLTanhOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLTanhOp::result() {
  return *getODSResults(0).begin();
}

void GLSLTanhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void GLSLTanhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLTanhOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void GLSLTanhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void GLSLTanhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult GLSLTanhOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps15(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps15(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GLSLTanhOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult GLSLTanhOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GLSLTanhOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void GLSLTanhOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLTanhOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLUClampOp definitions
//===----------------------------------------------------------------------===//

GLSLUClampOpAdaptor::GLSLUClampOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLUClampOpAdaptor::GLSLUClampOpAdaptor(GLSLUClampOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLUClampOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLUClampOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLUClampOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLUClampOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value GLSLUClampOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::Value GLSLUClampOpAdaptor::z() {
  return *getODSOperands(2).begin();
}

::mlir::DictionaryAttr GLSLUClampOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLUClampOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLUClampOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLUClampOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLUClampOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value GLSLUClampOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::Value GLSLUClampOp::z() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange GLSLUClampOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange GLSLUClampOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange GLSLUClampOp::zMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLUClampOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLUClampOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLUClampOp::result() {
  return *getODSResults(0).begin();
}

void GLSLUClampOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value x, ::mlir::Value y, ::mlir::Value z) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addOperands(z);
  odsState.addTypes(result);
}

void GLSLUClampOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y, ::mlir::Value z) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addOperands(z);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLUClampOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult GLSLUClampOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps18(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps18(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps18(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps18(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GLSLUClampOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

void GLSLUClampOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLUClampOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLUMaxOp definitions
//===----------------------------------------------------------------------===//

GLSLUMaxOpAdaptor::GLSLUMaxOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLUMaxOpAdaptor::GLSLUMaxOpAdaptor(GLSLUMaxOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLUMaxOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLUMaxOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLUMaxOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLUMaxOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value GLSLUMaxOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr GLSLUMaxOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLUMaxOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLUMaxOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLUMaxOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLUMaxOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value GLSLUMaxOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange GLSLUMaxOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange GLSLUMaxOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLUMaxOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLUMaxOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLUMaxOp::result() {
  return *getODSResults(0).begin();
}

void GLSLUMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void GLSLUMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLUMaxOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void GLSLUMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes({lhs.getType()});

}

void GLSLUMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult GLSLUMaxOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GLSLUMaxOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult GLSLUMaxOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(resultTypes), ::llvm::ArrayRef<::mlir::Type>(resultTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GLSLUMaxOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void GLSLUMaxOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLUMaxOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GLSLUMinOp definitions
//===----------------------------------------------------------------------===//

GLSLUMinOpAdaptor::GLSLUMinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GLSLUMinOpAdaptor::GLSLUMinOpAdaptor(GLSLUMinOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GLSLUMinOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GLSLUMinOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GLSLUMinOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLUMinOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value GLSLUMinOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr GLSLUMinOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GLSLUMinOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GLSLUMinOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GLSLUMinOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLUMinOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value GLSLUMinOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange GLSLUMinOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange GLSLUMinOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GLSLUMinOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GLSLUMinOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GLSLUMinOp::result() {
  return *getODSResults(0).begin();
}

void GLSLUMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void GLSLUMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GLSLUMinOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void GLSLUMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes({lhs.getType()});

}

void GLSLUMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult GLSLUMinOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GLSLUMinOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult GLSLUMinOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(resultTypes), ::llvm::ArrayRef<::mlir::Type>(resultTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GLSLUMinOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void GLSLUMinOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GLSLUMinOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GlobalVariableOp definitions
//===----------------------------------------------------------------------===//

GlobalVariableOpAdaptor::GlobalVariableOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GlobalVariableOpAdaptor::GlobalVariableOpAdaptor(GlobalVariableOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GlobalVariableOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GlobalVariableOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GlobalVariableOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr GlobalVariableOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::TypeAttr GlobalVariableOpAdaptor::typeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::TypeAttr attr = odsAttrs.get("type").cast<::mlir::TypeAttr>();
  return attr;
}

::mlir::Type GlobalVariableOpAdaptor::type() {
  auto attr = typeAttr();
  return attr.getValue().cast<::mlir::Type>();
}

::mlir::StringAttr GlobalVariableOpAdaptor::sym_nameAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("sym_name").cast<::mlir::StringAttr>();
  return attr;
}

::llvm::StringRef GlobalVariableOpAdaptor::sym_name() {
  auto attr = sym_nameAttr();
  return attr.getValue();
}

::mlir::FlatSymbolRefAttr GlobalVariableOpAdaptor::initializerAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FlatSymbolRefAttr attr = odsAttrs.get("initializer").dyn_cast_or_null<::mlir::FlatSymbolRefAttr>();
  return attr;
}

::llvm::Optional< ::llvm::StringRef > GlobalVariableOpAdaptor::initializer() {
  auto attr = initializerAttr();
  return attr ? ::llvm::Optional< ::llvm::StringRef >(attr.getValue()) : (::llvm::None);
}

::mlir::IntegerAttr GlobalVariableOpAdaptor::locationAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("location").dyn_cast_or_null<::mlir::IntegerAttr>();
  return attr;
}

::llvm::Optional<uint32_t> GlobalVariableOpAdaptor::location() {
  auto attr = locationAttr();
  return attr ? ::llvm::Optional<uint32_t>(attr.getValue().getZExtValue()) : (::llvm::None);
}

::mlir::IntegerAttr GlobalVariableOpAdaptor::bindingAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("binding").dyn_cast_or_null<::mlir::IntegerAttr>();
  return attr;
}

::llvm::Optional<uint32_t> GlobalVariableOpAdaptor::binding() {
  auto attr = bindingAttr();
  return attr ? ::llvm::Optional<uint32_t>(attr.getValue().getZExtValue()) : (::llvm::None);
}

::mlir::IntegerAttr GlobalVariableOpAdaptor::descriptor_setAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("descriptor_set").dyn_cast_or_null<::mlir::IntegerAttr>();
  return attr;
}

::llvm::Optional<uint32_t> GlobalVariableOpAdaptor::descriptor_set() {
  auto attr = descriptor_setAttr();
  return attr ? ::llvm::Optional<uint32_t>(attr.getValue().getZExtValue()) : (::llvm::None);
}

::mlir::StringAttr GlobalVariableOpAdaptor::builtinAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("builtin").dyn_cast_or_null<::mlir::StringAttr>();
  return attr;
}

::llvm::Optional< ::llvm::StringRef > GlobalVariableOpAdaptor::builtin() {
  auto attr = builtinAttr();
  return attr ? ::llvm::Optional< ::llvm::StringRef >(attr.getValue()) : (::llvm::None);
}

::mlir::LogicalResult GlobalVariableOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_type = odsAttrs.get("type");
    if (!tblgen_type)
      return emitError(loc, "'spv.GlobalVariable' op ""requires attribute 'type'");

    if (tblgen_type && !(((tblgen_type.isa<::mlir::TypeAttr>())) && ((tblgen_type.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>()))))
      return emitError(loc, "'spv.GlobalVariable' op ""attribute 'type' failed to satisfy constraint: any type attribute");
  }
  {
    auto tblgen_sym_name = odsAttrs.get("sym_name");
    if (!tblgen_sym_name)
      return emitError(loc, "'spv.GlobalVariable' op ""requires attribute 'sym_name'");

    if (tblgen_sym_name && !((tblgen_sym_name.isa<::mlir::StringAttr>())))
      return emitError(loc, "'spv.GlobalVariable' op ""attribute 'sym_name' failed to satisfy constraint: string attribute");
  }
  {
    auto tblgen_initializer = odsAttrs.get("initializer");
    if (tblgen_initializer && !((tblgen_initializer.isa<::mlir::FlatSymbolRefAttr>())))
      return emitError(loc, "'spv.GlobalVariable' op ""attribute 'initializer' failed to satisfy constraint: flat symbol reference attribute");
  }
  {
    auto tblgen_location = odsAttrs.get("location");
    if (tblgen_location && !(((tblgen_location.isa<::mlir::IntegerAttr>())) && ((tblgen_location.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))))
      return emitError(loc, "'spv.GlobalVariable' op ""attribute 'location' failed to satisfy constraint: 32-bit signless integer attribute");
  }
  {
    auto tblgen_binding = odsAttrs.get("binding");
    if (tblgen_binding && !(((tblgen_binding.isa<::mlir::IntegerAttr>())) && ((tblgen_binding.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))))
      return emitError(loc, "'spv.GlobalVariable' op ""attribute 'binding' failed to satisfy constraint: 32-bit signless integer attribute");
  }
  {
    auto tblgen_descriptor_set = odsAttrs.get("descriptor_set");
    if (tblgen_descriptor_set && !(((tblgen_descriptor_set.isa<::mlir::IntegerAttr>())) && ((tblgen_descriptor_set.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))))
      return emitError(loc, "'spv.GlobalVariable' op ""attribute 'descriptor_set' failed to satisfy constraint: 32-bit signless integer attribute");
  }
  {
    auto tblgen_builtin = odsAttrs.get("builtin");
    if (tblgen_builtin && !((tblgen_builtin.isa<::mlir::StringAttr>())))
      return emitError(loc, "'spv.GlobalVariable' op ""attribute 'builtin' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GlobalVariableOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GlobalVariableOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> GlobalVariableOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GlobalVariableOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::TypeAttr GlobalVariableOp::typeAttr() {
  return (*this)->getAttr(typeAttrName()).cast<::mlir::TypeAttr>();
}

::mlir::Type GlobalVariableOp::type() {
  auto attr = typeAttr();
  return attr.getValue().cast<::mlir::Type>();
}

::mlir::StringAttr GlobalVariableOp::sym_nameAttr() {
  return (*this)->getAttr(sym_nameAttrName()).cast<::mlir::StringAttr>();
}

::llvm::StringRef GlobalVariableOp::sym_name() {
  auto attr = sym_nameAttr();
  return attr.getValue();
}

::mlir::FlatSymbolRefAttr GlobalVariableOp::initializerAttr() {
  return (*this)->getAttr(initializerAttrName()).dyn_cast_or_null<::mlir::FlatSymbolRefAttr>();
}

::llvm::Optional< ::llvm::StringRef > GlobalVariableOp::initializer() {
  auto attr = initializerAttr();
  return attr ? ::llvm::Optional< ::llvm::StringRef >(attr.getValue()) : (::llvm::None);
}

::mlir::IntegerAttr GlobalVariableOp::locationAttr() {
  return (*this)->getAttr(locationAttrName()).dyn_cast_or_null<::mlir::IntegerAttr>();
}

::llvm::Optional<uint32_t> GlobalVariableOp::location() {
  auto attr = locationAttr();
  return attr ? ::llvm::Optional<uint32_t>(attr.getValue().getZExtValue()) : (::llvm::None);
}

::mlir::IntegerAttr GlobalVariableOp::bindingAttr() {
  return (*this)->getAttr(bindingAttrName()).dyn_cast_or_null<::mlir::IntegerAttr>();
}

::llvm::Optional<uint32_t> GlobalVariableOp::binding() {
  auto attr = bindingAttr();
  return attr ? ::llvm::Optional<uint32_t>(attr.getValue().getZExtValue()) : (::llvm::None);
}

::mlir::IntegerAttr GlobalVariableOp::descriptor_setAttr() {
  return (*this)->getAttr(descriptor_setAttrName()).dyn_cast_or_null<::mlir::IntegerAttr>();
}

::llvm::Optional<uint32_t> GlobalVariableOp::descriptor_set() {
  auto attr = descriptor_setAttr();
  return attr ? ::llvm::Optional<uint32_t>(attr.getValue().getZExtValue()) : (::llvm::None);
}

::mlir::StringAttr GlobalVariableOp::builtinAttr() {
  return (*this)->getAttr(builtinAttrName()).dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::Optional< ::llvm::StringRef > GlobalVariableOp::builtin() {
  auto attr = builtinAttr();
  return attr ? ::llvm::Optional< ::llvm::StringRef >(attr.getValue()) : (::llvm::None);
}

void GlobalVariableOp::typeAttr(::mlir::TypeAttr attr) {
  (*this)->setAttr(typeAttrName(), attr);
}

void GlobalVariableOp::sym_nameAttr(::mlir::StringAttr attr) {
  (*this)->setAttr(sym_nameAttrName(), attr);
}

void GlobalVariableOp::initializerAttr(::mlir::FlatSymbolRefAttr attr) {
  (*this)->setAttr(initializerAttrName(), attr);
}

void GlobalVariableOp::locationAttr(::mlir::IntegerAttr attr) {
  (*this)->setAttr(locationAttrName(), attr);
}

void GlobalVariableOp::bindingAttr(::mlir::IntegerAttr attr) {
  (*this)->setAttr(bindingAttrName(), attr);
}

void GlobalVariableOp::descriptor_setAttr(::mlir::IntegerAttr attr) {
  (*this)->setAttr(descriptor_setAttrName(), attr);
}

void GlobalVariableOp::builtinAttr(::mlir::StringAttr attr) {
  (*this)->setAttr(builtinAttrName(), attr);
}

::mlir::Attribute GlobalVariableOp::removeInitializerAttr() {
  return (*this)->removeAttr(initializerAttrName());
}

::mlir::Attribute GlobalVariableOp::removeLocationAttr() {
  return (*this)->removeAttr(locationAttrName());
}

::mlir::Attribute GlobalVariableOp::removeBindingAttr() {
  return (*this)->removeAttr(bindingAttrName());
}

::mlir::Attribute GlobalVariableOp::removeDescriptor_setAttr() {
  return (*this)->removeAttr(descriptor_setAttrName());
}

::mlir::Attribute GlobalVariableOp::removeBuiltinAttr() {
  return (*this)->removeAttr(builtinAttrName());
}

void GlobalVariableOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeAttr type, StringAttr sym_name, FlatSymbolRefAttr initializer) {
      odsState.addAttribute("type", type);
      odsState.addAttribute(sym_nameAttrName(odsState.name), sym_name);
      if (initializer)
        odsState.addAttribute(initializerAttrName(odsState.name), initializer);
    
}

void GlobalVariableOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeAttr type, ArrayRef<NamedAttribute> namedAttrs) {
      odsState.addAttribute("type", type);
      odsState.addAttributes(namedAttrs);
    
}

void GlobalVariableOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type type, StringRef sym_name, FlatSymbolRefAttr initializer) {
      odsState.addAttribute("type", TypeAttr::get(type));
      odsState.addAttribute(sym_nameAttrName(odsState.name), odsBuilder.getStringAttr(sym_name));
      if (initializer)
        odsState.addAttribute(initializerAttrName(odsState.name), initializer);
    
}

void GlobalVariableOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeAttr type, ::mlir::StringAttr sym_name, /*optional*/::mlir::FlatSymbolRefAttr initializer, /*optional*/::mlir::IntegerAttr location, /*optional*/::mlir::IntegerAttr binding, /*optional*/::mlir::IntegerAttr descriptor_set, /*optional*/::mlir::StringAttr builtin) {
  odsState.addAttribute(typeAttrName(odsState.name), type);
  odsState.addAttribute(sym_nameAttrName(odsState.name), sym_name);
  if (initializer) {
  odsState.addAttribute(initializerAttrName(odsState.name), initializer);
  }
  if (location) {
  odsState.addAttribute(locationAttrName(odsState.name), location);
  }
  if (binding) {
  odsState.addAttribute(bindingAttrName(odsState.name), binding);
  }
  if (descriptor_set) {
  odsState.addAttribute(descriptor_setAttrName(odsState.name), descriptor_set);
  }
  if (builtin) {
  odsState.addAttribute(builtinAttrName(odsState.name), builtin);
  }
}

void GlobalVariableOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::TypeAttr type, ::mlir::StringAttr sym_name, /*optional*/::mlir::FlatSymbolRefAttr initializer, /*optional*/::mlir::IntegerAttr location, /*optional*/::mlir::IntegerAttr binding, /*optional*/::mlir::IntegerAttr descriptor_set, /*optional*/::mlir::StringAttr builtin) {
  odsState.addAttribute(typeAttrName(odsState.name), type);
  odsState.addAttribute(sym_nameAttrName(odsState.name), sym_name);
  if (initializer) {
  odsState.addAttribute(initializerAttrName(odsState.name), initializer);
  }
  if (location) {
  odsState.addAttribute(locationAttrName(odsState.name), location);
  }
  if (binding) {
  odsState.addAttribute(bindingAttrName(odsState.name), binding);
  }
  if (descriptor_set) {
  odsState.addAttribute(descriptor_setAttrName(odsState.name), descriptor_set);
  }
  if (builtin) {
  odsState.addAttribute(builtinAttrName(odsState.name), builtin);
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GlobalVariableOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type type, ::llvm::StringRef sym_name, /*optional*/::mlir::FlatSymbolRefAttr initializer, /*optional*/::mlir::IntegerAttr location, /*optional*/::mlir::IntegerAttr binding, /*optional*/::mlir::IntegerAttr descriptor_set, /*optional*/::mlir::StringAttr builtin) {
  odsState.addAttribute(typeAttrName(odsState.name), ::mlir::TypeAttr::get(type));
  odsState.addAttribute(sym_nameAttrName(odsState.name), odsBuilder.getStringAttr(sym_name));
  if (initializer) {
  odsState.addAttribute(initializerAttrName(odsState.name), initializer);
  }
  if (location) {
  odsState.addAttribute(locationAttrName(odsState.name), location);
  }
  if (binding) {
  odsState.addAttribute(bindingAttrName(odsState.name), binding);
  }
  if (descriptor_set) {
  odsState.addAttribute(descriptor_setAttrName(odsState.name), descriptor_set);
  }
  if (builtin) {
  odsState.addAttribute(builtinAttrName(odsState.name), builtin);
  }
}

void GlobalVariableOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Type type, ::llvm::StringRef sym_name, /*optional*/::mlir::FlatSymbolRefAttr initializer, /*optional*/::mlir::IntegerAttr location, /*optional*/::mlir::IntegerAttr binding, /*optional*/::mlir::IntegerAttr descriptor_set, /*optional*/::mlir::StringAttr builtin) {
  odsState.addAttribute(typeAttrName(odsState.name), ::mlir::TypeAttr::get(type));
  odsState.addAttribute(sym_nameAttrName(odsState.name), odsBuilder.getStringAttr(sym_name));
  if (initializer) {
  odsState.addAttribute(initializerAttrName(odsState.name), initializer);
  }
  if (location) {
  odsState.addAttribute(locationAttrName(odsState.name), location);
  }
  if (binding) {
  odsState.addAttribute(bindingAttrName(odsState.name), binding);
  }
  if (descriptor_set) {
  odsState.addAttribute(descriptor_setAttrName(odsState.name), descriptor_set);
  }
  if (builtin) {
  odsState.addAttribute(builtinAttrName(odsState.name), builtin);
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GlobalVariableOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult GlobalVariableOp::verifyInvariantsImpl() {
  {
    auto tblgen_type = (*this)->getAttr(typeAttrName());
    if (!tblgen_type)
      return emitOpError("requires attribute 'type'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps5(*this, tblgen_type, "type")))
      return ::mlir::failure();
  }
  {
    auto tblgen_sym_name = (*this)->getAttr(sym_nameAttrName());
    if (!tblgen_sym_name)
      return emitOpError("requires attribute 'sym_name'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps11(*this, tblgen_sym_name, "sym_name")))
      return ::mlir::failure();
  }
  {
    auto tblgen_initializer = (*this)->getAttr(initializerAttrName());
    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps0(*this, tblgen_initializer, "initializer")))
      return ::mlir::failure();
  }
  {
    auto tblgen_location = (*this)->getAttr(locationAttrName());
    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps7(*this, tblgen_location, "location")))
      return ::mlir::failure();
  }
  {
    auto tblgen_binding = (*this)->getAttr(bindingAttrName());
    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps7(*this, tblgen_binding, "binding")))
      return ::mlir::failure();
  }
  {
    auto tblgen_descriptor_set = (*this)->getAttr(descriptor_setAttrName());
    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps7(*this, tblgen_descriptor_set, "descriptor_set")))
      return ::mlir::failure();
  }
  {
    auto tblgen_builtin = (*this)->getAttr(builtinAttrName());
    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps11(*this, tblgen_builtin, "builtin")))
      return ::mlir::failure();
  }
  if (!((isDirectInModuleLikeOp((*this->getOperation()).getParentOp()))))
    return emitOpError("failed to verify that op must appear in a module-like op's block");
  return ::mlir::success();
}

::mlir::LogicalResult GlobalVariableOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GlobalVariableOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GroupBroadcastOp definitions
//===----------------------------------------------------------------------===//

GroupBroadcastOpAdaptor::GroupBroadcastOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GroupBroadcastOpAdaptor::GroupBroadcastOpAdaptor(GroupBroadcastOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GroupBroadcastOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GroupBroadcastOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GroupBroadcastOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupBroadcastOpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value GroupBroadcastOpAdaptor::localid() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr GroupBroadcastOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ScopeAttr GroupBroadcastOpAdaptor::execution_scopeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ScopeAttr attr = odsAttrs.get("execution_scope").cast<::mlir::spirv::ScopeAttr>();
  return attr;
}

::mlir::spirv::Scope GroupBroadcastOpAdaptor::execution_scope() {
  auto attr = execution_scopeAttr();
  return attr.getValue();
}

::mlir::LogicalResult GroupBroadcastOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_execution_scope = odsAttrs.get("execution_scope");
    if (!tblgen_execution_scope)
      return emitError(loc, "'spv.GroupBroadcast' op ""requires attribute 'execution_scope'");

    if (tblgen_execution_scope && !((((tblgen_execution_scope.isa<::mlir::IntegerAttr>())) && ((tblgen_execution_scope.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(tblgen_execution_scope.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.GroupBroadcast' op ""attribute 'execution_scope' failed to satisfy constraint: valid SPIR-V Scope");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GroupBroadcastOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GroupBroadcastOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupBroadcastOp::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value GroupBroadcastOp::localid() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange GroupBroadcastOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange GroupBroadcastOp::localidMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GroupBroadcastOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GroupBroadcastOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupBroadcastOp::result() {
  return *getODSResults(0).begin();
}

::mlir::spirv::ScopeAttr GroupBroadcastOp::execution_scopeAttr() {
  return (*this)->getAttr(execution_scopeAttrName()).cast<::mlir::spirv::ScopeAttr>();
}

::mlir::spirv::Scope GroupBroadcastOp::execution_scope() {
  auto attr = execution_scopeAttr();
  return attr.getValue();
}

void GroupBroadcastOp::execution_scopeAttr(::mlir::spirv::ScopeAttr attr) {
  (*this)->setAttr(execution_scopeAttrName(), attr);
}

void GroupBroadcastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::spirv::ScopeAttr execution_scope, ::mlir::Value value, ::mlir::Value localid) {
  odsState.addOperands(value);
  odsState.addOperands(localid);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);
  odsState.addTypes(result);
}

void GroupBroadcastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::spirv::ScopeAttr execution_scope, ::mlir::Value value, ::mlir::Value localid) {
  odsState.addOperands(value);
  odsState.addOperands(localid);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(GroupBroadcastOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      /*regions=*/{}, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void GroupBroadcastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::ScopeAttr execution_scope, ::mlir::Value value, ::mlir::Value localid) {
  odsState.addOperands(value);
  odsState.addOperands(localid);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GroupBroadcastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::spirv::Scope execution_scope, ::mlir::Value value, ::mlir::Value localid) {
  odsState.addOperands(value);
  odsState.addOperands(localid);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));
  odsState.addTypes(result);
}

void GroupBroadcastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::spirv::Scope execution_scope, ::mlir::Value value, ::mlir::Value localid) {
  odsState.addOperands(value);
  odsState.addOperands(localid);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(GroupBroadcastOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      /*regions=*/{}, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void GroupBroadcastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::Scope execution_scope, ::mlir::Value value, ::mlir::Value localid) {
  odsState.addOperands(value);
  odsState.addOperands(localid);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GroupBroadcastOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void GroupBroadcastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  ::mlir::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(GroupBroadcastOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::mlir::LogicalResult GroupBroadcastOp::verifyInvariantsImpl() {
  {
    auto tblgen_execution_scope = (*this)->getAttr(execution_scopeAttrName());
    if (!tblgen_execution_scope)
      return emitOpError("requires attribute 'execution_scope'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps1(*this, tblgen_execution_scope, "execution_scope")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps7(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps7(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((::llvm::is_splat(::llvm::makeArrayRef({(*this->getODSOperands(0).begin()).getType(), (*this->getODSResults(0).begin()).getType()})))))
    return emitOpError("failed to verify that all of {value, result} have same type");
  return ::mlir::success();
}

::mlir::LogicalResult GroupBroadcastOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::LogicalResult GroupBroadcastOp::inferReturnTypes(::mlir::MLIRContext *context, ::llvm::Optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  inferredReturnTypes[0] = operands[0].getType();
  return ::mlir::success();
}

::mlir::ParseResult GroupBroadcastOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::spirv::ScopeAttr execution_scopeAttr;
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type valueRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> valueTypes(valueRawTypes);
  ::mlir::Type localidRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> localidTypes(localidRawTypes);

  {
    ::llvm::StringRef attrStr;
    ::mlir::NamedAttrList attrStorage;
    auto loc = parser.getCurrentLocation();
    if (parser.parseOptionalKeyword(&attrStr, {"CrossDevice","Device","Workgroup","Subgroup","Invocation","QueueFamily","ShaderCallKHR"})) {
      ::mlir::StringAttr attrVal;
      ::mlir::OptionalParseResult parseResult =
        parser.parseOptionalAttribute(attrVal,
                                      parser.getBuilder().getNoneType(),
                                      "execution_scope", attrStorage);
      if (parseResult.hasValue()) {
        if (failed(*parseResult))
          return ::mlir::failure();
        attrStr = attrVal.getValue();
      } else {
        return parser.emitError(loc, "expected string or keyword containing one of the following enum values for attribute 'execution_scope' [CrossDevice, Device, Workgroup, Subgroup, Invocation, QueueFamily, ShaderCallKHR]");
      }
    }
    if (!attrStr.empty()) {
      auto attrOptional = ::mlir::spirv::symbolizeScope(attrStr);
      if (!attrOptional)
        return parser.emitError(loc, "invalid ")
               << "execution_scope attribute specification: \"" << attrStr << '"';;

      execution_scopeAttr = ::mlir::spirv::ScopeAttr::get(parser.getBuilder().getContext(), attrOptional.getValue());
      result.addAttribute("execution_scope", execution_scopeAttr);
    }
  }
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    valueRawTypes[0] = type;
  }
  if (parser.parseComma())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    localidRawTypes[0] = type;
  }
  result.addTypes(valueTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(valueTypes), ::llvm::ArrayRef<::mlir::Type>(localidTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GroupBroadcastOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';

  {
    auto caseValue = execution_scope();
    auto caseValueStr = stringifyScope(caseValue);
    _odsPrinter << caseValueStr;
  }
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"execution_scope"});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = value().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';
  {
    auto type = localid().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void GroupBroadcastOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GroupBroadcastOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GroupNonUniformBallotOp definitions
//===----------------------------------------------------------------------===//

GroupNonUniformBallotOpAdaptor::GroupNonUniformBallotOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GroupNonUniformBallotOpAdaptor::GroupNonUniformBallotOpAdaptor(GroupNonUniformBallotOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GroupNonUniformBallotOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GroupNonUniformBallotOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GroupNonUniformBallotOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformBallotOpAdaptor::predicate() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr GroupNonUniformBallotOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ScopeAttr GroupNonUniformBallotOpAdaptor::execution_scopeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ScopeAttr attr = odsAttrs.get("execution_scope").cast<::mlir::spirv::ScopeAttr>();
  return attr;
}

::mlir::spirv::Scope GroupNonUniformBallotOpAdaptor::execution_scope() {
  auto attr = execution_scopeAttr();
  return attr.getValue();
}

::mlir::LogicalResult GroupNonUniformBallotOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_execution_scope = odsAttrs.get("execution_scope");
    if (!tblgen_execution_scope)
      return emitError(loc, "'spv.GroupNonUniformBallot' op ""requires attribute 'execution_scope'");

    if (tblgen_execution_scope && !((((tblgen_execution_scope.isa<::mlir::IntegerAttr>())) && ((tblgen_execution_scope.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(tblgen_execution_scope.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.GroupNonUniformBallot' op ""attribute 'execution_scope' failed to satisfy constraint: valid SPIR-V Scope");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GroupNonUniformBallotOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GroupNonUniformBallotOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformBallotOp::predicate() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange GroupNonUniformBallotOp::predicateMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GroupNonUniformBallotOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GroupNonUniformBallotOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformBallotOp::result() {
  return *getODSResults(0).begin();
}

::mlir::spirv::ScopeAttr GroupNonUniformBallotOp::execution_scopeAttr() {
  return (*this)->getAttr(execution_scopeAttrName()).cast<::mlir::spirv::ScopeAttr>();
}

::mlir::spirv::Scope GroupNonUniformBallotOp::execution_scope() {
  auto attr = execution_scopeAttr();
  return attr.getValue();
}

void GroupNonUniformBallotOp::execution_scopeAttr(::mlir::spirv::ScopeAttr attr) {
  (*this)->setAttr(execution_scopeAttrName(), attr);
}

void GroupNonUniformBallotOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::spirv::ScopeAttr execution_scope, ::mlir::Value predicate) {
  odsState.addOperands(predicate);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);
  odsState.addTypes(result);
}

void GroupNonUniformBallotOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::ScopeAttr execution_scope, ::mlir::Value predicate) {
  odsState.addOperands(predicate);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GroupNonUniformBallotOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::spirv::Scope execution_scope, ::mlir::Value predicate) {
  odsState.addOperands(predicate);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));
  odsState.addTypes(result);
}

void GroupNonUniformBallotOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::Scope execution_scope, ::mlir::Value predicate) {
  odsState.addOperands(predicate);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GroupNonUniformBallotOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult GroupNonUniformBallotOp::verifyInvariantsImpl() {
  {
    auto tblgen_execution_scope = (*this)->getAttr(execution_scopeAttrName());
    if (!tblgen_execution_scope)
      return emitOpError("requires attribute 'execution_scope'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps1(*this, tblgen_execution_scope, "execution_scope")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps6(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps19(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GroupNonUniformBallotOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult GroupNonUniformBallotOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::spirv::ScopeAttr execution_scopeAttr;
  ::mlir::OpAsmParser::OperandType predicateRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> predicateOperands(predicateRawOperands);  ::llvm::SMLoc predicateOperandsLoc;
  (void)predicateOperandsLoc;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  {
    ::llvm::StringRef attrStr;
    ::mlir::NamedAttrList attrStorage;
    auto loc = parser.getCurrentLocation();
    if (parser.parseOptionalKeyword(&attrStr, {"CrossDevice","Device","Workgroup","Subgroup","Invocation","QueueFamily","ShaderCallKHR"})) {
      ::mlir::StringAttr attrVal;
      ::mlir::OptionalParseResult parseResult =
        parser.parseOptionalAttribute(attrVal,
                                      parser.getBuilder().getNoneType(),
                                      "execution_scope", attrStorage);
      if (parseResult.hasValue()) {
        if (failed(*parseResult))
          return ::mlir::failure();
        attrStr = attrVal.getValue();
      } else {
        return parser.emitError(loc, "expected string or keyword containing one of the following enum values for attribute 'execution_scope' [CrossDevice, Device, Workgroup, Subgroup, Invocation, QueueFamily, ShaderCallKHR]");
      }
    }
    if (!attrStr.empty()) {
      auto attrOptional = ::mlir::spirv::symbolizeScope(attrStr);
      if (!attrOptional)
        return parser.emitError(loc, "invalid ")
               << "execution_scope attribute specification: \"" << attrStr << '"';;

      execution_scopeAttr = ::mlir::spirv::ScopeAttr::get(parser.getBuilder().getContext(), attrOptional.getValue());
      result.addAttribute("execution_scope", execution_scopeAttr);
    }
  }

  predicateOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(predicateRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::VectorType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getIntegerType(1);
  result.addTypes(resultTypes);
  if (parser.resolveOperands(predicateOperands, odsBuildableType0, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GroupNonUniformBallotOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';

  {
    auto caseValue = execution_scope();
    auto caseValueStr = stringifyScope(caseValue);
    _odsPrinter << caseValueStr;
  }
  _odsPrinter << ' ';
  _odsPrinter << predicate();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"execution_scope"});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::VectorType>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GroupNonUniformBallotOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GroupNonUniformBroadcastOp definitions
//===----------------------------------------------------------------------===//

GroupNonUniformBroadcastOpAdaptor::GroupNonUniformBroadcastOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GroupNonUniformBroadcastOpAdaptor::GroupNonUniformBroadcastOpAdaptor(GroupNonUniformBroadcastOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GroupNonUniformBroadcastOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GroupNonUniformBroadcastOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GroupNonUniformBroadcastOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformBroadcastOpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value GroupNonUniformBroadcastOpAdaptor::id() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr GroupNonUniformBroadcastOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ScopeAttr GroupNonUniformBroadcastOpAdaptor::execution_scopeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ScopeAttr attr = odsAttrs.get("execution_scope").cast<::mlir::spirv::ScopeAttr>();
  return attr;
}

::mlir::spirv::Scope GroupNonUniformBroadcastOpAdaptor::execution_scope() {
  auto attr = execution_scopeAttr();
  return attr.getValue();
}

::mlir::LogicalResult GroupNonUniformBroadcastOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_execution_scope = odsAttrs.get("execution_scope");
    if (!tblgen_execution_scope)
      return emitError(loc, "'spv.GroupNonUniformBroadcast' op ""requires attribute 'execution_scope'");

    if (tblgen_execution_scope && !((((tblgen_execution_scope.isa<::mlir::IntegerAttr>())) && ((tblgen_execution_scope.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(tblgen_execution_scope.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.GroupNonUniformBroadcast' op ""attribute 'execution_scope' failed to satisfy constraint: valid SPIR-V Scope");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GroupNonUniformBroadcastOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GroupNonUniformBroadcastOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformBroadcastOp::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value GroupNonUniformBroadcastOp::id() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange GroupNonUniformBroadcastOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange GroupNonUniformBroadcastOp::idMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GroupNonUniformBroadcastOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GroupNonUniformBroadcastOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformBroadcastOp::result() {
  return *getODSResults(0).begin();
}

::mlir::spirv::ScopeAttr GroupNonUniformBroadcastOp::execution_scopeAttr() {
  return (*this)->getAttr(execution_scopeAttrName()).cast<::mlir::spirv::ScopeAttr>();
}

::mlir::spirv::Scope GroupNonUniformBroadcastOp::execution_scope() {
  auto attr = execution_scopeAttr();
  return attr.getValue();
}

void GroupNonUniformBroadcastOp::execution_scopeAttr(::mlir::spirv::ScopeAttr attr) {
  (*this)->setAttr(execution_scopeAttrName(), attr);
}

void GroupNonUniformBroadcastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::spirv::ScopeAttr execution_scope, ::mlir::Value value, ::mlir::Value id) {
  odsState.addOperands(value);
  odsState.addOperands(id);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);
  odsState.addTypes(result);
}

void GroupNonUniformBroadcastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::spirv::ScopeAttr execution_scope, ::mlir::Value value, ::mlir::Value id) {
  odsState.addOperands(value);
  odsState.addOperands(id);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(GroupNonUniformBroadcastOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      /*regions=*/{}, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void GroupNonUniformBroadcastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::ScopeAttr execution_scope, ::mlir::Value value, ::mlir::Value id) {
  odsState.addOperands(value);
  odsState.addOperands(id);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GroupNonUniformBroadcastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::spirv::Scope execution_scope, ::mlir::Value value, ::mlir::Value id) {
  odsState.addOperands(value);
  odsState.addOperands(id);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));
  odsState.addTypes(result);
}

void GroupNonUniformBroadcastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::spirv::Scope execution_scope, ::mlir::Value value, ::mlir::Value id) {
  odsState.addOperands(value);
  odsState.addOperands(id);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(GroupNonUniformBroadcastOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      /*regions=*/{}, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void GroupNonUniformBroadcastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::Scope execution_scope, ::mlir::Value value, ::mlir::Value id) {
  odsState.addOperands(value);
  odsState.addOperands(id);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GroupNonUniformBroadcastOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void GroupNonUniformBroadcastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  ::mlir::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(GroupNonUniformBroadcastOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::mlir::LogicalResult GroupNonUniformBroadcastOp::verifyInvariantsImpl() {
  {
    auto tblgen_execution_scope = (*this)->getAttr(execution_scopeAttrName());
    if (!tblgen_execution_scope)
      return emitOpError("requires attribute 'execution_scope'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps1(*this, tblgen_execution_scope, "execution_scope")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps7(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps7(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((::llvm::is_splat(::llvm::makeArrayRef({(*this->getODSOperands(0).begin()).getType(), (*this->getODSResults(0).begin()).getType()})))))
    return emitOpError("failed to verify that all of {value, result} have same type");
  return ::mlir::success();
}

::mlir::LogicalResult GroupNonUniformBroadcastOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::LogicalResult GroupNonUniformBroadcastOp::inferReturnTypes(::mlir::MLIRContext *context, ::llvm::Optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  inferredReturnTypes[0] = operands[0].getType();
  return ::mlir::success();
}

::mlir::ParseResult GroupNonUniformBroadcastOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::spirv::ScopeAttr execution_scopeAttr;
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type valueRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> valueTypes(valueRawTypes);
  ::mlir::Type idRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> idTypes(idRawTypes);

  {
    ::llvm::StringRef attrStr;
    ::mlir::NamedAttrList attrStorage;
    auto loc = parser.getCurrentLocation();
    if (parser.parseOptionalKeyword(&attrStr, {"CrossDevice","Device","Workgroup","Subgroup","Invocation","QueueFamily","ShaderCallKHR"})) {
      ::mlir::StringAttr attrVal;
      ::mlir::OptionalParseResult parseResult =
        parser.parseOptionalAttribute(attrVal,
                                      parser.getBuilder().getNoneType(),
                                      "execution_scope", attrStorage);
      if (parseResult.hasValue()) {
        if (failed(*parseResult))
          return ::mlir::failure();
        attrStr = attrVal.getValue();
      } else {
        return parser.emitError(loc, "expected string or keyword containing one of the following enum values for attribute 'execution_scope' [CrossDevice, Device, Workgroup, Subgroup, Invocation, QueueFamily, ShaderCallKHR]");
      }
    }
    if (!attrStr.empty()) {
      auto attrOptional = ::mlir::spirv::symbolizeScope(attrStr);
      if (!attrOptional)
        return parser.emitError(loc, "invalid ")
               << "execution_scope attribute specification: \"" << attrStr << '"';;

      execution_scopeAttr = ::mlir::spirv::ScopeAttr::get(parser.getBuilder().getContext(), attrOptional.getValue());
      result.addAttribute("execution_scope", execution_scopeAttr);
    }
  }
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    valueRawTypes[0] = type;
  }
  if (parser.parseComma())
    return ::mlir::failure();

  {
    ::mlir::IntegerType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    idRawTypes[0] = type;
  }
  result.addTypes(valueTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(valueTypes), ::llvm::ArrayRef<::mlir::Type>(idTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GroupNonUniformBroadcastOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';

  {
    auto caseValue = execution_scope();
    auto caseValueStr = stringifyScope(caseValue);
    _odsPrinter << caseValueStr;
  }
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"execution_scope"});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = value().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';
  {
    auto type = id().getType();
    if (auto validType = type.dyn_cast<::mlir::IntegerType>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void GroupNonUniformBroadcastOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GroupNonUniformBroadcastOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GroupNonUniformElectOp definitions
//===----------------------------------------------------------------------===//

GroupNonUniformElectOpAdaptor::GroupNonUniformElectOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GroupNonUniformElectOpAdaptor::GroupNonUniformElectOpAdaptor(GroupNonUniformElectOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GroupNonUniformElectOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GroupNonUniformElectOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GroupNonUniformElectOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr GroupNonUniformElectOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ScopeAttr GroupNonUniformElectOpAdaptor::execution_scopeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ScopeAttr attr = odsAttrs.get("execution_scope").cast<::mlir::spirv::ScopeAttr>();
  return attr;
}

::mlir::spirv::Scope GroupNonUniformElectOpAdaptor::execution_scope() {
  auto attr = execution_scopeAttr();
  return attr.getValue();
}

::mlir::LogicalResult GroupNonUniformElectOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_execution_scope = odsAttrs.get("execution_scope");
    if (!tblgen_execution_scope)
      return emitError(loc, "'spv.GroupNonUniformElect' op ""requires attribute 'execution_scope'");

    if (tblgen_execution_scope && !((((tblgen_execution_scope.isa<::mlir::IntegerAttr>())) && ((tblgen_execution_scope.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(tblgen_execution_scope.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.GroupNonUniformElect' op ""attribute 'execution_scope' failed to satisfy constraint: valid SPIR-V Scope");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GroupNonUniformElectOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GroupNonUniformElectOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> GroupNonUniformElectOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GroupNonUniformElectOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformElectOp::result() {
  return *getODSResults(0).begin();
}

::mlir::spirv::ScopeAttr GroupNonUniformElectOp::execution_scopeAttr() {
  return (*this)->getAttr(execution_scopeAttrName()).cast<::mlir::spirv::ScopeAttr>();
}

::mlir::spirv::Scope GroupNonUniformElectOp::execution_scope() {
  auto attr = execution_scopeAttr();
  return attr.getValue();
}

void GroupNonUniformElectOp::execution_scopeAttr(::mlir::spirv::ScopeAttr attr) {
  (*this)->setAttr(execution_scopeAttrName(), attr);
}

void GroupNonUniformElectOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::spirv::ScopeAttr execution_scope) {
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);
  odsState.addTypes(result);
}

void GroupNonUniformElectOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::spirv::ScopeAttr execution_scope) {
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(GroupNonUniformElectOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      /*regions=*/{}, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void GroupNonUniformElectOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::ScopeAttr execution_scope) {
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GroupNonUniformElectOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::spirv::Scope execution_scope) {
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));
  odsState.addTypes(result);
}

void GroupNonUniformElectOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::spirv::Scope execution_scope) {
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(GroupNonUniformElectOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      /*regions=*/{}, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void GroupNonUniformElectOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::Scope execution_scope) {
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GroupNonUniformElectOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void GroupNonUniformElectOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  ::mlir::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(GroupNonUniformElectOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::mlir::LogicalResult GroupNonUniformElectOp::verifyInvariantsImpl() {
  {
    auto tblgen_execution_scope = (*this)->getAttr(execution_scopeAttrName());
    if (!tblgen_execution_scope)
      return emitOpError("requires attribute 'execution_scope'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps1(*this, tblgen_execution_scope, "execution_scope")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps6(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GroupNonUniformElectOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::LogicalResult GroupNonUniformElectOp::inferReturnTypes(::mlir::MLIRContext *context, ::llvm::Optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  inferredReturnTypes[0] = odsBuilder.getIntegerType(1);
  return ::mlir::success();
}

::mlir::ParseResult GroupNonUniformElectOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::spirv::ScopeAttr execution_scopeAttr;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  {
    ::llvm::StringRef attrStr;
    ::mlir::NamedAttrList attrStorage;
    auto loc = parser.getCurrentLocation();
    if (parser.parseOptionalKeyword(&attrStr, {"CrossDevice","Device","Workgroup","Subgroup","Invocation","QueueFamily","ShaderCallKHR"})) {
      ::mlir::StringAttr attrVal;
      ::mlir::OptionalParseResult parseResult =
        parser.parseOptionalAttribute(attrVal,
                                      parser.getBuilder().getNoneType(),
                                      "execution_scope", attrStorage);
      if (parseResult.hasValue()) {
        if (failed(*parseResult))
          return ::mlir::failure();
        attrStr = attrVal.getValue();
      } else {
        return parser.emitError(loc, "expected string or keyword containing one of the following enum values for attribute 'execution_scope' [CrossDevice, Device, Workgroup, Subgroup, Invocation, QueueFamily, ShaderCallKHR]");
      }
    }
    if (!attrStr.empty()) {
      auto attrOptional = ::mlir::spirv::symbolizeScope(attrStr);
      if (!attrOptional)
        return parser.emitError(loc, "invalid ")
               << "execution_scope attribute specification: \"" << attrStr << '"';;

      execution_scopeAttr = ::mlir::spirv::ScopeAttr::get(parser.getBuilder().getContext(), attrOptional.getValue());
      result.addAttribute("execution_scope", execution_scopeAttr);
    }
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  return ::mlir::success();
}

void GroupNonUniformElectOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';

  {
    auto caseValue = execution_scope();
    auto caseValueStr = stringifyScope(caseValue);
    _odsPrinter << caseValueStr;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"execution_scope"});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GroupNonUniformElectOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GroupNonUniformFAddOp definitions
//===----------------------------------------------------------------------===//

GroupNonUniformFAddOpAdaptor::GroupNonUniformFAddOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GroupNonUniformFAddOpAdaptor::GroupNonUniformFAddOpAdaptor(GroupNonUniformFAddOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GroupNonUniformFAddOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GroupNonUniformFAddOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange GroupNonUniformFAddOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformFAddOpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value GroupNonUniformFAddOpAdaptor::cluster_size() {
  auto operands = getODSOperands(1);
  return operands.empty() ? ::mlir::Value() : *operands.begin();
}

::mlir::DictionaryAttr GroupNonUniformFAddOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ScopeAttr GroupNonUniformFAddOpAdaptor::execution_scopeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ScopeAttr attr = odsAttrs.get("execution_scope").cast<::mlir::spirv::ScopeAttr>();
  return attr;
}

::mlir::spirv::Scope GroupNonUniformFAddOpAdaptor::execution_scope() {
  auto attr = execution_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::GroupOperationAttr GroupNonUniformFAddOpAdaptor::group_operationAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::GroupOperationAttr attr = odsAttrs.get("group_operation").cast<::mlir::spirv::GroupOperationAttr>();
  return attr;
}

::mlir::spirv::GroupOperation GroupNonUniformFAddOpAdaptor::group_operation() {
  auto attr = group_operationAttr();
  return attr.getValue();
}

::mlir::LogicalResult GroupNonUniformFAddOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_execution_scope = odsAttrs.get("execution_scope");
    if (!tblgen_execution_scope)
      return emitError(loc, "'spv.GroupNonUniformFAdd' op ""requires attribute 'execution_scope'");

    if (tblgen_execution_scope && !((((tblgen_execution_scope.isa<::mlir::IntegerAttr>())) && ((tblgen_execution_scope.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(tblgen_execution_scope.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.GroupNonUniformFAdd' op ""attribute 'execution_scope' failed to satisfy constraint: valid SPIR-V Scope");
  }
  {
    auto tblgen_group_operation = odsAttrs.get("group_operation");
    if (!tblgen_group_operation)
      return emitError(loc, "'spv.GroupNonUniformFAdd' op ""requires attribute 'group_operation'");

    if (tblgen_group_operation && !((((tblgen_group_operation.isa<::mlir::IntegerAttr>())) && ((tblgen_group_operation.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeGroupOperation(tblgen_group_operation.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.GroupNonUniformFAdd' op ""attribute 'group_operation' failed to satisfy constraint: valid SPIR-V GroupOperation");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GroupNonUniformFAddOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range GroupNonUniformFAddOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformFAddOp::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value GroupNonUniformFAddOp::cluster_size() {
  auto operands = getODSOperands(1);
  return operands.empty() ? ::mlir::Value() : *operands.begin();
}

::mlir::MutableOperandRange GroupNonUniformFAddOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange GroupNonUniformFAddOp::cluster_sizeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GroupNonUniformFAddOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GroupNonUniformFAddOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformFAddOp::result() {
  return *getODSResults(0).begin();
}

::mlir::spirv::ScopeAttr GroupNonUniformFAddOp::execution_scopeAttr() {
  return (*this)->getAttr(execution_scopeAttrName()).cast<::mlir::spirv::ScopeAttr>();
}

::mlir::spirv::Scope GroupNonUniformFAddOp::execution_scope() {
  auto attr = execution_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::GroupOperationAttr GroupNonUniformFAddOp::group_operationAttr() {
  return (*this)->getAttr(group_operationAttrName()).cast<::mlir::spirv::GroupOperationAttr>();
}

::mlir::spirv::GroupOperation GroupNonUniformFAddOp::group_operation() {
  auto attr = group_operationAttr();
  return attr.getValue();
}

void GroupNonUniformFAddOp::execution_scopeAttr(::mlir::spirv::ScopeAttr attr) {
  (*this)->setAttr(execution_scopeAttrName(), attr);
}

void GroupNonUniformFAddOp::group_operationAttr(::mlir::spirv::GroupOperationAttr attr) {
  (*this)->setAttr(group_operationAttrName(), attr);
}

void GroupNonUniformFAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::spirv::ScopeAttr execution_scope, ::mlir::spirv::GroupOperationAttr group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);
  odsState.addAttribute(group_operationAttrName(odsState.name), group_operation);
  odsState.addTypes(result);
}

void GroupNonUniformFAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::ScopeAttr execution_scope, ::mlir::spirv::GroupOperationAttr group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);
  odsState.addAttribute(group_operationAttrName(odsState.name), group_operation);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GroupNonUniformFAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::spirv::Scope execution_scope, ::mlir::spirv::GroupOperation group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));
  odsState.addAttribute(group_operationAttrName(odsState.name), ::mlir::spirv::GroupOperationAttr::get(odsBuilder.getContext(), group_operation));
  odsState.addTypes(result);
}

void GroupNonUniformFAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::Scope execution_scope, ::mlir::spirv::GroupOperation group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));
  odsState.addAttribute(group_operationAttrName(odsState.name), ::mlir::spirv::GroupOperationAttr::get(odsBuilder.getContext(), group_operation));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GroupNonUniformFAddOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult GroupNonUniformFAddOp::verifyInvariantsImpl() {
  {
    auto tblgen_execution_scope = (*this)->getAttr(execution_scopeAttrName());
    if (!tblgen_execution_scope)
      return emitOpError("requires attribute 'execution_scope'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps1(*this, tblgen_execution_scope, "execution_scope")))
      return ::mlir::failure();
  }
  {
    auto tblgen_group_operation = (*this)->getAttr(group_operationAttrName());
    if (!tblgen_group_operation)
      return emitOpError("requires attribute 'group_operation'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps13(*this, tblgen_group_operation, "group_operation")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    if (valueGroup1.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup1.size();
    }

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GroupNonUniformFAddOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GroupNonUniformFAddOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GroupNonUniformFMaxOp definitions
//===----------------------------------------------------------------------===//

GroupNonUniformFMaxOpAdaptor::GroupNonUniformFMaxOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GroupNonUniformFMaxOpAdaptor::GroupNonUniformFMaxOpAdaptor(GroupNonUniformFMaxOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GroupNonUniformFMaxOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GroupNonUniformFMaxOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange GroupNonUniformFMaxOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformFMaxOpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value GroupNonUniformFMaxOpAdaptor::cluster_size() {
  auto operands = getODSOperands(1);
  return operands.empty() ? ::mlir::Value() : *operands.begin();
}

::mlir::DictionaryAttr GroupNonUniformFMaxOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ScopeAttr GroupNonUniformFMaxOpAdaptor::execution_scopeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ScopeAttr attr = odsAttrs.get("execution_scope").cast<::mlir::spirv::ScopeAttr>();
  return attr;
}

::mlir::spirv::Scope GroupNonUniformFMaxOpAdaptor::execution_scope() {
  auto attr = execution_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::GroupOperationAttr GroupNonUniformFMaxOpAdaptor::group_operationAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::GroupOperationAttr attr = odsAttrs.get("group_operation").cast<::mlir::spirv::GroupOperationAttr>();
  return attr;
}

::mlir::spirv::GroupOperation GroupNonUniformFMaxOpAdaptor::group_operation() {
  auto attr = group_operationAttr();
  return attr.getValue();
}

::mlir::LogicalResult GroupNonUniformFMaxOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_execution_scope = odsAttrs.get("execution_scope");
    if (!tblgen_execution_scope)
      return emitError(loc, "'spv.GroupNonUniformFMax' op ""requires attribute 'execution_scope'");

    if (tblgen_execution_scope && !((((tblgen_execution_scope.isa<::mlir::IntegerAttr>())) && ((tblgen_execution_scope.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(tblgen_execution_scope.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.GroupNonUniformFMax' op ""attribute 'execution_scope' failed to satisfy constraint: valid SPIR-V Scope");
  }
  {
    auto tblgen_group_operation = odsAttrs.get("group_operation");
    if (!tblgen_group_operation)
      return emitError(loc, "'spv.GroupNonUniformFMax' op ""requires attribute 'group_operation'");

    if (tblgen_group_operation && !((((tblgen_group_operation.isa<::mlir::IntegerAttr>())) && ((tblgen_group_operation.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeGroupOperation(tblgen_group_operation.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.GroupNonUniformFMax' op ""attribute 'group_operation' failed to satisfy constraint: valid SPIR-V GroupOperation");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GroupNonUniformFMaxOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range GroupNonUniformFMaxOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformFMaxOp::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value GroupNonUniformFMaxOp::cluster_size() {
  auto operands = getODSOperands(1);
  return operands.empty() ? ::mlir::Value() : *operands.begin();
}

::mlir::MutableOperandRange GroupNonUniformFMaxOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange GroupNonUniformFMaxOp::cluster_sizeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GroupNonUniformFMaxOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GroupNonUniformFMaxOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformFMaxOp::result() {
  return *getODSResults(0).begin();
}

::mlir::spirv::ScopeAttr GroupNonUniformFMaxOp::execution_scopeAttr() {
  return (*this)->getAttr(execution_scopeAttrName()).cast<::mlir::spirv::ScopeAttr>();
}

::mlir::spirv::Scope GroupNonUniformFMaxOp::execution_scope() {
  auto attr = execution_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::GroupOperationAttr GroupNonUniformFMaxOp::group_operationAttr() {
  return (*this)->getAttr(group_operationAttrName()).cast<::mlir::spirv::GroupOperationAttr>();
}

::mlir::spirv::GroupOperation GroupNonUniformFMaxOp::group_operation() {
  auto attr = group_operationAttr();
  return attr.getValue();
}

void GroupNonUniformFMaxOp::execution_scopeAttr(::mlir::spirv::ScopeAttr attr) {
  (*this)->setAttr(execution_scopeAttrName(), attr);
}

void GroupNonUniformFMaxOp::group_operationAttr(::mlir::spirv::GroupOperationAttr attr) {
  (*this)->setAttr(group_operationAttrName(), attr);
}

void GroupNonUniformFMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::spirv::ScopeAttr execution_scope, ::mlir::spirv::GroupOperationAttr group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);
  odsState.addAttribute(group_operationAttrName(odsState.name), group_operation);
  odsState.addTypes(result);
}

void GroupNonUniformFMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::ScopeAttr execution_scope, ::mlir::spirv::GroupOperationAttr group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);
  odsState.addAttribute(group_operationAttrName(odsState.name), group_operation);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GroupNonUniformFMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::spirv::Scope execution_scope, ::mlir::spirv::GroupOperation group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));
  odsState.addAttribute(group_operationAttrName(odsState.name), ::mlir::spirv::GroupOperationAttr::get(odsBuilder.getContext(), group_operation));
  odsState.addTypes(result);
}

void GroupNonUniformFMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::Scope execution_scope, ::mlir::spirv::GroupOperation group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));
  odsState.addAttribute(group_operationAttrName(odsState.name), ::mlir::spirv::GroupOperationAttr::get(odsBuilder.getContext(), group_operation));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GroupNonUniformFMaxOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult GroupNonUniformFMaxOp::verifyInvariantsImpl() {
  {
    auto tblgen_execution_scope = (*this)->getAttr(execution_scopeAttrName());
    if (!tblgen_execution_scope)
      return emitOpError("requires attribute 'execution_scope'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps1(*this, tblgen_execution_scope, "execution_scope")))
      return ::mlir::failure();
  }
  {
    auto tblgen_group_operation = (*this)->getAttr(group_operationAttrName());
    if (!tblgen_group_operation)
      return emitOpError("requires attribute 'group_operation'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps13(*this, tblgen_group_operation, "group_operation")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    if (valueGroup1.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup1.size();
    }

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GroupNonUniformFMaxOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GroupNonUniformFMaxOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GroupNonUniformFMinOp definitions
//===----------------------------------------------------------------------===//

GroupNonUniformFMinOpAdaptor::GroupNonUniformFMinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GroupNonUniformFMinOpAdaptor::GroupNonUniformFMinOpAdaptor(GroupNonUniformFMinOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GroupNonUniformFMinOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GroupNonUniformFMinOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange GroupNonUniformFMinOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformFMinOpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value GroupNonUniformFMinOpAdaptor::cluster_size() {
  auto operands = getODSOperands(1);
  return operands.empty() ? ::mlir::Value() : *operands.begin();
}

::mlir::DictionaryAttr GroupNonUniformFMinOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ScopeAttr GroupNonUniformFMinOpAdaptor::execution_scopeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ScopeAttr attr = odsAttrs.get("execution_scope").cast<::mlir::spirv::ScopeAttr>();
  return attr;
}

::mlir::spirv::Scope GroupNonUniformFMinOpAdaptor::execution_scope() {
  auto attr = execution_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::GroupOperationAttr GroupNonUniformFMinOpAdaptor::group_operationAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::GroupOperationAttr attr = odsAttrs.get("group_operation").cast<::mlir::spirv::GroupOperationAttr>();
  return attr;
}

::mlir::spirv::GroupOperation GroupNonUniformFMinOpAdaptor::group_operation() {
  auto attr = group_operationAttr();
  return attr.getValue();
}

::mlir::LogicalResult GroupNonUniformFMinOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_execution_scope = odsAttrs.get("execution_scope");
    if (!tblgen_execution_scope)
      return emitError(loc, "'spv.GroupNonUniformFMin' op ""requires attribute 'execution_scope'");

    if (tblgen_execution_scope && !((((tblgen_execution_scope.isa<::mlir::IntegerAttr>())) && ((tblgen_execution_scope.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(tblgen_execution_scope.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.GroupNonUniformFMin' op ""attribute 'execution_scope' failed to satisfy constraint: valid SPIR-V Scope");
  }
  {
    auto tblgen_group_operation = odsAttrs.get("group_operation");
    if (!tblgen_group_operation)
      return emitError(loc, "'spv.GroupNonUniformFMin' op ""requires attribute 'group_operation'");

    if (tblgen_group_operation && !((((tblgen_group_operation.isa<::mlir::IntegerAttr>())) && ((tblgen_group_operation.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeGroupOperation(tblgen_group_operation.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.GroupNonUniformFMin' op ""attribute 'group_operation' failed to satisfy constraint: valid SPIR-V GroupOperation");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GroupNonUniformFMinOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range GroupNonUniformFMinOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformFMinOp::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value GroupNonUniformFMinOp::cluster_size() {
  auto operands = getODSOperands(1);
  return operands.empty() ? ::mlir::Value() : *operands.begin();
}

::mlir::MutableOperandRange GroupNonUniformFMinOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange GroupNonUniformFMinOp::cluster_sizeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GroupNonUniformFMinOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GroupNonUniformFMinOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformFMinOp::result() {
  return *getODSResults(0).begin();
}

::mlir::spirv::ScopeAttr GroupNonUniformFMinOp::execution_scopeAttr() {
  return (*this)->getAttr(execution_scopeAttrName()).cast<::mlir::spirv::ScopeAttr>();
}

::mlir::spirv::Scope GroupNonUniformFMinOp::execution_scope() {
  auto attr = execution_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::GroupOperationAttr GroupNonUniformFMinOp::group_operationAttr() {
  return (*this)->getAttr(group_operationAttrName()).cast<::mlir::spirv::GroupOperationAttr>();
}

::mlir::spirv::GroupOperation GroupNonUniformFMinOp::group_operation() {
  auto attr = group_operationAttr();
  return attr.getValue();
}

void GroupNonUniformFMinOp::execution_scopeAttr(::mlir::spirv::ScopeAttr attr) {
  (*this)->setAttr(execution_scopeAttrName(), attr);
}

void GroupNonUniformFMinOp::group_operationAttr(::mlir::spirv::GroupOperationAttr attr) {
  (*this)->setAttr(group_operationAttrName(), attr);
}

void GroupNonUniformFMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::spirv::ScopeAttr execution_scope, ::mlir::spirv::GroupOperationAttr group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);
  odsState.addAttribute(group_operationAttrName(odsState.name), group_operation);
  odsState.addTypes(result);
}

void GroupNonUniformFMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::ScopeAttr execution_scope, ::mlir::spirv::GroupOperationAttr group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);
  odsState.addAttribute(group_operationAttrName(odsState.name), group_operation);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GroupNonUniformFMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::spirv::Scope execution_scope, ::mlir::spirv::GroupOperation group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));
  odsState.addAttribute(group_operationAttrName(odsState.name), ::mlir::spirv::GroupOperationAttr::get(odsBuilder.getContext(), group_operation));
  odsState.addTypes(result);
}

void GroupNonUniformFMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::Scope execution_scope, ::mlir::spirv::GroupOperation group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));
  odsState.addAttribute(group_operationAttrName(odsState.name), ::mlir::spirv::GroupOperationAttr::get(odsBuilder.getContext(), group_operation));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GroupNonUniformFMinOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult GroupNonUniformFMinOp::verifyInvariantsImpl() {
  {
    auto tblgen_execution_scope = (*this)->getAttr(execution_scopeAttrName());
    if (!tblgen_execution_scope)
      return emitOpError("requires attribute 'execution_scope'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps1(*this, tblgen_execution_scope, "execution_scope")))
      return ::mlir::failure();
  }
  {
    auto tblgen_group_operation = (*this)->getAttr(group_operationAttrName());
    if (!tblgen_group_operation)
      return emitOpError("requires attribute 'group_operation'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps13(*this, tblgen_group_operation, "group_operation")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    if (valueGroup1.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup1.size();
    }

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GroupNonUniformFMinOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GroupNonUniformFMinOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GroupNonUniformFMulOp definitions
//===----------------------------------------------------------------------===//

GroupNonUniformFMulOpAdaptor::GroupNonUniformFMulOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GroupNonUniformFMulOpAdaptor::GroupNonUniformFMulOpAdaptor(GroupNonUniformFMulOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GroupNonUniformFMulOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GroupNonUniformFMulOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange GroupNonUniformFMulOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformFMulOpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value GroupNonUniformFMulOpAdaptor::cluster_size() {
  auto operands = getODSOperands(1);
  return operands.empty() ? ::mlir::Value() : *operands.begin();
}

::mlir::DictionaryAttr GroupNonUniformFMulOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ScopeAttr GroupNonUniformFMulOpAdaptor::execution_scopeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ScopeAttr attr = odsAttrs.get("execution_scope").cast<::mlir::spirv::ScopeAttr>();
  return attr;
}

::mlir::spirv::Scope GroupNonUniformFMulOpAdaptor::execution_scope() {
  auto attr = execution_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::GroupOperationAttr GroupNonUniformFMulOpAdaptor::group_operationAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::GroupOperationAttr attr = odsAttrs.get("group_operation").cast<::mlir::spirv::GroupOperationAttr>();
  return attr;
}

::mlir::spirv::GroupOperation GroupNonUniformFMulOpAdaptor::group_operation() {
  auto attr = group_operationAttr();
  return attr.getValue();
}

::mlir::LogicalResult GroupNonUniformFMulOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_execution_scope = odsAttrs.get("execution_scope");
    if (!tblgen_execution_scope)
      return emitError(loc, "'spv.GroupNonUniformFMul' op ""requires attribute 'execution_scope'");

    if (tblgen_execution_scope && !((((tblgen_execution_scope.isa<::mlir::IntegerAttr>())) && ((tblgen_execution_scope.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(tblgen_execution_scope.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.GroupNonUniformFMul' op ""attribute 'execution_scope' failed to satisfy constraint: valid SPIR-V Scope");
  }
  {
    auto tblgen_group_operation = odsAttrs.get("group_operation");
    if (!tblgen_group_operation)
      return emitError(loc, "'spv.GroupNonUniformFMul' op ""requires attribute 'group_operation'");

    if (tblgen_group_operation && !((((tblgen_group_operation.isa<::mlir::IntegerAttr>())) && ((tblgen_group_operation.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeGroupOperation(tblgen_group_operation.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.GroupNonUniformFMul' op ""attribute 'group_operation' failed to satisfy constraint: valid SPIR-V GroupOperation");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GroupNonUniformFMulOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range GroupNonUniformFMulOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformFMulOp::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value GroupNonUniformFMulOp::cluster_size() {
  auto operands = getODSOperands(1);
  return operands.empty() ? ::mlir::Value() : *operands.begin();
}

::mlir::MutableOperandRange GroupNonUniformFMulOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange GroupNonUniformFMulOp::cluster_sizeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GroupNonUniformFMulOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GroupNonUniformFMulOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformFMulOp::result() {
  return *getODSResults(0).begin();
}

::mlir::spirv::ScopeAttr GroupNonUniformFMulOp::execution_scopeAttr() {
  return (*this)->getAttr(execution_scopeAttrName()).cast<::mlir::spirv::ScopeAttr>();
}

::mlir::spirv::Scope GroupNonUniformFMulOp::execution_scope() {
  auto attr = execution_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::GroupOperationAttr GroupNonUniformFMulOp::group_operationAttr() {
  return (*this)->getAttr(group_operationAttrName()).cast<::mlir::spirv::GroupOperationAttr>();
}

::mlir::spirv::GroupOperation GroupNonUniformFMulOp::group_operation() {
  auto attr = group_operationAttr();
  return attr.getValue();
}

void GroupNonUniformFMulOp::execution_scopeAttr(::mlir::spirv::ScopeAttr attr) {
  (*this)->setAttr(execution_scopeAttrName(), attr);
}

void GroupNonUniformFMulOp::group_operationAttr(::mlir::spirv::GroupOperationAttr attr) {
  (*this)->setAttr(group_operationAttrName(), attr);
}

void GroupNonUniformFMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::spirv::ScopeAttr execution_scope, ::mlir::spirv::GroupOperationAttr group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);
  odsState.addAttribute(group_operationAttrName(odsState.name), group_operation);
  odsState.addTypes(result);
}

void GroupNonUniformFMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::ScopeAttr execution_scope, ::mlir::spirv::GroupOperationAttr group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);
  odsState.addAttribute(group_operationAttrName(odsState.name), group_operation);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GroupNonUniformFMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::spirv::Scope execution_scope, ::mlir::spirv::GroupOperation group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));
  odsState.addAttribute(group_operationAttrName(odsState.name), ::mlir::spirv::GroupOperationAttr::get(odsBuilder.getContext(), group_operation));
  odsState.addTypes(result);
}

void GroupNonUniformFMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::Scope execution_scope, ::mlir::spirv::GroupOperation group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));
  odsState.addAttribute(group_operationAttrName(odsState.name), ::mlir::spirv::GroupOperationAttr::get(odsBuilder.getContext(), group_operation));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GroupNonUniformFMulOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult GroupNonUniformFMulOp::verifyInvariantsImpl() {
  {
    auto tblgen_execution_scope = (*this)->getAttr(execution_scopeAttrName());
    if (!tblgen_execution_scope)
      return emitOpError("requires attribute 'execution_scope'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps1(*this, tblgen_execution_scope, "execution_scope")))
      return ::mlir::failure();
  }
  {
    auto tblgen_group_operation = (*this)->getAttr(group_operationAttrName());
    if (!tblgen_group_operation)
      return emitOpError("requires attribute 'group_operation'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps13(*this, tblgen_group_operation, "group_operation")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    if (valueGroup1.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup1.size();
    }

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GroupNonUniformFMulOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GroupNonUniformFMulOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GroupNonUniformIAddOp definitions
//===----------------------------------------------------------------------===//

GroupNonUniformIAddOpAdaptor::GroupNonUniformIAddOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GroupNonUniformIAddOpAdaptor::GroupNonUniformIAddOpAdaptor(GroupNonUniformIAddOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GroupNonUniformIAddOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GroupNonUniformIAddOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange GroupNonUniformIAddOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformIAddOpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value GroupNonUniformIAddOpAdaptor::cluster_size() {
  auto operands = getODSOperands(1);
  return operands.empty() ? ::mlir::Value() : *operands.begin();
}

::mlir::DictionaryAttr GroupNonUniformIAddOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ScopeAttr GroupNonUniformIAddOpAdaptor::execution_scopeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ScopeAttr attr = odsAttrs.get("execution_scope").cast<::mlir::spirv::ScopeAttr>();
  return attr;
}

::mlir::spirv::Scope GroupNonUniformIAddOpAdaptor::execution_scope() {
  auto attr = execution_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::GroupOperationAttr GroupNonUniformIAddOpAdaptor::group_operationAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::GroupOperationAttr attr = odsAttrs.get("group_operation").cast<::mlir::spirv::GroupOperationAttr>();
  return attr;
}

::mlir::spirv::GroupOperation GroupNonUniformIAddOpAdaptor::group_operation() {
  auto attr = group_operationAttr();
  return attr.getValue();
}

::mlir::LogicalResult GroupNonUniformIAddOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_execution_scope = odsAttrs.get("execution_scope");
    if (!tblgen_execution_scope)
      return emitError(loc, "'spv.GroupNonUniformIAdd' op ""requires attribute 'execution_scope'");

    if (tblgen_execution_scope && !((((tblgen_execution_scope.isa<::mlir::IntegerAttr>())) && ((tblgen_execution_scope.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(tblgen_execution_scope.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.GroupNonUniformIAdd' op ""attribute 'execution_scope' failed to satisfy constraint: valid SPIR-V Scope");
  }
  {
    auto tblgen_group_operation = odsAttrs.get("group_operation");
    if (!tblgen_group_operation)
      return emitError(loc, "'spv.GroupNonUniformIAdd' op ""requires attribute 'group_operation'");

    if (tblgen_group_operation && !((((tblgen_group_operation.isa<::mlir::IntegerAttr>())) && ((tblgen_group_operation.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeGroupOperation(tblgen_group_operation.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.GroupNonUniformIAdd' op ""attribute 'group_operation' failed to satisfy constraint: valid SPIR-V GroupOperation");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GroupNonUniformIAddOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range GroupNonUniformIAddOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformIAddOp::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value GroupNonUniformIAddOp::cluster_size() {
  auto operands = getODSOperands(1);
  return operands.empty() ? ::mlir::Value() : *operands.begin();
}

::mlir::MutableOperandRange GroupNonUniformIAddOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange GroupNonUniformIAddOp::cluster_sizeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GroupNonUniformIAddOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GroupNonUniformIAddOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformIAddOp::result() {
  return *getODSResults(0).begin();
}

::mlir::spirv::ScopeAttr GroupNonUniformIAddOp::execution_scopeAttr() {
  return (*this)->getAttr(execution_scopeAttrName()).cast<::mlir::spirv::ScopeAttr>();
}

::mlir::spirv::Scope GroupNonUniformIAddOp::execution_scope() {
  auto attr = execution_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::GroupOperationAttr GroupNonUniformIAddOp::group_operationAttr() {
  return (*this)->getAttr(group_operationAttrName()).cast<::mlir::spirv::GroupOperationAttr>();
}

::mlir::spirv::GroupOperation GroupNonUniformIAddOp::group_operation() {
  auto attr = group_operationAttr();
  return attr.getValue();
}

void GroupNonUniformIAddOp::execution_scopeAttr(::mlir::spirv::ScopeAttr attr) {
  (*this)->setAttr(execution_scopeAttrName(), attr);
}

void GroupNonUniformIAddOp::group_operationAttr(::mlir::spirv::GroupOperationAttr attr) {
  (*this)->setAttr(group_operationAttrName(), attr);
}

void GroupNonUniformIAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::spirv::ScopeAttr execution_scope, ::mlir::spirv::GroupOperationAttr group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);
  odsState.addAttribute(group_operationAttrName(odsState.name), group_operation);
  odsState.addTypes(result);
}

void GroupNonUniformIAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::ScopeAttr execution_scope, ::mlir::spirv::GroupOperationAttr group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);
  odsState.addAttribute(group_operationAttrName(odsState.name), group_operation);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GroupNonUniformIAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::spirv::Scope execution_scope, ::mlir::spirv::GroupOperation group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));
  odsState.addAttribute(group_operationAttrName(odsState.name), ::mlir::spirv::GroupOperationAttr::get(odsBuilder.getContext(), group_operation));
  odsState.addTypes(result);
}

void GroupNonUniformIAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::Scope execution_scope, ::mlir::spirv::GroupOperation group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));
  odsState.addAttribute(group_operationAttrName(odsState.name), ::mlir::spirv::GroupOperationAttr::get(odsBuilder.getContext(), group_operation));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GroupNonUniformIAddOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult GroupNonUniformIAddOp::verifyInvariantsImpl() {
  {
    auto tblgen_execution_scope = (*this)->getAttr(execution_scopeAttrName());
    if (!tblgen_execution_scope)
      return emitOpError("requires attribute 'execution_scope'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps1(*this, tblgen_execution_scope, "execution_scope")))
      return ::mlir::failure();
  }
  {
    auto tblgen_group_operation = (*this)->getAttr(group_operationAttrName());
    if (!tblgen_group_operation)
      return emitOpError("requires attribute 'group_operation'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps13(*this, tblgen_group_operation, "group_operation")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    if (valueGroup1.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup1.size();
    }

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GroupNonUniformIAddOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GroupNonUniformIAddOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GroupNonUniformIMulOp definitions
//===----------------------------------------------------------------------===//

GroupNonUniformIMulOpAdaptor::GroupNonUniformIMulOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GroupNonUniformIMulOpAdaptor::GroupNonUniformIMulOpAdaptor(GroupNonUniformIMulOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GroupNonUniformIMulOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GroupNonUniformIMulOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange GroupNonUniformIMulOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformIMulOpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value GroupNonUniformIMulOpAdaptor::cluster_size() {
  auto operands = getODSOperands(1);
  return operands.empty() ? ::mlir::Value() : *operands.begin();
}

::mlir::DictionaryAttr GroupNonUniformIMulOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ScopeAttr GroupNonUniformIMulOpAdaptor::execution_scopeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ScopeAttr attr = odsAttrs.get("execution_scope").cast<::mlir::spirv::ScopeAttr>();
  return attr;
}

::mlir::spirv::Scope GroupNonUniformIMulOpAdaptor::execution_scope() {
  auto attr = execution_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::GroupOperationAttr GroupNonUniformIMulOpAdaptor::group_operationAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::GroupOperationAttr attr = odsAttrs.get("group_operation").cast<::mlir::spirv::GroupOperationAttr>();
  return attr;
}

::mlir::spirv::GroupOperation GroupNonUniformIMulOpAdaptor::group_operation() {
  auto attr = group_operationAttr();
  return attr.getValue();
}

::mlir::LogicalResult GroupNonUniformIMulOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_execution_scope = odsAttrs.get("execution_scope");
    if (!tblgen_execution_scope)
      return emitError(loc, "'spv.GroupNonUniformIMul' op ""requires attribute 'execution_scope'");

    if (tblgen_execution_scope && !((((tblgen_execution_scope.isa<::mlir::IntegerAttr>())) && ((tblgen_execution_scope.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(tblgen_execution_scope.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.GroupNonUniformIMul' op ""attribute 'execution_scope' failed to satisfy constraint: valid SPIR-V Scope");
  }
  {
    auto tblgen_group_operation = odsAttrs.get("group_operation");
    if (!tblgen_group_operation)
      return emitError(loc, "'spv.GroupNonUniformIMul' op ""requires attribute 'group_operation'");

    if (tblgen_group_operation && !((((tblgen_group_operation.isa<::mlir::IntegerAttr>())) && ((tblgen_group_operation.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeGroupOperation(tblgen_group_operation.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.GroupNonUniformIMul' op ""attribute 'group_operation' failed to satisfy constraint: valid SPIR-V GroupOperation");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GroupNonUniformIMulOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range GroupNonUniformIMulOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformIMulOp::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value GroupNonUniformIMulOp::cluster_size() {
  auto operands = getODSOperands(1);
  return operands.empty() ? ::mlir::Value() : *operands.begin();
}

::mlir::MutableOperandRange GroupNonUniformIMulOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange GroupNonUniformIMulOp::cluster_sizeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GroupNonUniformIMulOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GroupNonUniformIMulOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformIMulOp::result() {
  return *getODSResults(0).begin();
}

::mlir::spirv::ScopeAttr GroupNonUniformIMulOp::execution_scopeAttr() {
  return (*this)->getAttr(execution_scopeAttrName()).cast<::mlir::spirv::ScopeAttr>();
}

::mlir::spirv::Scope GroupNonUniformIMulOp::execution_scope() {
  auto attr = execution_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::GroupOperationAttr GroupNonUniformIMulOp::group_operationAttr() {
  return (*this)->getAttr(group_operationAttrName()).cast<::mlir::spirv::GroupOperationAttr>();
}

::mlir::spirv::GroupOperation GroupNonUniformIMulOp::group_operation() {
  auto attr = group_operationAttr();
  return attr.getValue();
}

void GroupNonUniformIMulOp::execution_scopeAttr(::mlir::spirv::ScopeAttr attr) {
  (*this)->setAttr(execution_scopeAttrName(), attr);
}

void GroupNonUniformIMulOp::group_operationAttr(::mlir::spirv::GroupOperationAttr attr) {
  (*this)->setAttr(group_operationAttrName(), attr);
}

void GroupNonUniformIMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::spirv::ScopeAttr execution_scope, ::mlir::spirv::GroupOperationAttr group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);
  odsState.addAttribute(group_operationAttrName(odsState.name), group_operation);
  odsState.addTypes(result);
}

void GroupNonUniformIMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::ScopeAttr execution_scope, ::mlir::spirv::GroupOperationAttr group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);
  odsState.addAttribute(group_operationAttrName(odsState.name), group_operation);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GroupNonUniformIMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::spirv::Scope execution_scope, ::mlir::spirv::GroupOperation group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));
  odsState.addAttribute(group_operationAttrName(odsState.name), ::mlir::spirv::GroupOperationAttr::get(odsBuilder.getContext(), group_operation));
  odsState.addTypes(result);
}

void GroupNonUniformIMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::Scope execution_scope, ::mlir::spirv::GroupOperation group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));
  odsState.addAttribute(group_operationAttrName(odsState.name), ::mlir::spirv::GroupOperationAttr::get(odsBuilder.getContext(), group_operation));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GroupNonUniformIMulOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult GroupNonUniformIMulOp::verifyInvariantsImpl() {
  {
    auto tblgen_execution_scope = (*this)->getAttr(execution_scopeAttrName());
    if (!tblgen_execution_scope)
      return emitOpError("requires attribute 'execution_scope'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps1(*this, tblgen_execution_scope, "execution_scope")))
      return ::mlir::failure();
  }
  {
    auto tblgen_group_operation = (*this)->getAttr(group_operationAttrName());
    if (!tblgen_group_operation)
      return emitOpError("requires attribute 'group_operation'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps13(*this, tblgen_group_operation, "group_operation")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    if (valueGroup1.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup1.size();
    }

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GroupNonUniformIMulOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GroupNonUniformIMulOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GroupNonUniformSMaxOp definitions
//===----------------------------------------------------------------------===//

GroupNonUniformSMaxOpAdaptor::GroupNonUniformSMaxOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GroupNonUniformSMaxOpAdaptor::GroupNonUniformSMaxOpAdaptor(GroupNonUniformSMaxOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GroupNonUniformSMaxOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GroupNonUniformSMaxOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange GroupNonUniformSMaxOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformSMaxOpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value GroupNonUniformSMaxOpAdaptor::cluster_size() {
  auto operands = getODSOperands(1);
  return operands.empty() ? ::mlir::Value() : *operands.begin();
}

::mlir::DictionaryAttr GroupNonUniformSMaxOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ScopeAttr GroupNonUniformSMaxOpAdaptor::execution_scopeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ScopeAttr attr = odsAttrs.get("execution_scope").cast<::mlir::spirv::ScopeAttr>();
  return attr;
}

::mlir::spirv::Scope GroupNonUniformSMaxOpAdaptor::execution_scope() {
  auto attr = execution_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::GroupOperationAttr GroupNonUniformSMaxOpAdaptor::group_operationAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::GroupOperationAttr attr = odsAttrs.get("group_operation").cast<::mlir::spirv::GroupOperationAttr>();
  return attr;
}

::mlir::spirv::GroupOperation GroupNonUniformSMaxOpAdaptor::group_operation() {
  auto attr = group_operationAttr();
  return attr.getValue();
}

::mlir::LogicalResult GroupNonUniformSMaxOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_execution_scope = odsAttrs.get("execution_scope");
    if (!tblgen_execution_scope)
      return emitError(loc, "'spv.GroupNonUniformSMax' op ""requires attribute 'execution_scope'");

    if (tblgen_execution_scope && !((((tblgen_execution_scope.isa<::mlir::IntegerAttr>())) && ((tblgen_execution_scope.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(tblgen_execution_scope.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.GroupNonUniformSMax' op ""attribute 'execution_scope' failed to satisfy constraint: valid SPIR-V Scope");
  }
  {
    auto tblgen_group_operation = odsAttrs.get("group_operation");
    if (!tblgen_group_operation)
      return emitError(loc, "'spv.GroupNonUniformSMax' op ""requires attribute 'group_operation'");

    if (tblgen_group_operation && !((((tblgen_group_operation.isa<::mlir::IntegerAttr>())) && ((tblgen_group_operation.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeGroupOperation(tblgen_group_operation.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.GroupNonUniformSMax' op ""attribute 'group_operation' failed to satisfy constraint: valid SPIR-V GroupOperation");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GroupNonUniformSMaxOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range GroupNonUniformSMaxOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformSMaxOp::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value GroupNonUniformSMaxOp::cluster_size() {
  auto operands = getODSOperands(1);
  return operands.empty() ? ::mlir::Value() : *operands.begin();
}

::mlir::MutableOperandRange GroupNonUniformSMaxOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange GroupNonUniformSMaxOp::cluster_sizeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GroupNonUniformSMaxOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GroupNonUniformSMaxOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformSMaxOp::result() {
  return *getODSResults(0).begin();
}

::mlir::spirv::ScopeAttr GroupNonUniformSMaxOp::execution_scopeAttr() {
  return (*this)->getAttr(execution_scopeAttrName()).cast<::mlir::spirv::ScopeAttr>();
}

::mlir::spirv::Scope GroupNonUniformSMaxOp::execution_scope() {
  auto attr = execution_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::GroupOperationAttr GroupNonUniformSMaxOp::group_operationAttr() {
  return (*this)->getAttr(group_operationAttrName()).cast<::mlir::spirv::GroupOperationAttr>();
}

::mlir::spirv::GroupOperation GroupNonUniformSMaxOp::group_operation() {
  auto attr = group_operationAttr();
  return attr.getValue();
}

void GroupNonUniformSMaxOp::execution_scopeAttr(::mlir::spirv::ScopeAttr attr) {
  (*this)->setAttr(execution_scopeAttrName(), attr);
}

void GroupNonUniformSMaxOp::group_operationAttr(::mlir::spirv::GroupOperationAttr attr) {
  (*this)->setAttr(group_operationAttrName(), attr);
}

void GroupNonUniformSMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::spirv::ScopeAttr execution_scope, ::mlir::spirv::GroupOperationAttr group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);
  odsState.addAttribute(group_operationAttrName(odsState.name), group_operation);
  odsState.addTypes(result);
}

void GroupNonUniformSMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::ScopeAttr execution_scope, ::mlir::spirv::GroupOperationAttr group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);
  odsState.addAttribute(group_operationAttrName(odsState.name), group_operation);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GroupNonUniformSMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::spirv::Scope execution_scope, ::mlir::spirv::GroupOperation group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));
  odsState.addAttribute(group_operationAttrName(odsState.name), ::mlir::spirv::GroupOperationAttr::get(odsBuilder.getContext(), group_operation));
  odsState.addTypes(result);
}

void GroupNonUniformSMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::Scope execution_scope, ::mlir::spirv::GroupOperation group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));
  odsState.addAttribute(group_operationAttrName(odsState.name), ::mlir::spirv::GroupOperationAttr::get(odsBuilder.getContext(), group_operation));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GroupNonUniformSMaxOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult GroupNonUniformSMaxOp::verifyInvariantsImpl() {
  {
    auto tblgen_execution_scope = (*this)->getAttr(execution_scopeAttrName());
    if (!tblgen_execution_scope)
      return emitOpError("requires attribute 'execution_scope'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps1(*this, tblgen_execution_scope, "execution_scope")))
      return ::mlir::failure();
  }
  {
    auto tblgen_group_operation = (*this)->getAttr(group_operationAttrName());
    if (!tblgen_group_operation)
      return emitOpError("requires attribute 'group_operation'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps13(*this, tblgen_group_operation, "group_operation")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    if (valueGroup1.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup1.size();
    }

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GroupNonUniformSMaxOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GroupNonUniformSMaxOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GroupNonUniformSMinOp definitions
//===----------------------------------------------------------------------===//

GroupNonUniformSMinOpAdaptor::GroupNonUniformSMinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GroupNonUniformSMinOpAdaptor::GroupNonUniformSMinOpAdaptor(GroupNonUniformSMinOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GroupNonUniformSMinOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GroupNonUniformSMinOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange GroupNonUniformSMinOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformSMinOpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value GroupNonUniformSMinOpAdaptor::cluster_size() {
  auto operands = getODSOperands(1);
  return operands.empty() ? ::mlir::Value() : *operands.begin();
}

::mlir::DictionaryAttr GroupNonUniformSMinOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ScopeAttr GroupNonUniformSMinOpAdaptor::execution_scopeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ScopeAttr attr = odsAttrs.get("execution_scope").cast<::mlir::spirv::ScopeAttr>();
  return attr;
}

::mlir::spirv::Scope GroupNonUniformSMinOpAdaptor::execution_scope() {
  auto attr = execution_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::GroupOperationAttr GroupNonUniformSMinOpAdaptor::group_operationAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::GroupOperationAttr attr = odsAttrs.get("group_operation").cast<::mlir::spirv::GroupOperationAttr>();
  return attr;
}

::mlir::spirv::GroupOperation GroupNonUniformSMinOpAdaptor::group_operation() {
  auto attr = group_operationAttr();
  return attr.getValue();
}

::mlir::LogicalResult GroupNonUniformSMinOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_execution_scope = odsAttrs.get("execution_scope");
    if (!tblgen_execution_scope)
      return emitError(loc, "'spv.GroupNonUniformSMin' op ""requires attribute 'execution_scope'");

    if (tblgen_execution_scope && !((((tblgen_execution_scope.isa<::mlir::IntegerAttr>())) && ((tblgen_execution_scope.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(tblgen_execution_scope.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.GroupNonUniformSMin' op ""attribute 'execution_scope' failed to satisfy constraint: valid SPIR-V Scope");
  }
  {
    auto tblgen_group_operation = odsAttrs.get("group_operation");
    if (!tblgen_group_operation)
      return emitError(loc, "'spv.GroupNonUniformSMin' op ""requires attribute 'group_operation'");

    if (tblgen_group_operation && !((((tblgen_group_operation.isa<::mlir::IntegerAttr>())) && ((tblgen_group_operation.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeGroupOperation(tblgen_group_operation.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.GroupNonUniformSMin' op ""attribute 'group_operation' failed to satisfy constraint: valid SPIR-V GroupOperation");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GroupNonUniformSMinOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range GroupNonUniformSMinOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformSMinOp::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value GroupNonUniformSMinOp::cluster_size() {
  auto operands = getODSOperands(1);
  return operands.empty() ? ::mlir::Value() : *operands.begin();
}

::mlir::MutableOperandRange GroupNonUniformSMinOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange GroupNonUniformSMinOp::cluster_sizeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GroupNonUniformSMinOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GroupNonUniformSMinOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformSMinOp::result() {
  return *getODSResults(0).begin();
}

::mlir::spirv::ScopeAttr GroupNonUniformSMinOp::execution_scopeAttr() {
  return (*this)->getAttr(execution_scopeAttrName()).cast<::mlir::spirv::ScopeAttr>();
}

::mlir::spirv::Scope GroupNonUniformSMinOp::execution_scope() {
  auto attr = execution_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::GroupOperationAttr GroupNonUniformSMinOp::group_operationAttr() {
  return (*this)->getAttr(group_operationAttrName()).cast<::mlir::spirv::GroupOperationAttr>();
}

::mlir::spirv::GroupOperation GroupNonUniformSMinOp::group_operation() {
  auto attr = group_operationAttr();
  return attr.getValue();
}

void GroupNonUniformSMinOp::execution_scopeAttr(::mlir::spirv::ScopeAttr attr) {
  (*this)->setAttr(execution_scopeAttrName(), attr);
}

void GroupNonUniformSMinOp::group_operationAttr(::mlir::spirv::GroupOperationAttr attr) {
  (*this)->setAttr(group_operationAttrName(), attr);
}

void GroupNonUniformSMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::spirv::ScopeAttr execution_scope, ::mlir::spirv::GroupOperationAttr group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);
  odsState.addAttribute(group_operationAttrName(odsState.name), group_operation);
  odsState.addTypes(result);
}

void GroupNonUniformSMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::ScopeAttr execution_scope, ::mlir::spirv::GroupOperationAttr group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);
  odsState.addAttribute(group_operationAttrName(odsState.name), group_operation);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GroupNonUniformSMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::spirv::Scope execution_scope, ::mlir::spirv::GroupOperation group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));
  odsState.addAttribute(group_operationAttrName(odsState.name), ::mlir::spirv::GroupOperationAttr::get(odsBuilder.getContext(), group_operation));
  odsState.addTypes(result);
}

void GroupNonUniformSMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::Scope execution_scope, ::mlir::spirv::GroupOperation group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));
  odsState.addAttribute(group_operationAttrName(odsState.name), ::mlir::spirv::GroupOperationAttr::get(odsBuilder.getContext(), group_operation));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GroupNonUniformSMinOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult GroupNonUniformSMinOp::verifyInvariantsImpl() {
  {
    auto tblgen_execution_scope = (*this)->getAttr(execution_scopeAttrName());
    if (!tblgen_execution_scope)
      return emitOpError("requires attribute 'execution_scope'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps1(*this, tblgen_execution_scope, "execution_scope")))
      return ::mlir::failure();
  }
  {
    auto tblgen_group_operation = (*this)->getAttr(group_operationAttrName());
    if (!tblgen_group_operation)
      return emitOpError("requires attribute 'group_operation'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps13(*this, tblgen_group_operation, "group_operation")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    if (valueGroup1.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup1.size();
    }

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GroupNonUniformSMinOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GroupNonUniformSMinOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GroupNonUniformUMaxOp definitions
//===----------------------------------------------------------------------===//

GroupNonUniformUMaxOpAdaptor::GroupNonUniformUMaxOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GroupNonUniformUMaxOpAdaptor::GroupNonUniformUMaxOpAdaptor(GroupNonUniformUMaxOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GroupNonUniformUMaxOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GroupNonUniformUMaxOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange GroupNonUniformUMaxOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformUMaxOpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value GroupNonUniformUMaxOpAdaptor::cluster_size() {
  auto operands = getODSOperands(1);
  return operands.empty() ? ::mlir::Value() : *operands.begin();
}

::mlir::DictionaryAttr GroupNonUniformUMaxOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ScopeAttr GroupNonUniformUMaxOpAdaptor::execution_scopeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ScopeAttr attr = odsAttrs.get("execution_scope").cast<::mlir::spirv::ScopeAttr>();
  return attr;
}

::mlir::spirv::Scope GroupNonUniformUMaxOpAdaptor::execution_scope() {
  auto attr = execution_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::GroupOperationAttr GroupNonUniformUMaxOpAdaptor::group_operationAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::GroupOperationAttr attr = odsAttrs.get("group_operation").cast<::mlir::spirv::GroupOperationAttr>();
  return attr;
}

::mlir::spirv::GroupOperation GroupNonUniformUMaxOpAdaptor::group_operation() {
  auto attr = group_operationAttr();
  return attr.getValue();
}

::mlir::LogicalResult GroupNonUniformUMaxOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_execution_scope = odsAttrs.get("execution_scope");
    if (!tblgen_execution_scope)
      return emitError(loc, "'spv.GroupNonUniformUMax' op ""requires attribute 'execution_scope'");

    if (tblgen_execution_scope && !((((tblgen_execution_scope.isa<::mlir::IntegerAttr>())) && ((tblgen_execution_scope.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(tblgen_execution_scope.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.GroupNonUniformUMax' op ""attribute 'execution_scope' failed to satisfy constraint: valid SPIR-V Scope");
  }
  {
    auto tblgen_group_operation = odsAttrs.get("group_operation");
    if (!tblgen_group_operation)
      return emitError(loc, "'spv.GroupNonUniformUMax' op ""requires attribute 'group_operation'");

    if (tblgen_group_operation && !((((tblgen_group_operation.isa<::mlir::IntegerAttr>())) && ((tblgen_group_operation.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeGroupOperation(tblgen_group_operation.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.GroupNonUniformUMax' op ""attribute 'group_operation' failed to satisfy constraint: valid SPIR-V GroupOperation");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GroupNonUniformUMaxOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range GroupNonUniformUMaxOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformUMaxOp::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value GroupNonUniformUMaxOp::cluster_size() {
  auto operands = getODSOperands(1);
  return operands.empty() ? ::mlir::Value() : *operands.begin();
}

::mlir::MutableOperandRange GroupNonUniformUMaxOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange GroupNonUniformUMaxOp::cluster_sizeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GroupNonUniformUMaxOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GroupNonUniformUMaxOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformUMaxOp::result() {
  return *getODSResults(0).begin();
}

::mlir::spirv::ScopeAttr GroupNonUniformUMaxOp::execution_scopeAttr() {
  return (*this)->getAttr(execution_scopeAttrName()).cast<::mlir::spirv::ScopeAttr>();
}

::mlir::spirv::Scope GroupNonUniformUMaxOp::execution_scope() {
  auto attr = execution_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::GroupOperationAttr GroupNonUniformUMaxOp::group_operationAttr() {
  return (*this)->getAttr(group_operationAttrName()).cast<::mlir::spirv::GroupOperationAttr>();
}

::mlir::spirv::GroupOperation GroupNonUniformUMaxOp::group_operation() {
  auto attr = group_operationAttr();
  return attr.getValue();
}

void GroupNonUniformUMaxOp::execution_scopeAttr(::mlir::spirv::ScopeAttr attr) {
  (*this)->setAttr(execution_scopeAttrName(), attr);
}

void GroupNonUniformUMaxOp::group_operationAttr(::mlir::spirv::GroupOperationAttr attr) {
  (*this)->setAttr(group_operationAttrName(), attr);
}

void GroupNonUniformUMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::spirv::ScopeAttr execution_scope, ::mlir::spirv::GroupOperationAttr group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);
  odsState.addAttribute(group_operationAttrName(odsState.name), group_operation);
  odsState.addTypes(result);
}

void GroupNonUniformUMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::ScopeAttr execution_scope, ::mlir::spirv::GroupOperationAttr group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);
  odsState.addAttribute(group_operationAttrName(odsState.name), group_operation);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GroupNonUniformUMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::spirv::Scope execution_scope, ::mlir::spirv::GroupOperation group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));
  odsState.addAttribute(group_operationAttrName(odsState.name), ::mlir::spirv::GroupOperationAttr::get(odsBuilder.getContext(), group_operation));
  odsState.addTypes(result);
}

void GroupNonUniformUMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::Scope execution_scope, ::mlir::spirv::GroupOperation group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));
  odsState.addAttribute(group_operationAttrName(odsState.name), ::mlir::spirv::GroupOperationAttr::get(odsBuilder.getContext(), group_operation));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GroupNonUniformUMaxOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult GroupNonUniformUMaxOp::verifyInvariantsImpl() {
  {
    auto tblgen_execution_scope = (*this)->getAttr(execution_scopeAttrName());
    if (!tblgen_execution_scope)
      return emitOpError("requires attribute 'execution_scope'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps1(*this, tblgen_execution_scope, "execution_scope")))
      return ::mlir::failure();
  }
  {
    auto tblgen_group_operation = (*this)->getAttr(group_operationAttrName());
    if (!tblgen_group_operation)
      return emitOpError("requires attribute 'group_operation'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps13(*this, tblgen_group_operation, "group_operation")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    if (valueGroup1.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup1.size();
    }

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GroupNonUniformUMaxOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GroupNonUniformUMaxOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::GroupNonUniformUMinOp definitions
//===----------------------------------------------------------------------===//

GroupNonUniformUMinOpAdaptor::GroupNonUniformUMinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

GroupNonUniformUMinOpAdaptor::GroupNonUniformUMinOpAdaptor(GroupNonUniformUMinOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange GroupNonUniformUMinOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GroupNonUniformUMinOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange GroupNonUniformUMinOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformUMinOpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value GroupNonUniformUMinOpAdaptor::cluster_size() {
  auto operands = getODSOperands(1);
  return operands.empty() ? ::mlir::Value() : *operands.begin();
}

::mlir::DictionaryAttr GroupNonUniformUMinOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ScopeAttr GroupNonUniformUMinOpAdaptor::execution_scopeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ScopeAttr attr = odsAttrs.get("execution_scope").cast<::mlir::spirv::ScopeAttr>();
  return attr;
}

::mlir::spirv::Scope GroupNonUniformUMinOpAdaptor::execution_scope() {
  auto attr = execution_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::GroupOperationAttr GroupNonUniformUMinOpAdaptor::group_operationAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::GroupOperationAttr attr = odsAttrs.get("group_operation").cast<::mlir::spirv::GroupOperationAttr>();
  return attr;
}

::mlir::spirv::GroupOperation GroupNonUniformUMinOpAdaptor::group_operation() {
  auto attr = group_operationAttr();
  return attr.getValue();
}

::mlir::LogicalResult GroupNonUniformUMinOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_execution_scope = odsAttrs.get("execution_scope");
    if (!tblgen_execution_scope)
      return emitError(loc, "'spv.GroupNonUniformUMin' op ""requires attribute 'execution_scope'");

    if (tblgen_execution_scope && !((((tblgen_execution_scope.isa<::mlir::IntegerAttr>())) && ((tblgen_execution_scope.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(tblgen_execution_scope.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.GroupNonUniformUMin' op ""attribute 'execution_scope' failed to satisfy constraint: valid SPIR-V Scope");
  }
  {
    auto tblgen_group_operation = odsAttrs.get("group_operation");
    if (!tblgen_group_operation)
      return emitError(loc, "'spv.GroupNonUniformUMin' op ""requires attribute 'group_operation'");

    if (tblgen_group_operation && !((((tblgen_group_operation.isa<::mlir::IntegerAttr>())) && ((tblgen_group_operation.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeGroupOperation(tblgen_group_operation.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.GroupNonUniformUMin' op ""attribute 'group_operation' failed to satisfy constraint: valid SPIR-V GroupOperation");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GroupNonUniformUMinOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range GroupNonUniformUMinOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformUMinOp::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value GroupNonUniformUMinOp::cluster_size() {
  auto operands = getODSOperands(1);
  return operands.empty() ? ::mlir::Value() : *operands.begin();
}

::mlir::MutableOperandRange GroupNonUniformUMinOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange GroupNonUniformUMinOp::cluster_sizeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> GroupNonUniformUMinOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GroupNonUniformUMinOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GroupNonUniformUMinOp::result() {
  return *getODSResults(0).begin();
}

::mlir::spirv::ScopeAttr GroupNonUniformUMinOp::execution_scopeAttr() {
  return (*this)->getAttr(execution_scopeAttrName()).cast<::mlir::spirv::ScopeAttr>();
}

::mlir::spirv::Scope GroupNonUniformUMinOp::execution_scope() {
  auto attr = execution_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::GroupOperationAttr GroupNonUniformUMinOp::group_operationAttr() {
  return (*this)->getAttr(group_operationAttrName()).cast<::mlir::spirv::GroupOperationAttr>();
}

::mlir::spirv::GroupOperation GroupNonUniformUMinOp::group_operation() {
  auto attr = group_operationAttr();
  return attr.getValue();
}

void GroupNonUniformUMinOp::execution_scopeAttr(::mlir::spirv::ScopeAttr attr) {
  (*this)->setAttr(execution_scopeAttrName(), attr);
}

void GroupNonUniformUMinOp::group_operationAttr(::mlir::spirv::GroupOperationAttr attr) {
  (*this)->setAttr(group_operationAttrName(), attr);
}

void GroupNonUniformUMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::spirv::ScopeAttr execution_scope, ::mlir::spirv::GroupOperationAttr group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);
  odsState.addAttribute(group_operationAttrName(odsState.name), group_operation);
  odsState.addTypes(result);
}

void GroupNonUniformUMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::ScopeAttr execution_scope, ::mlir::spirv::GroupOperationAttr group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), execution_scope);
  odsState.addAttribute(group_operationAttrName(odsState.name), group_operation);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GroupNonUniformUMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::spirv::Scope execution_scope, ::mlir::spirv::GroupOperation group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));
  odsState.addAttribute(group_operationAttrName(odsState.name), ::mlir::spirv::GroupOperationAttr::get(odsBuilder.getContext(), group_operation));
  odsState.addTypes(result);
}

void GroupNonUniformUMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::Scope execution_scope, ::mlir::spirv::GroupOperation group_operation, ::mlir::Value value, /*optional*/::mlir::Value cluster_size) {
  odsState.addOperands(value);
  if (cluster_size)
    odsState.addOperands(cluster_size);
  odsState.addAttribute(execution_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), execution_scope));
  odsState.addAttribute(group_operationAttrName(odsState.name), ::mlir::spirv::GroupOperationAttr::get(odsBuilder.getContext(), group_operation));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GroupNonUniformUMinOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult GroupNonUniformUMinOp::verifyInvariantsImpl() {
  {
    auto tblgen_execution_scope = (*this)->getAttr(execution_scopeAttrName());
    if (!tblgen_execution_scope)
      return emitOpError("requires attribute 'execution_scope'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps1(*this, tblgen_execution_scope, "execution_scope")))
      return ::mlir::failure();
  }
  {
    auto tblgen_group_operation = (*this)->getAttr(group_operationAttrName());
    if (!tblgen_group_operation)
      return emitOpError("requires attribute 'group_operation'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps13(*this, tblgen_group_operation, "group_operation")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    if (valueGroup1.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup1.size();
    }

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult GroupNonUniformUMinOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::GroupNonUniformUMinOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::IAddOp definitions
//===----------------------------------------------------------------------===//

IAddOpAdaptor::IAddOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

IAddOpAdaptor::IAddOpAdaptor(IAddOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange IAddOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> IAddOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange IAddOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IAddOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value IAddOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr IAddOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult IAddOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> IAddOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range IAddOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IAddOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value IAddOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange IAddOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange IAddOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> IAddOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range IAddOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IAddOp::result() {
  return *getODSResults(0).begin();
}

void IAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void IAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void IAddOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void IAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes({operand1.getType()});

}

void IAddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult IAddOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps10(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps10(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps10(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult IAddOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult IAddOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(resultTypes), ::llvm::ArrayRef<::mlir::Type>(resultTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void IAddOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void IAddOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::IAddOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::IEqualOp definitions
//===----------------------------------------------------------------------===//

IEqualOpAdaptor::IEqualOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

IEqualOpAdaptor::IEqualOpAdaptor(IEqualOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange IEqualOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> IEqualOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange IEqualOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IEqualOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value IEqualOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr IEqualOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult IEqualOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> IEqualOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range IEqualOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IEqualOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value IEqualOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange IEqualOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange IEqualOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> IEqualOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range IEqualOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IEqualOp::result() {
  return *getODSResults(0).begin();
}

void IEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value lhs, Value rhs) {
::buildLogicalBinaryOp(odsBuilder, odsState, lhs, rhs);
}

void IEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void IEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void IEqualOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult IEqualOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(getUnaryOpResultType((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of result to correspond to the `i1` equivalent of the operand");
  return ::mlir::success();
}

::mlir::LogicalResult IEqualOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult IEqualOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operand1RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand1Operands(operand1RawOperands);  ::llvm::SMLoc operand1OperandsLoc;
  (void)operand1OperandsLoc;
  ::mlir::OpAsmParser::OperandType operand2RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand2Operands(operand2RawOperands);  ::llvm::SMLoc operand2OperandsLoc;
  (void)operand2OperandsLoc;
  ::mlir::Type operand1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand1Types(operand1RawTypes);

  operand1OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand1RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  operand2OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand2RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand1RawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  for (::mlir::Type type : operand1Types) {
    (void)type;
    if (!((((type.isInteger(8))) || ((type.isInteger(16))) || ((type.isInteger(32))) || ((type.isInteger(64)))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isInteger(8))) || ((elementType.isInteger(16))) || ((elementType.isInteger(32))) || ((elementType.isInteger(64))); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
      return parser.emitError(parser.getNameLoc()) << "'operand1' must be 8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(getUnaryOpResultType(operand1Types[0]));
  if (parser.resolveOperands(operand1Operands, operand1Types, operand1OperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(operand2Operands, operand1Types[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void IEqualOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand1();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << operand2();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand1().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void IEqualOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::IEqualOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::IMulOp definitions
//===----------------------------------------------------------------------===//

IMulOpAdaptor::IMulOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

IMulOpAdaptor::IMulOpAdaptor(IMulOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange IMulOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> IMulOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange IMulOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IMulOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value IMulOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr IMulOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult IMulOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> IMulOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range IMulOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IMulOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value IMulOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange IMulOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange IMulOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> IMulOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range IMulOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IMulOp::result() {
  return *getODSResults(0).begin();
}

void IMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void IMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void IMulOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void IMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes({operand1.getType()});

}

void IMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult IMulOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps10(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps10(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps10(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult IMulOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult IMulOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(resultTypes), ::llvm::ArrayRef<::mlir::Type>(resultTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void IMulOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void IMulOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::IMulOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::INotEqualOp definitions
//===----------------------------------------------------------------------===//

INotEqualOpAdaptor::INotEqualOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

INotEqualOpAdaptor::INotEqualOpAdaptor(INotEqualOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange INotEqualOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> INotEqualOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange INotEqualOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value INotEqualOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value INotEqualOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr INotEqualOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult INotEqualOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> INotEqualOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range INotEqualOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value INotEqualOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value INotEqualOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange INotEqualOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange INotEqualOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> INotEqualOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range INotEqualOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value INotEqualOp::result() {
  return *getODSResults(0).begin();
}

void INotEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value lhs, Value rhs) {
::buildLogicalBinaryOp(odsBuilder, odsState, lhs, rhs);
}

void INotEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void INotEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void INotEqualOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult INotEqualOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(getUnaryOpResultType((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of result to correspond to the `i1` equivalent of the operand");
  return ::mlir::success();
}

::mlir::LogicalResult INotEqualOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult INotEqualOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operand1RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand1Operands(operand1RawOperands);  ::llvm::SMLoc operand1OperandsLoc;
  (void)operand1OperandsLoc;
  ::mlir::OpAsmParser::OperandType operand2RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand2Operands(operand2RawOperands);  ::llvm::SMLoc operand2OperandsLoc;
  (void)operand2OperandsLoc;
  ::mlir::Type operand1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand1Types(operand1RawTypes);

  operand1OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand1RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  operand2OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand2RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand1RawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  for (::mlir::Type type : operand1Types) {
    (void)type;
    if (!((((type.isInteger(8))) || ((type.isInteger(16))) || ((type.isInteger(32))) || ((type.isInteger(64)))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isInteger(8))) || ((elementType.isInteger(16))) || ((elementType.isInteger(32))) || ((elementType.isInteger(64))); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
      return parser.emitError(parser.getNameLoc()) << "'operand1' must be 8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(getUnaryOpResultType(operand1Types[0]));
  if (parser.resolveOperands(operand1Operands, operand1Types, operand1OperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(operand2Operands, operand1Types[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void INotEqualOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand1();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << operand2();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand1().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void INotEqualOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::INotEqualOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::ISubOp definitions
//===----------------------------------------------------------------------===//

ISubOpAdaptor::ISubOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

ISubOpAdaptor::ISubOpAdaptor(ISubOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange ISubOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ISubOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ISubOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ISubOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value ISubOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr ISubOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult ISubOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> ISubOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ISubOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ISubOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value ISubOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange ISubOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange ISubOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> ISubOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ISubOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ISubOp::result() {
  return *getODSResults(0).begin();
}

void ISubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void ISubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ISubOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void ISubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes({operand1.getType()});

}

void ISubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult ISubOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps10(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps10(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps10(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult ISubOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult ISubOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(resultTypes), ::llvm::ArrayRef<::mlir::Type>(resultTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ISubOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void ISubOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::ISubOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::ImageDrefGatherOp definitions
//===----------------------------------------------------------------------===//

ImageDrefGatherOpAdaptor::ImageDrefGatherOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

ImageDrefGatherOpAdaptor::ImageDrefGatherOpAdaptor(ImageDrefGatherOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange ImageDrefGatherOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ImageDrefGatherOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, false, false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 3) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange ImageDrefGatherOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ImageDrefGatherOpAdaptor::sampledimage() {
  return *getODSOperands(0).begin();
}

::mlir::Value ImageDrefGatherOpAdaptor::coordinate() {
  return *getODSOperands(1).begin();
}

::mlir::Value ImageDrefGatherOpAdaptor::dref() {
  return *getODSOperands(2).begin();
}

::mlir::ValueRange ImageDrefGatherOpAdaptor::operand_arguments() {
  return getODSOperands(3);
}

::mlir::DictionaryAttr ImageDrefGatherOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ImageOperandsAttr ImageDrefGatherOpAdaptor::imageoperandsAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ImageOperandsAttr attr = odsAttrs.get("imageoperands").dyn_cast_or_null<::mlir::spirv::ImageOperandsAttr>();
  return attr;
}

::llvm::Optional<::mlir::spirv::ImageOperands> ImageDrefGatherOpAdaptor::imageoperands() {
  auto attr = imageoperandsAttr();
  return attr ? ::llvm::Optional<::mlir::spirv::ImageOperands>(attr.getValue()) : (::llvm::None);
}

::mlir::LogicalResult ImageDrefGatherOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_imageoperands = odsAttrs.get("imageoperands");
    if (tblgen_imageoperands && !((((tblgen_imageoperands.isa<::mlir::IntegerAttr>())) && ((tblgen_imageoperands.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeImageOperands(tblgen_imageoperands.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.ImageDrefGather' op ""attribute 'imageoperands' failed to satisfy constraint: valid SPIR-V ImageOperands");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> ImageDrefGatherOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, false, false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 3) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range ImageDrefGatherOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ImageDrefGatherOp::sampledimage() {
  return *getODSOperands(0).begin();
}

::mlir::Value ImageDrefGatherOp::coordinate() {
  return *getODSOperands(1).begin();
}

::mlir::Value ImageDrefGatherOp::dref() {
  return *getODSOperands(2).begin();
}

::mlir::Operation::operand_range ImageDrefGatherOp::operand_arguments() {
  return getODSOperands(3);
}

::mlir::MutableOperandRange ImageDrefGatherOp::sampledimageMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange ImageDrefGatherOp::coordinateMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange ImageDrefGatherOp::drefMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange ImageDrefGatherOp::operand_argumentsMutable() {
  auto range = getODSOperandIndexAndLength(3);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> ImageDrefGatherOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ImageDrefGatherOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ImageDrefGatherOp::result() {
  return *getODSResults(0).begin();
}

::mlir::spirv::ImageOperandsAttr ImageDrefGatherOp::imageoperandsAttr() {
  return (*this)->getAttr(imageoperandsAttrName()).dyn_cast_or_null<::mlir::spirv::ImageOperandsAttr>();
}

::llvm::Optional<::mlir::spirv::ImageOperands> ImageDrefGatherOp::imageoperands() {
  auto attr = imageoperandsAttr();
  return attr ? ::llvm::Optional<::mlir::spirv::ImageOperands>(attr.getValue()) : (::llvm::None);
}

void ImageDrefGatherOp::imageoperandsAttr(::mlir::spirv::ImageOperandsAttr attr) {
  (*this)->setAttr(imageoperandsAttrName(), attr);
}

::mlir::Attribute ImageDrefGatherOp::removeImageoperandsAttr() {
  return (*this)->removeAttr(imageoperandsAttrName());
}

void ImageDrefGatherOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value sampledimage, ::mlir::Value coordinate, ::mlir::Value dref, /*optional*/::mlir::spirv::ImageOperandsAttr imageoperands, ::mlir::ValueRange operand_arguments) {
  odsState.addOperands(sampledimage);
  odsState.addOperands(coordinate);
  odsState.addOperands(dref);
  odsState.addOperands(operand_arguments);
  if (imageoperands) {
  odsState.addAttribute(imageoperandsAttrName(odsState.name), imageoperands);
  }
  odsState.addTypes(result);
}

void ImageDrefGatherOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value sampledimage, ::mlir::Value coordinate, ::mlir::Value dref, /*optional*/::mlir::spirv::ImageOperandsAttr imageoperands, ::mlir::ValueRange operand_arguments) {
  odsState.addOperands(sampledimage);
  odsState.addOperands(coordinate);
  odsState.addOperands(dref);
  odsState.addOperands(operand_arguments);
  if (imageoperands) {
  odsState.addAttribute(imageoperandsAttrName(odsState.name), imageoperands);
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ImageDrefGatherOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ImageDrefGatherOp::verifyInvariantsImpl() {
  {
    auto tblgen_imageoperands = (*this)->getAttr(imageoperandsAttrName());
    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps14(*this, tblgen_imageoperands, "imageoperands")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps20(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps7(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps21(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult ImageDrefGatherOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult ImageDrefGatherOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType sampledimageRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> sampledimageOperands(sampledimageRawOperands);  ::llvm::SMLoc sampledimageOperandsLoc;
  (void)sampledimageOperandsLoc;
  ::mlir::Type sampledimageRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> sampledimageTypes(sampledimageRawTypes);
  ::mlir::OpAsmParser::OperandType coordinateRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> coordinateOperands(coordinateRawOperands);  ::llvm::SMLoc coordinateOperandsLoc;
  (void)coordinateOperandsLoc;
  ::mlir::Type coordinateRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> coordinateTypes(coordinateRawTypes);
  ::mlir::OpAsmParser::OperandType drefRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> drefOperands(drefRawOperands);  ::llvm::SMLoc drefOperandsLoc;
  (void)drefOperandsLoc;
  ::mlir::Type drefRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> drefTypes(drefRawTypes);
  ::mlir::spirv::ImageOperandsAttr imageoperandsAttr;
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> operand_argumentsOperands;
  ::llvm::SMLoc operand_argumentsOperandsLoc;
  (void)operand_argumentsOperandsLoc;
  ::mlir::SmallVector<::mlir::Type, 1> operand_argumentsTypes;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  sampledimageOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(sampledimageRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    sampledimageRawTypes[0] = type;
  }
  if (parser.parseComma())
    return ::mlir::failure();

  coordinateOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(coordinateRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    coordinateRawTypes[0] = type;
  }
  if (parser.parseComma())
    return ::mlir::failure();

  drefOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(drefRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    drefRawTypes[0] = type;
  }
  {
    if (parseImageOperands(parser, imageoperandsAttr))
      return ::mlir::failure();
    if (imageoperandsAttr)
      result.addAttribute("imageoperands", imageoperandsAttr);
  }
  if (succeeded(parser.parseOptionalLParen())) {

  operand_argumentsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(operand_argumentsOperands))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(operand_argumentsTypes))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::VectorType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(sampledimageOperands, sampledimageTypes, sampledimageOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(coordinateOperands, coordinateTypes, coordinateOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(drefOperands, drefTypes, drefOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(operand_argumentsOperands, operand_argumentsTypes, operand_argumentsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ImageDrefGatherOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << sampledimage();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = sampledimage().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << coordinate();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = coordinate().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << dref();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = dref().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ';
  printImageOperands(_odsPrinter, *this, imageoperandsAttr());
  if (!operand_arguments().empty()) {
  _odsPrinter << "(";
  _odsPrinter << operand_arguments();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << operand_arguments().getTypes();
  _odsPrinter << ")";
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"imageoperands"});
  _odsPrinter << ' ' << "->";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::VectorType>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void ImageDrefGatherOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::ImageDrefGatherOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::ImageOp definitions
//===----------------------------------------------------------------------===//

ImageOpAdaptor::ImageOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

ImageOpAdaptor::ImageOpAdaptor(ImageOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange ImageOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ImageOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ImageOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ImageOpAdaptor::sampledimage() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr ImageOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult ImageOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> ImageOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ImageOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ImageOp::sampledimage() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ImageOp::sampledimageMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> ImageOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ImageOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ImageOp::result() {
  return *getODSResults(0).begin();
}

void ImageOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value sampledimage) {
  odsState.addOperands(sampledimage);
  odsState.addTypes(result);
}

void ImageOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value sampledimage) {
  odsState.addOperands(sampledimage);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ImageOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ImageOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps20(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps22(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()((*this->getODSOperands(0).begin()).getType().cast<spirv::SampledImageType>().getImageType(), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of 'result' matches image type of 'sampledimage'");
  return ::mlir::success();
}

::mlir::LogicalResult ImageOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult ImageOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType sampledimageRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> sampledimageOperands(sampledimageRawOperands);  ::llvm::SMLoc sampledimageOperandsLoc;
  (void)sampledimageOperandsLoc;
  ::mlir::Type sampledimageRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> sampledimageTypes(sampledimageRawTypes);
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();

  sampledimageOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(sampledimageRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    sampledimageRawTypes[0] = type;
  }
  for (::mlir::Type type : sampledimageTypes) {
    (void)type;
    if (!((type.isa<::mlir::spirv::SampledImageType>()))) {
      return parser.emitError(parser.getNameLoc()) << "'sampledimage' must be any SPIR-V sampled image type, but got " << type;
    }
  }
  result.addTypes(sampledimageTypes[0].cast<spirv::SampledImageType>().getImageType());
  if (parser.resolveOperands(sampledimageOperands, sampledimageTypes, sampledimageOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ImageOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ';
  _odsPrinter << sampledimage();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = sampledimage().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void ImageOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::ImageOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::ImageQuerySizeOp definitions
//===----------------------------------------------------------------------===//

ImageQuerySizeOpAdaptor::ImageQuerySizeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

ImageQuerySizeOpAdaptor::ImageQuerySizeOpAdaptor(ImageQuerySizeOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange ImageQuerySizeOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ImageQuerySizeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ImageQuerySizeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ImageQuerySizeOpAdaptor::image() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr ImageQuerySizeOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult ImageQuerySizeOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> ImageQuerySizeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ImageQuerySizeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ImageQuerySizeOp::image() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ImageQuerySizeOp::imageMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> ImageQuerySizeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ImageQuerySizeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ImageQuerySizeOp::result() {
  return *getODSResults(0).begin();
}

void ImageQuerySizeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value image) {
  odsState.addOperands(image);
  odsState.addTypes(result);
}

void ImageQuerySizeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value image) {
  odsState.addOperands(image);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ImageQuerySizeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ImageQuerySizeOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps22(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult ImageQuerySizeOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult ImageQuerySizeOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType imageRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> imageOperands(imageRawOperands);  ::llvm::SMLoc imageOperandsLoc;
  (void)imageOperandsLoc;
  ::mlir::Type imageRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> imageTypes(imageRawTypes);
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();

  imageOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(imageRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    imageRawTypes[0] = type;
  }
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(imageOperands, imageTypes, imageOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ImageQuerySizeOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ';
  _odsPrinter << image();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = image().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ' << "->";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void ImageQuerySizeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::ImageQuerySizeOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::InBoundsPtrAccessChainOp definitions
//===----------------------------------------------------------------------===//

InBoundsPtrAccessChainOpAdaptor::InBoundsPtrAccessChainOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

InBoundsPtrAccessChainOpAdaptor::InBoundsPtrAccessChainOpAdaptor(InBoundsPtrAccessChainOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange InBoundsPtrAccessChainOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> InBoundsPtrAccessChainOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 2) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange InBoundsPtrAccessChainOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value InBoundsPtrAccessChainOpAdaptor::base_ptr() {
  return *getODSOperands(0).begin();
}

::mlir::Value InBoundsPtrAccessChainOpAdaptor::element() {
  return *getODSOperands(1).begin();
}

::mlir::ValueRange InBoundsPtrAccessChainOpAdaptor::indices() {
  return getODSOperands(2);
}

::mlir::DictionaryAttr InBoundsPtrAccessChainOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult InBoundsPtrAccessChainOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> InBoundsPtrAccessChainOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 2) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range InBoundsPtrAccessChainOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value InBoundsPtrAccessChainOp::base_ptr() {
  return *getODSOperands(0).begin();
}

::mlir::Value InBoundsPtrAccessChainOp::element() {
  return *getODSOperands(1).begin();
}

::mlir::Operation::operand_range InBoundsPtrAccessChainOp::indices() {
  return getODSOperands(2);
}

::mlir::MutableOperandRange InBoundsPtrAccessChainOp::base_ptrMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange InBoundsPtrAccessChainOp::elementMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange InBoundsPtrAccessChainOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> InBoundsPtrAccessChainOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range InBoundsPtrAccessChainOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value InBoundsPtrAccessChainOp::result() {
  return *getODSResults(0).begin();
}

void InBoundsPtrAccessChainOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value base_ptr, ::mlir::Value element, ::mlir::ValueRange indices) {
  odsState.addOperands(base_ptr);
  odsState.addOperands(element);
  odsState.addOperands(indices);
  odsState.addTypes(result);
}

void InBoundsPtrAccessChainOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value base_ptr, ::mlir::Value element, ::mlir::ValueRange indices) {
  odsState.addOperands(base_ptr);
  odsState.addOperands(element);
  odsState.addOperands(indices);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void InBoundsPtrAccessChainOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult InBoundsPtrAccessChainOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps0(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps0(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult InBoundsPtrAccessChainOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

void InBoundsPtrAccessChainOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::InBoundsPtrAccessChainOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::IsInfOp definitions
//===----------------------------------------------------------------------===//

IsInfOpAdaptor::IsInfOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

IsInfOpAdaptor::IsInfOpAdaptor(IsInfOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange IsInfOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> IsInfOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange IsInfOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IsInfOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr IsInfOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult IsInfOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> IsInfOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range IsInfOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IsInfOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange IsInfOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> IsInfOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range IsInfOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IsInfOp::result() {
  return *getODSResults(0).begin();
}

void IsInfOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value value) {
::buildLogicalUnaryOp(odsBuilder, odsState, value);
}

void IsInfOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void IsInfOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void IsInfOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult IsInfOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(getUnaryOpResultType((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of result to correspond to the `i1` equivalent of the operand");
  return ::mlir::success();
}

::mlir::LogicalResult IsInfOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult IsInfOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  for (::mlir::Type type : operandTypes) {
    (void)type;
    if (!((((type.isF16())) || ((type.isF32())) || ((type.isF64()))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isF16())) || ((elementType.isF32())) || ((elementType.isF64())); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
      return parser.emitError(parser.getNameLoc()) << "'operand' must be 16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(getUnaryOpResultType(operandTypes[0]));
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void IsInfOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void IsInfOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::IsInfOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::IsNanOp definitions
//===----------------------------------------------------------------------===//

IsNanOpAdaptor::IsNanOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

IsNanOpAdaptor::IsNanOpAdaptor(IsNanOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange IsNanOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> IsNanOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange IsNanOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IsNanOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr IsNanOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult IsNanOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> IsNanOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range IsNanOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IsNanOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange IsNanOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> IsNanOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range IsNanOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IsNanOp::result() {
  return *getODSResults(0).begin();
}

void IsNanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value value) {
::buildLogicalUnaryOp(odsBuilder, odsState, value);
}

void IsNanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void IsNanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void IsNanOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult IsNanOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(getUnaryOpResultType((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of result to correspond to the `i1` equivalent of the operand");
  return ::mlir::success();
}

::mlir::LogicalResult IsNanOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult IsNanOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  for (::mlir::Type type : operandTypes) {
    (void)type;
    if (!((((type.isF16())) || ((type.isF32())) || ((type.isF64()))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isF16())) || ((elementType.isF32())) || ((elementType.isF64())); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
      return parser.emitError(parser.getNameLoc()) << "'operand' must be 16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(getUnaryOpResultType(operandTypes[0]));
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void IsNanOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void IsNanOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::IsNanOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::LoadOp definitions
//===----------------------------------------------------------------------===//

LoadOpAdaptor::LoadOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

LoadOpAdaptor::LoadOpAdaptor(LoadOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange LoadOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> LoadOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange LoadOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LoadOpAdaptor::ptr() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr LoadOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::MemoryAccessAttr LoadOpAdaptor::memory_accessAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::MemoryAccessAttr attr = odsAttrs.get("memory_access").dyn_cast_or_null<::mlir::spirv::MemoryAccessAttr>();
  return attr;
}

::llvm::Optional<::mlir::spirv::MemoryAccess> LoadOpAdaptor::memory_access() {
  auto attr = memory_accessAttr();
  return attr ? ::llvm::Optional<::mlir::spirv::MemoryAccess>(attr.getValue()) : (::llvm::None);
}

::mlir::IntegerAttr LoadOpAdaptor::alignmentAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("alignment").dyn_cast_or_null<::mlir::IntegerAttr>();
  return attr;
}

::llvm::Optional<uint32_t> LoadOpAdaptor::alignment() {
  auto attr = alignmentAttr();
  return attr ? ::llvm::Optional<uint32_t>(attr.getValue().getZExtValue()) : (::llvm::None);
}

::mlir::LogicalResult LoadOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_memory_access = odsAttrs.get("memory_access");
    if (tblgen_memory_access && !((((tblgen_memory_access.isa<::mlir::IntegerAttr>())) && ((tblgen_memory_access.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemoryAccess(tblgen_memory_access.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.Load' op ""attribute 'memory_access' failed to satisfy constraint: valid SPIR-V MemoryAccess");
  }
  {
    auto tblgen_alignment = odsAttrs.get("alignment");
    if (tblgen_alignment && !(((tblgen_alignment.isa<::mlir::IntegerAttr>())) && ((tblgen_alignment.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))))
      return emitError(loc, "'spv.Load' op ""attribute 'alignment' failed to satisfy constraint: 32-bit signless integer attribute");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> LoadOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LoadOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LoadOp::ptr() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange LoadOp::ptrMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> LoadOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LoadOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LoadOp::value() {
  return *getODSResults(0).begin();
}

::mlir::spirv::MemoryAccessAttr LoadOp::memory_accessAttr() {
  return (*this)->getAttr(memory_accessAttrName()).dyn_cast_or_null<::mlir::spirv::MemoryAccessAttr>();
}

::llvm::Optional<::mlir::spirv::MemoryAccess> LoadOp::memory_access() {
  auto attr = memory_accessAttr();
  return attr ? ::llvm::Optional<::mlir::spirv::MemoryAccess>(attr.getValue()) : (::llvm::None);
}

::mlir::IntegerAttr LoadOp::alignmentAttr() {
  return (*this)->getAttr(alignmentAttrName()).dyn_cast_or_null<::mlir::IntegerAttr>();
}

::llvm::Optional<uint32_t> LoadOp::alignment() {
  auto attr = alignmentAttr();
  return attr ? ::llvm::Optional<uint32_t>(attr.getValue().getZExtValue()) : (::llvm::None);
}

void LoadOp::memory_accessAttr(::mlir::spirv::MemoryAccessAttr attr) {
  (*this)->setAttr(memory_accessAttrName(), attr);
}

void LoadOp::alignmentAttr(::mlir::IntegerAttr attr) {
  (*this)->setAttr(alignmentAttrName(), attr);
}

::mlir::Attribute LoadOp::removeMemory_accessAttr() {
  return (*this)->removeAttr(memory_accessAttrName());
}

::mlir::Attribute LoadOp::removeAlignmentAttr() {
  return (*this)->removeAttr(alignmentAttrName());
}

void LoadOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type value, ::mlir::Value ptr, /*optional*/::mlir::spirv::MemoryAccessAttr memory_access, /*optional*/::mlir::IntegerAttr alignment) {
  odsState.addOperands(ptr);
  if (memory_access) {
  odsState.addAttribute(memory_accessAttrName(odsState.name), memory_access);
  }
  if (alignment) {
  odsState.addAttribute(alignmentAttrName(odsState.name), alignment);
  }
  odsState.addTypes(value);
}

void LoadOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value ptr, /*optional*/::mlir::spirv::MemoryAccessAttr memory_access, /*optional*/::mlir::IntegerAttr alignment) {
  odsState.addOperands(ptr);
  if (memory_access) {
  odsState.addAttribute(memory_accessAttrName(odsState.name), memory_access);
  }
  if (alignment) {
  odsState.addAttribute(alignmentAttrName(odsState.name), alignment);
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LoadOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult LoadOp::verifyInvariantsImpl() {
  {
    auto tblgen_memory_access = (*this)->getAttr(memory_accessAttrName());
    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps6(*this, tblgen_memory_access, "memory_access")))
      return ::mlir::failure();
  }
  {
    auto tblgen_alignment = (*this)->getAttr(alignmentAttrName());
    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps7(*this, tblgen_alignment, "alignment")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps0(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps7(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult LoadOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::LoadOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::LogicalAndOp definitions
//===----------------------------------------------------------------------===//

LogicalAndOpAdaptor::LogicalAndOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

LogicalAndOpAdaptor::LogicalAndOpAdaptor(LogicalAndOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange LogicalAndOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> LogicalAndOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange LogicalAndOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogicalAndOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value LogicalAndOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr LogicalAndOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult LogicalAndOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> LogicalAndOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LogicalAndOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogicalAndOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value LogicalAndOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange LogicalAndOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange LogicalAndOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> LogicalAndOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LogicalAndOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogicalAndOp::result() {
  return *getODSResults(0).begin();
}

void LogicalAndOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value lhs, Value rhs) {
::buildLogicalBinaryOp(odsBuilder, odsState, lhs, rhs);
}

void LogicalAndOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void LogicalAndOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LogicalAndOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult LogicalAndOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(getUnaryOpResultType((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of result to correspond to the `i1` equivalent of the operand");
  return ::mlir::success();
}

::mlir::LogicalResult LogicalAndOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult LogicalAndOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operand1RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand1Operands(operand1RawOperands);  ::llvm::SMLoc operand1OperandsLoc;
  (void)operand1OperandsLoc;
  ::mlir::OpAsmParser::OperandType operand2RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand2Operands(operand2RawOperands);  ::llvm::SMLoc operand2OperandsLoc;
  (void)operand2OperandsLoc;
  ::mlir::Type operand1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand1Types(operand1RawTypes);

  operand1OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand1RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  operand2OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand2RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand1RawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  for (::mlir::Type type : operand1Types) {
    (void)type;
    if (!(((type.isSignlessInteger(1))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return (elementType.isSignlessInteger(1)); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
      return parser.emitError(parser.getNameLoc()) << "'operand1' must be bool or vector of bool values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(getUnaryOpResultType(operand1Types[0]));
  if (parser.resolveOperands(operand1Operands, operand1Types, operand1OperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(operand2Operands, operand1Types[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void LogicalAndOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand1();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << operand2();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand1().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void LogicalAndOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::LogicalAndOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::LogicalEqualOp definitions
//===----------------------------------------------------------------------===//

LogicalEqualOpAdaptor::LogicalEqualOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

LogicalEqualOpAdaptor::LogicalEqualOpAdaptor(LogicalEqualOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange LogicalEqualOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> LogicalEqualOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange LogicalEqualOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogicalEqualOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value LogicalEqualOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr LogicalEqualOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult LogicalEqualOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> LogicalEqualOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LogicalEqualOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogicalEqualOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value LogicalEqualOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange LogicalEqualOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange LogicalEqualOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> LogicalEqualOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LogicalEqualOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogicalEqualOp::result() {
  return *getODSResults(0).begin();
}

void LogicalEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value lhs, Value rhs) {
::buildLogicalBinaryOp(odsBuilder, odsState, lhs, rhs);
}

void LogicalEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void LogicalEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LogicalEqualOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult LogicalEqualOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(getUnaryOpResultType((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of result to correspond to the `i1` equivalent of the operand");
  return ::mlir::success();
}

::mlir::LogicalResult LogicalEqualOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult LogicalEqualOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operand1RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand1Operands(operand1RawOperands);  ::llvm::SMLoc operand1OperandsLoc;
  (void)operand1OperandsLoc;
  ::mlir::OpAsmParser::OperandType operand2RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand2Operands(operand2RawOperands);  ::llvm::SMLoc operand2OperandsLoc;
  (void)operand2OperandsLoc;
  ::mlir::Type operand1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand1Types(operand1RawTypes);

  operand1OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand1RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  operand2OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand2RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand1RawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  for (::mlir::Type type : operand1Types) {
    (void)type;
    if (!(((type.isSignlessInteger(1))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return (elementType.isSignlessInteger(1)); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
      return parser.emitError(parser.getNameLoc()) << "'operand1' must be bool or vector of bool values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(getUnaryOpResultType(operand1Types[0]));
  if (parser.resolveOperands(operand1Operands, operand1Types, operand1OperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(operand2Operands, operand1Types[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void LogicalEqualOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand1();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << operand2();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand1().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void LogicalEqualOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::LogicalEqualOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::LogicalNotEqualOp definitions
//===----------------------------------------------------------------------===//

LogicalNotEqualOpAdaptor::LogicalNotEqualOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

LogicalNotEqualOpAdaptor::LogicalNotEqualOpAdaptor(LogicalNotEqualOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange LogicalNotEqualOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> LogicalNotEqualOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange LogicalNotEqualOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogicalNotEqualOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value LogicalNotEqualOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr LogicalNotEqualOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult LogicalNotEqualOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> LogicalNotEqualOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LogicalNotEqualOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogicalNotEqualOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value LogicalNotEqualOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange LogicalNotEqualOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange LogicalNotEqualOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> LogicalNotEqualOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LogicalNotEqualOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogicalNotEqualOp::result() {
  return *getODSResults(0).begin();
}

void LogicalNotEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value lhs, Value rhs) {
::buildLogicalBinaryOp(odsBuilder, odsState, lhs, rhs);
}

void LogicalNotEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void LogicalNotEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LogicalNotEqualOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult LogicalNotEqualOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(getUnaryOpResultType((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of result to correspond to the `i1` equivalent of the operand");
  return ::mlir::success();
}

::mlir::LogicalResult LogicalNotEqualOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult LogicalNotEqualOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operand1RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand1Operands(operand1RawOperands);  ::llvm::SMLoc operand1OperandsLoc;
  (void)operand1OperandsLoc;
  ::mlir::OpAsmParser::OperandType operand2RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand2Operands(operand2RawOperands);  ::llvm::SMLoc operand2OperandsLoc;
  (void)operand2OperandsLoc;
  ::mlir::Type operand1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand1Types(operand1RawTypes);

  operand1OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand1RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  operand2OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand2RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand1RawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  for (::mlir::Type type : operand1Types) {
    (void)type;
    if (!(((type.isSignlessInteger(1))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return (elementType.isSignlessInteger(1)); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
      return parser.emitError(parser.getNameLoc()) << "'operand1' must be bool or vector of bool values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(getUnaryOpResultType(operand1Types[0]));
  if (parser.resolveOperands(operand1Operands, operand1Types, operand1OperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(operand2Operands, operand1Types[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void LogicalNotEqualOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand1();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << operand2();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand1().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void LogicalNotEqualOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::LogicalNotEqualOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::LogicalNotOp definitions
//===----------------------------------------------------------------------===//

LogicalNotOpAdaptor::LogicalNotOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

LogicalNotOpAdaptor::LogicalNotOpAdaptor(LogicalNotOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange LogicalNotOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> LogicalNotOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange LogicalNotOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogicalNotOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr LogicalNotOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult LogicalNotOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> LogicalNotOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LogicalNotOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogicalNotOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange LogicalNotOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> LogicalNotOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LogicalNotOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogicalNotOp::result() {
  return *getODSResults(0).begin();
}

void LogicalNotOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value value) {
::buildLogicalUnaryOp(odsBuilder, odsState, value);
}

void LogicalNotOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void LogicalNotOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LogicalNotOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult LogicalNotOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(getUnaryOpResultType((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of result to correspond to the `i1` equivalent of the operand");
  return ::mlir::success();
}

::mlir::LogicalResult LogicalNotOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult LogicalNotOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  for (::mlir::Type type : operandTypes) {
    (void)type;
    if (!(((type.isSignlessInteger(1))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return (elementType.isSignlessInteger(1)); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
      return parser.emitError(parser.getNameLoc()) << "'operand' must be bool or vector of bool values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(getUnaryOpResultType(operandTypes[0]));
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void LogicalNotOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void LogicalNotOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::LogicalNotOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::LogicalOrOp definitions
//===----------------------------------------------------------------------===//

LogicalOrOpAdaptor::LogicalOrOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

LogicalOrOpAdaptor::LogicalOrOpAdaptor(LogicalOrOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange LogicalOrOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> LogicalOrOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange LogicalOrOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogicalOrOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value LogicalOrOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr LogicalOrOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult LogicalOrOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> LogicalOrOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LogicalOrOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogicalOrOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value LogicalOrOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange LogicalOrOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange LogicalOrOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> LogicalOrOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LogicalOrOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogicalOrOp::result() {
  return *getODSResults(0).begin();
}

void LogicalOrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value lhs, Value rhs) {
::buildLogicalBinaryOp(odsBuilder, odsState, lhs, rhs);
}

void LogicalOrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void LogicalOrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LogicalOrOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult LogicalOrOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(getUnaryOpResultType((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of result to correspond to the `i1` equivalent of the operand");
  return ::mlir::success();
}

::mlir::LogicalResult LogicalOrOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult LogicalOrOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operand1RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand1Operands(operand1RawOperands);  ::llvm::SMLoc operand1OperandsLoc;
  (void)operand1OperandsLoc;
  ::mlir::OpAsmParser::OperandType operand2RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand2Operands(operand2RawOperands);  ::llvm::SMLoc operand2OperandsLoc;
  (void)operand2OperandsLoc;
  ::mlir::Type operand1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand1Types(operand1RawTypes);

  operand1OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand1RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  operand2OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand2RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand1RawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  for (::mlir::Type type : operand1Types) {
    (void)type;
    if (!(((type.isSignlessInteger(1))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return (elementType.isSignlessInteger(1)); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
      return parser.emitError(parser.getNameLoc()) << "'operand1' must be bool or vector of bool values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(getUnaryOpResultType(operand1Types[0]));
  if (parser.resolveOperands(operand1Operands, operand1Types, operand1OperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(operand2Operands, operand1Types[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void LogicalOrOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand1();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << operand2();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand1().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void LogicalOrOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::LogicalOrOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::LoopOp definitions
//===----------------------------------------------------------------------===//

LoopOpAdaptor::LoopOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

LoopOpAdaptor::LoopOpAdaptor(LoopOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange LoopOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> LoopOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange LoopOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr LoopOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::LoopControlAttr LoopOpAdaptor::loop_controlAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::LoopControlAttr attr = odsAttrs.get("loop_control").cast<::mlir::spirv::LoopControlAttr>();
  return attr;
}

::mlir::spirv::LoopControl LoopOpAdaptor::loop_control() {
  auto attr = loop_controlAttr();
  return attr.getValue();
}

::mlir::RegionRange LoopOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &LoopOpAdaptor::body() {
  return *odsRegions[0];
}

::mlir::LogicalResult LoopOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_loop_control = odsAttrs.get("loop_control");
    if (!tblgen_loop_control)
      return emitError(loc, "'spv.mlir.loop' op ""requires attribute 'loop_control'");

    if (tblgen_loop_control && !((((tblgen_loop_control.isa<::mlir::IntegerAttr>())) && ((tblgen_loop_control.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeLoopControl(tblgen_loop_control.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.mlir.loop' op ""attribute 'loop_control' failed to satisfy constraint: valid SPIR-V LoopControl");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> LoopOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LoopOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> LoopOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LoopOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Region &LoopOp::body() {
  return (*this)->getRegion(0);
}

::mlir::spirv::LoopControlAttr LoopOp::loop_controlAttr() {
  return (*this)->getAttr(loop_controlAttrName()).cast<::mlir::spirv::LoopControlAttr>();
}

::mlir::spirv::LoopControl LoopOp::loop_control() {
  auto attr = loop_controlAttr();
  return attr.getValue();
}

void LoopOp::loop_controlAttr(::mlir::spirv::LoopControlAttr attr) {
  (*this)->setAttr(loop_controlAttrName(), attr);
}

void LoopOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::spirv::LoopControlAttr loop_control) {
  odsState.addAttribute(loop_controlAttrName(odsState.name), loop_control);
  (void)odsState.addRegion();
}

void LoopOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::LoopControlAttr loop_control) {
  odsState.addAttribute(loop_controlAttrName(odsState.name), loop_control);
  (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LoopOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::spirv::LoopControl loop_control) {
  odsState.addAttribute(loop_controlAttrName(odsState.name), ::mlir::spirv::LoopControlAttr::get(odsBuilder.getContext(), loop_control));
  (void)odsState.addRegion();
}

void LoopOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::LoopControl loop_control) {
  odsState.addAttribute(loop_controlAttrName(odsState.name), ::mlir::spirv::LoopControlAttr::get(odsBuilder.getContext(), loop_control));
  (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LoopOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 1; ++i)
    (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult LoopOp::verifyInvariantsImpl() {
  {
    auto tblgen_loop_control = (*this)->getAttr(loop_controlAttrName());
    if (!tblgen_loop_control)
      return emitOpError("requires attribute 'loop_control'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps15(*this, tblgen_loop_control, "loop_control")))
      return ::mlir::failure();
  }
  if (!((isNestedInFunctionOpInterface((*this->getOperation()).getParentOp()))))
    return emitOpError("failed to verify that op must appear in a function-like op's block");
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::makeMutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_SPIRVOps0(*this, region, "body", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::LogicalResult LoopOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::LoopOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::MatrixTimesMatrixOp definitions
//===----------------------------------------------------------------------===//

MatrixTimesMatrixOpAdaptor::MatrixTimesMatrixOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

MatrixTimesMatrixOpAdaptor::MatrixTimesMatrixOpAdaptor(MatrixTimesMatrixOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange MatrixTimesMatrixOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> MatrixTimesMatrixOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MatrixTimesMatrixOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixTimesMatrixOpAdaptor::leftmatrix() {
  return *getODSOperands(0).begin();
}

::mlir::Value MatrixTimesMatrixOpAdaptor::rightmatrix() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr MatrixTimesMatrixOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult MatrixTimesMatrixOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> MatrixTimesMatrixOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MatrixTimesMatrixOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixTimesMatrixOp::leftmatrix() {
  return *getODSOperands(0).begin();
}

::mlir::Value MatrixTimesMatrixOp::rightmatrix() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange MatrixTimesMatrixOp::leftmatrixMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange MatrixTimesMatrixOp::rightmatrixMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> MatrixTimesMatrixOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MatrixTimesMatrixOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixTimesMatrixOp::result() {
  return *getODSResults(0).begin();
}

void MatrixTimesMatrixOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value leftmatrix, ::mlir::Value rightmatrix) {
  odsState.addOperands(leftmatrix);
  odsState.addOperands(rightmatrix);
  odsState.addTypes(result);
}

void MatrixTimesMatrixOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value leftmatrix, ::mlir::Value rightmatrix) {
  odsState.addOperands(leftmatrix);
  odsState.addOperands(rightmatrix);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MatrixTimesMatrixOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MatrixTimesMatrixOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps23(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps23(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps23(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult MatrixTimesMatrixOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult MatrixTimesMatrixOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type leftmatrixRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> leftmatrixTypes(leftmatrixRawTypes);
  ::mlir::Type rightmatrixRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> rightmatrixTypes(rightmatrixRawTypes);
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    leftmatrixRawTypes[0] = type;
  }
  if (parser.parseComma())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    rightmatrixRawTypes[0] = type;
  }
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(leftmatrixTypes), ::llvm::ArrayRef<::mlir::Type>(rightmatrixTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void MatrixTimesMatrixOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = leftmatrix().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';
  {
    auto type = rightmatrix().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ' << "->";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void MatrixTimesMatrixOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::MatrixTimesMatrixOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::MatrixTimesScalarOp definitions
//===----------------------------------------------------------------------===//

MatrixTimesScalarOpAdaptor::MatrixTimesScalarOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

MatrixTimesScalarOpAdaptor::MatrixTimesScalarOpAdaptor(MatrixTimesScalarOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange MatrixTimesScalarOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> MatrixTimesScalarOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MatrixTimesScalarOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixTimesScalarOpAdaptor::matrix() {
  return *getODSOperands(0).begin();
}

::mlir::Value MatrixTimesScalarOpAdaptor::scalar() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr MatrixTimesScalarOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult MatrixTimesScalarOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> MatrixTimesScalarOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MatrixTimesScalarOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixTimesScalarOp::matrix() {
  return *getODSOperands(0).begin();
}

::mlir::Value MatrixTimesScalarOp::scalar() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange MatrixTimesScalarOp::matrixMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange MatrixTimesScalarOp::scalarMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> MatrixTimesScalarOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MatrixTimesScalarOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatrixTimesScalarOp::result() {
  return *getODSResults(0).begin();
}

void MatrixTimesScalarOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value matrix, ::mlir::Value scalar) {
  odsState.addOperands(matrix);
  odsState.addOperands(scalar);
  odsState.addTypes(result);
}

void MatrixTimesScalarOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value matrix, ::mlir::Value scalar) {
  odsState.addOperands(matrix);
  odsState.addOperands(scalar);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MatrixTimesScalarOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MatrixTimesScalarOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps23(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps23(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult MatrixTimesScalarOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult MatrixTimesScalarOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type matrixRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> matrixTypes(matrixRawTypes);
  ::mlir::Type scalarRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> scalarTypes(scalarRawTypes);
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    matrixRawTypes[0] = type;
  }
  if (parser.parseComma())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    scalarRawTypes[0] = type;
  }
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(matrixTypes), ::llvm::ArrayRef<::mlir::Type>(scalarTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void MatrixTimesScalarOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = matrix().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';
  {
    auto type = scalar().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ' << "->";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void MatrixTimesScalarOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::MatrixTimesScalarOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::MemoryBarrierOp definitions
//===----------------------------------------------------------------------===//

MemoryBarrierOpAdaptor::MemoryBarrierOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

MemoryBarrierOpAdaptor::MemoryBarrierOpAdaptor(MemoryBarrierOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange MemoryBarrierOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> MemoryBarrierOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MemoryBarrierOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr MemoryBarrierOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::ScopeAttr MemoryBarrierOpAdaptor::memory_scopeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::ScopeAttr attr = odsAttrs.get("memory_scope").cast<::mlir::spirv::ScopeAttr>();
  return attr;
}

::mlir::spirv::Scope MemoryBarrierOpAdaptor::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr MemoryBarrierOpAdaptor::memory_semanticsAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::MemorySemanticsAttr attr = odsAttrs.get("memory_semantics").cast<::mlir::spirv::MemorySemanticsAttr>();
  return attr;
}

::mlir::spirv::MemorySemantics MemoryBarrierOpAdaptor::memory_semantics() {
  auto attr = memory_semanticsAttr();
  return attr.getValue();
}

::mlir::LogicalResult MemoryBarrierOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_memory_scope = odsAttrs.get("memory_scope");
    if (!tblgen_memory_scope)
      return emitError(loc, "'spv.MemoryBarrier' op ""requires attribute 'memory_scope'");

    if (tblgen_memory_scope && !((((tblgen_memory_scope.isa<::mlir::IntegerAttr>())) && ((tblgen_memory_scope.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeScope(tblgen_memory_scope.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.MemoryBarrier' op ""attribute 'memory_scope' failed to satisfy constraint: valid SPIR-V Scope");
  }
  {
    auto tblgen_memory_semantics = odsAttrs.get("memory_semantics");
    if (!tblgen_memory_semantics)
      return emitError(loc, "'spv.MemoryBarrier' op ""requires attribute 'memory_semantics'");

    if (tblgen_memory_semantics && !((((tblgen_memory_semantics.isa<::mlir::IntegerAttr>())) && ((tblgen_memory_semantics.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemorySemantics(tblgen_memory_semantics.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.MemoryBarrier' op ""attribute 'memory_semantics' failed to satisfy constraint: valid SPIR-V MemorySemantics");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> MemoryBarrierOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MemoryBarrierOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> MemoryBarrierOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MemoryBarrierOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::spirv::ScopeAttr MemoryBarrierOp::memory_scopeAttr() {
  return (*this)->getAttr(memory_scopeAttrName()).cast<::mlir::spirv::ScopeAttr>();
}

::mlir::spirv::Scope MemoryBarrierOp::memory_scope() {
  auto attr = memory_scopeAttr();
  return attr.getValue();
}

::mlir::spirv::MemorySemanticsAttr MemoryBarrierOp::memory_semanticsAttr() {
  return (*this)->getAttr(memory_semanticsAttrName()).cast<::mlir::spirv::MemorySemanticsAttr>();
}

::mlir::spirv::MemorySemantics MemoryBarrierOp::memory_semantics() {
  auto attr = memory_semanticsAttr();
  return attr.getValue();
}

void MemoryBarrierOp::memory_scopeAttr(::mlir::spirv::ScopeAttr attr) {
  (*this)->setAttr(memory_scopeAttrName(), attr);
}

void MemoryBarrierOp::memory_semanticsAttr(::mlir::spirv::MemorySemanticsAttr attr) {
  (*this)->setAttr(memory_semanticsAttrName(), attr);
}

void MemoryBarrierOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr memory_semantics) {
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(memory_semanticsAttrName(odsState.name), memory_semantics);
}

void MemoryBarrierOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::ScopeAttr memory_scope, ::mlir::spirv::MemorySemanticsAttr memory_semantics) {
  odsState.addAttribute(memory_scopeAttrName(odsState.name), memory_scope);
  odsState.addAttribute(memory_semanticsAttrName(odsState.name), memory_semantics);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MemoryBarrierOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics memory_semantics) {
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(memory_semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), memory_semantics));
}

void MemoryBarrierOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::Scope memory_scope, ::mlir::spirv::MemorySemantics memory_semantics) {
  odsState.addAttribute(memory_scopeAttrName(odsState.name), ::mlir::spirv::ScopeAttr::get(odsBuilder.getContext(), memory_scope));
  odsState.addAttribute(memory_semanticsAttrName(odsState.name), ::mlir::spirv::MemorySemanticsAttr::get(odsBuilder.getContext(), memory_semantics));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MemoryBarrierOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MemoryBarrierOp::verifyInvariantsImpl() {
  {
    auto tblgen_memory_scope = (*this)->getAttr(memory_scopeAttrName());
    if (!tblgen_memory_scope)
      return emitOpError("requires attribute 'memory_scope'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps1(*this, tblgen_memory_scope, "memory_scope")))
      return ::mlir::failure();
  }
  {
    auto tblgen_memory_semantics = (*this)->getAttr(memory_semanticsAttrName());
    if (!tblgen_memory_semantics)
      return emitOpError("requires attribute 'memory_semantics'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps2(*this, tblgen_memory_semantics, "memory_semantics")))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::LogicalResult MemoryBarrierOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult MemoryBarrierOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::spirv::ScopeAttr memory_scopeAttr;
  ::mlir::spirv::MemorySemanticsAttr memory_semanticsAttr;

  {
    ::llvm::StringRef attrStr;
    ::mlir::NamedAttrList attrStorage;
    auto loc = parser.getCurrentLocation();
    if (parser.parseOptionalKeyword(&attrStr, {"CrossDevice","Device","Workgroup","Subgroup","Invocation","QueueFamily","ShaderCallKHR"})) {
      ::mlir::StringAttr attrVal;
      ::mlir::OptionalParseResult parseResult =
        parser.parseOptionalAttribute(attrVal,
                                      parser.getBuilder().getNoneType(),
                                      "memory_scope", attrStorage);
      if (parseResult.hasValue()) {
        if (failed(*parseResult))
          return ::mlir::failure();
        attrStr = attrVal.getValue();
      } else {
        return parser.emitError(loc, "expected string or keyword containing one of the following enum values for attribute 'memory_scope' [CrossDevice, Device, Workgroup, Subgroup, Invocation, QueueFamily, ShaderCallKHR]");
      }
    }
    if (!attrStr.empty()) {
      auto attrOptional = ::mlir::spirv::symbolizeScope(attrStr);
      if (!attrOptional)
        return parser.emitError(loc, "invalid ")
               << "memory_scope attribute specification: \"" << attrStr << '"';;

      memory_scopeAttr = ::mlir::spirv::ScopeAttr::get(parser.getBuilder().getContext(), attrOptional.getValue());
      result.addAttribute("memory_scope", memory_scopeAttr);
    }
  }
  if (parser.parseComma())
    return ::mlir::failure();

  {
    ::llvm::StringRef attrStr;
    ::mlir::NamedAttrList attrStorage;
    auto loc = parser.getCurrentLocation();
    if (parser.parseOptionalKeyword(&attrStr, {"None","Acquire","Release","AcquireRelease","SequentiallyConsistent","UniformMemory","SubgroupMemory","WorkgroupMemory","CrossWorkgroupMemory","AtomicCounterMemory","ImageMemory","OutputMemory","MakeAvailable","MakeVisible","Volatile"})) {
      ::mlir::StringAttr attrVal;
      ::mlir::OptionalParseResult parseResult =
        parser.parseOptionalAttribute(attrVal,
                                      parser.getBuilder().getNoneType(),
                                      "memory_semantics", attrStorage);
      if (parseResult.hasValue()) {
        if (failed(*parseResult))
          return ::mlir::failure();
        attrStr = attrVal.getValue();
      } else {
        return parser.emitError(loc, "expected string or keyword containing one of the following enum values for attribute 'memory_semantics' [None, Acquire, Release, AcquireRelease, SequentiallyConsistent, UniformMemory, SubgroupMemory, WorkgroupMemory, CrossWorkgroupMemory, AtomicCounterMemory, ImageMemory, OutputMemory, MakeAvailable, MakeVisible, Volatile]");
      }
    }
    if (!attrStr.empty()) {
      auto attrOptional = ::mlir::spirv::symbolizeMemorySemantics(attrStr);
      if (!attrOptional)
        return parser.emitError(loc, "invalid ")
               << "memory_semantics attribute specification: \"" << attrStr << '"';;

      memory_semanticsAttr = ::mlir::spirv::MemorySemanticsAttr::get(parser.getBuilder().getContext(), attrOptional.getValue());
      result.addAttribute("memory_semantics", memory_semanticsAttr);
    }
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  return ::mlir::success();
}

void MemoryBarrierOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';

  {
    auto caseValue = memory_scope();
    auto caseValueStr = stringifyScope(caseValue);
    _odsPrinter << caseValueStr;
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';

  {
    auto caseValue = memory_semantics();
    auto caseValueStr = stringifyMemorySemantics(caseValue);
    switch (caseValue) {
    case ::mlir::spirv::MemorySemantics::Acquire:
    case ::mlir::spirv::MemorySemantics::Release:
    case ::mlir::spirv::MemorySemantics::AcquireRelease:
    case ::mlir::spirv::MemorySemantics::SequentiallyConsistent:
    case ::mlir::spirv::MemorySemantics::UniformMemory:
    case ::mlir::spirv::MemorySemantics::SubgroupMemory:
    case ::mlir::spirv::MemorySemantics::WorkgroupMemory:
    case ::mlir::spirv::MemorySemantics::CrossWorkgroupMemory:
    case ::mlir::spirv::MemorySemantics::AtomicCounterMemory:
    case ::mlir::spirv::MemorySemantics::ImageMemory:
    case ::mlir::spirv::MemorySemantics::OutputMemory:
    case ::mlir::spirv::MemorySemantics::MakeAvailable:
    case ::mlir::spirv::MemorySemantics::MakeVisible:
    case ::mlir::spirv::MemorySemantics::Volatile:
      _odsPrinter << caseValueStr;
      break;
    default:
      _odsPrinter << '"' << caseValueStr << '"';
      break;
    }
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"memory_scope", "memory_semantics"});
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::MemoryBarrierOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::MergeOp definitions
//===----------------------------------------------------------------------===//

MergeOpAdaptor::MergeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

MergeOpAdaptor::MergeOpAdaptor(MergeOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange MergeOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> MergeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MergeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr MergeOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult MergeOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> MergeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MergeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> MergeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MergeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void MergeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState) {
}

void MergeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes) {
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MergeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MergeOp::verifyInvariantsImpl() {
  return ::mlir::success();
}

::mlir::LogicalResult MergeOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult MergeOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  return ::mlir::success();
}

void MergeOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void MergeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::MergeOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::ModuleOp definitions
//===----------------------------------------------------------------------===//

ModuleOpAdaptor::ModuleOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

ModuleOpAdaptor::ModuleOpAdaptor(ModuleOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange ModuleOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ModuleOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ModuleOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr ModuleOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::AddressingModelAttr ModuleOpAdaptor::addressing_modelAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::AddressingModelAttr attr = odsAttrs.get("addressing_model").cast<::mlir::spirv::AddressingModelAttr>();
  return attr;
}

::mlir::spirv::AddressingModel ModuleOpAdaptor::addressing_model() {
  auto attr = addressing_modelAttr();
  return attr.getValue();
}

::mlir::spirv::MemoryModelAttr ModuleOpAdaptor::memory_modelAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::MemoryModelAttr attr = odsAttrs.get("memory_model").cast<::mlir::spirv::MemoryModelAttr>();
  return attr;
}

::mlir::spirv::MemoryModel ModuleOpAdaptor::memory_model() {
  auto attr = memory_modelAttr();
  return attr.getValue();
}

::mlir::spirv::VerCapExtAttr ModuleOpAdaptor::vce_tripleAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::VerCapExtAttr attr = odsAttrs.get("vce_triple").dyn_cast_or_null<::mlir::spirv::VerCapExtAttr>();
  return attr;
}

::llvm::Optional<::mlir::spirv::VerCapExtAttr> ModuleOpAdaptor::vce_triple() {
  auto attr = vce_tripleAttr();
  return attr ? ::llvm::Optional<::mlir::spirv::VerCapExtAttr>(attr) : (::llvm::None);
}

::mlir::StringAttr ModuleOpAdaptor::sym_nameAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("sym_name").dyn_cast_or_null<::mlir::StringAttr>();
  return attr;
}

::llvm::Optional< ::llvm::StringRef > ModuleOpAdaptor::sym_name() {
  auto attr = sym_nameAttr();
  return attr ? ::llvm::Optional< ::llvm::StringRef >(attr.getValue()) : (::llvm::None);
}

::mlir::RegionRange ModuleOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::LogicalResult ModuleOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_addressing_model = odsAttrs.get("addressing_model");
    if (!tblgen_addressing_model)
      return emitError(loc, "'spv.module' op ""requires attribute 'addressing_model'");

    if (tblgen_addressing_model && !((((tblgen_addressing_model.isa<::mlir::IntegerAttr>())) && ((tblgen_addressing_model.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeAddressingModel(tblgen_addressing_model.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.module' op ""attribute 'addressing_model' failed to satisfy constraint: valid SPIR-V AddressingModel");
  }
  {
    auto tblgen_memory_model = odsAttrs.get("memory_model");
    if (!tblgen_memory_model)
      return emitError(loc, "'spv.module' op ""requires attribute 'memory_model'");

    if (tblgen_memory_model && !((((tblgen_memory_model.isa<::mlir::IntegerAttr>())) && ((tblgen_memory_model.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemoryModel(tblgen_memory_model.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.module' op ""attribute 'memory_model' failed to satisfy constraint: valid SPIR-V MemoryModel");
  }
  {
    auto tblgen_vce_triple = odsAttrs.get("vce_triple");
    if (tblgen_vce_triple && !((tblgen_vce_triple.isa<::mlir::spirv::VerCapExtAttr>())))
      return emitError(loc, "'spv.module' op ""attribute 'vce_triple' failed to satisfy constraint: version-capability-extension attribute");
  }
  {
    auto tblgen_sym_name = odsAttrs.get("sym_name");
    if (tblgen_sym_name && !((tblgen_sym_name.isa<::mlir::StringAttr>())))
      return emitError(loc, "'spv.module' op ""attribute 'sym_name' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> ModuleOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ModuleOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> ModuleOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ModuleOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::spirv::AddressingModelAttr ModuleOp::addressing_modelAttr() {
  return (*this)->getAttr(addressing_modelAttrName()).cast<::mlir::spirv::AddressingModelAttr>();
}

::mlir::spirv::AddressingModel ModuleOp::addressing_model() {
  auto attr = addressing_modelAttr();
  return attr.getValue();
}

::mlir::spirv::MemoryModelAttr ModuleOp::memory_modelAttr() {
  return (*this)->getAttr(memory_modelAttrName()).cast<::mlir::spirv::MemoryModelAttr>();
}

::mlir::spirv::MemoryModel ModuleOp::memory_model() {
  auto attr = memory_modelAttr();
  return attr.getValue();
}

::mlir::spirv::VerCapExtAttr ModuleOp::vce_tripleAttr() {
  return (*this)->getAttr(vce_tripleAttrName()).dyn_cast_or_null<::mlir::spirv::VerCapExtAttr>();
}

::llvm::Optional<::mlir::spirv::VerCapExtAttr> ModuleOp::vce_triple() {
  auto attr = vce_tripleAttr();
  return attr ? ::llvm::Optional<::mlir::spirv::VerCapExtAttr>(attr) : (::llvm::None);
}

::mlir::StringAttr ModuleOp::sym_nameAttr() {
  return (*this)->getAttr(sym_nameAttrName()).dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::Optional< ::llvm::StringRef > ModuleOp::sym_name() {
  auto attr = sym_nameAttr();
  return attr ? ::llvm::Optional< ::llvm::StringRef >(attr.getValue()) : (::llvm::None);
}

void ModuleOp::addressing_modelAttr(::mlir::spirv::AddressingModelAttr attr) {
  (*this)->setAttr(addressing_modelAttrName(), attr);
}

void ModuleOp::memory_modelAttr(::mlir::spirv::MemoryModelAttr attr) {
  (*this)->setAttr(memory_modelAttrName(), attr);
}

void ModuleOp::vce_tripleAttr(::mlir::spirv::VerCapExtAttr attr) {
  (*this)->setAttr(vce_tripleAttrName(), attr);
}

void ModuleOp::sym_nameAttr(::mlir::StringAttr attr) {
  (*this)->setAttr(sym_nameAttrName(), attr);
}

::mlir::Attribute ModuleOp::removeVce_tripleAttr() {
  return (*this)->removeAttr(vce_tripleAttrName());
}

::mlir::Attribute ModuleOp::removeSym_nameAttr() {
  return (*this)->removeAttr(sym_nameAttrName());
}

::mlir::LogicalResult ModuleOp::verifyInvariantsImpl() {
  {
    auto tblgen_addressing_model = (*this)->getAttr(addressing_modelAttrName());
    if (!tblgen_addressing_model)
      return emitOpError("requires attribute 'addressing_model'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps16(*this, tblgen_addressing_model, "addressing_model")))
      return ::mlir::failure();
  }
  {
    auto tblgen_memory_model = (*this)->getAttr(memory_modelAttrName());
    if (!tblgen_memory_model)
      return emitOpError("requires attribute 'memory_model'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps17(*this, tblgen_memory_model, "memory_model")))
      return ::mlir::failure();
  }
  {
    auto tblgen_vce_triple = (*this)->getAttr(vce_tripleAttrName());
    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps18(*this, tblgen_vce_triple, "vce_triple")))
      return ::mlir::failure();
  }
  {
    auto tblgen_sym_name = (*this)->getAttr(sym_nameAttrName());
    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps11(*this, tblgen_sym_name, "sym_name")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::makeMutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_SPIRVOps0(*this, region, "", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::LogicalResult ModuleOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::ModuleOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::NotOp definitions
//===----------------------------------------------------------------------===//

NotOpAdaptor::NotOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

NotOpAdaptor::NotOpAdaptor(NotOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange NotOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> NotOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange NotOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value NotOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr NotOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult NotOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> NotOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range NotOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value NotOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange NotOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> NotOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range NotOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value NotOp::result() {
  return *getODSResults(0).begin();
}

void NotOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void NotOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void NotOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void NotOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void NotOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult NotOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult NotOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult NotOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void NotOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void NotOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::NotOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::OCLCeilOp definitions
//===----------------------------------------------------------------------===//

OCLCeilOpAdaptor::OCLCeilOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

OCLCeilOpAdaptor::OCLCeilOpAdaptor(OCLCeilOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange OCLCeilOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> OCLCeilOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange OCLCeilOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLCeilOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr OCLCeilOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult OCLCeilOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> OCLCeilOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range OCLCeilOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLCeilOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange OCLCeilOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> OCLCeilOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range OCLCeilOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLCeilOp::result() {
  return *getODSResults(0).begin();
}

void OCLCeilOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void OCLCeilOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void OCLCeilOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void OCLCeilOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void OCLCeilOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult OCLCeilOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult OCLCeilOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult OCLCeilOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void OCLCeilOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void OCLCeilOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::OCLCeilOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::OCLCosOp definitions
//===----------------------------------------------------------------------===//

OCLCosOpAdaptor::OCLCosOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

OCLCosOpAdaptor::OCLCosOpAdaptor(OCLCosOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange OCLCosOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> OCLCosOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange OCLCosOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLCosOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr OCLCosOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult OCLCosOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> OCLCosOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range OCLCosOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLCosOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange OCLCosOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> OCLCosOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range OCLCosOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLCosOp::result() {
  return *getODSResults(0).begin();
}

void OCLCosOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void OCLCosOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void OCLCosOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void OCLCosOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void OCLCosOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult OCLCosOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult OCLCosOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult OCLCosOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void OCLCosOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void OCLCosOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::OCLCosOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::OCLErfOp definitions
//===----------------------------------------------------------------------===//

OCLErfOpAdaptor::OCLErfOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

OCLErfOpAdaptor::OCLErfOpAdaptor(OCLErfOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange OCLErfOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> OCLErfOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange OCLErfOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLErfOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr OCLErfOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult OCLErfOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> OCLErfOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range OCLErfOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLErfOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange OCLErfOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> OCLErfOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range OCLErfOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLErfOp::result() {
  return *getODSResults(0).begin();
}

void OCLErfOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void OCLErfOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void OCLErfOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void OCLErfOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void OCLErfOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult OCLErfOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult OCLErfOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult OCLErfOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void OCLErfOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void OCLErfOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::OCLErfOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::OCLExpOp definitions
//===----------------------------------------------------------------------===//

OCLExpOpAdaptor::OCLExpOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

OCLExpOpAdaptor::OCLExpOpAdaptor(OCLExpOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange OCLExpOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> OCLExpOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange OCLExpOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLExpOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr OCLExpOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult OCLExpOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> OCLExpOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range OCLExpOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLExpOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange OCLExpOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> OCLExpOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range OCLExpOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLExpOp::result() {
  return *getODSResults(0).begin();
}

void OCLExpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void OCLExpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void OCLExpOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void OCLExpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void OCLExpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult OCLExpOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult OCLExpOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult OCLExpOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void OCLExpOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void OCLExpOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::OCLExpOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::OCLFAbsOp definitions
//===----------------------------------------------------------------------===//

OCLFAbsOpAdaptor::OCLFAbsOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

OCLFAbsOpAdaptor::OCLFAbsOpAdaptor(OCLFAbsOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange OCLFAbsOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> OCLFAbsOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange OCLFAbsOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLFAbsOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr OCLFAbsOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult OCLFAbsOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> OCLFAbsOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range OCLFAbsOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLFAbsOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange OCLFAbsOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> OCLFAbsOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range OCLFAbsOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLFAbsOp::result() {
  return *getODSResults(0).begin();
}

void OCLFAbsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void OCLFAbsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void OCLFAbsOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void OCLFAbsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void OCLFAbsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult OCLFAbsOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult OCLFAbsOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult OCLFAbsOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void OCLFAbsOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void OCLFAbsOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::OCLFAbsOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::OCLFloorOp definitions
//===----------------------------------------------------------------------===//

OCLFloorOpAdaptor::OCLFloorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

OCLFloorOpAdaptor::OCLFloorOpAdaptor(OCLFloorOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange OCLFloorOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> OCLFloorOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange OCLFloorOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLFloorOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr OCLFloorOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult OCLFloorOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> OCLFloorOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range OCLFloorOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLFloorOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange OCLFloorOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> OCLFloorOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range OCLFloorOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLFloorOp::result() {
  return *getODSResults(0).begin();
}

void OCLFloorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void OCLFloorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void OCLFloorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void OCLFloorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void OCLFloorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult OCLFloorOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult OCLFloorOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult OCLFloorOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void OCLFloorOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void OCLFloorOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::OCLFloorOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::OCLFmaOp definitions
//===----------------------------------------------------------------------===//

OCLFmaOpAdaptor::OCLFmaOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

OCLFmaOpAdaptor::OCLFmaOpAdaptor(OCLFmaOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange OCLFmaOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> OCLFmaOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange OCLFmaOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLFmaOpAdaptor::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value OCLFmaOpAdaptor::y() {
  return *getODSOperands(1).begin();
}

::mlir::Value OCLFmaOpAdaptor::z() {
  return *getODSOperands(2).begin();
}

::mlir::DictionaryAttr OCLFmaOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult OCLFmaOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> OCLFmaOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range OCLFmaOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLFmaOp::x() {
  return *getODSOperands(0).begin();
}

::mlir::Value OCLFmaOp::y() {
  return *getODSOperands(1).begin();
}

::mlir::Value OCLFmaOp::z() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange OCLFmaOp::xMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange OCLFmaOp::yMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange OCLFmaOp::zMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> OCLFmaOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range OCLFmaOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLFmaOp::result() {
  return *getODSResults(0).begin();
}

void OCLFmaOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value x, ::mlir::Value y, ::mlir::Value z) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addOperands(z);
  odsState.addTypes(result);
}

void OCLFmaOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value y, ::mlir::Value z) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addOperands(z);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void OCLFmaOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void OCLFmaOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x, ::mlir::Value y, ::mlir::Value z) {
  odsState.addOperands(x);
  odsState.addOperands(y);
  odsState.addOperands(z);
  odsState.addTypes({x.getType()});

}

void OCLFmaOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult OCLFmaOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult OCLFmaOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult OCLFmaOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(resultTypes), ::llvm::ArrayRef<::mlir::Type>(resultTypes), ::llvm::ArrayRef<::mlir::Type>(resultTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void OCLFmaOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void OCLFmaOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::OCLFmaOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::OCLLogOp definitions
//===----------------------------------------------------------------------===//

OCLLogOpAdaptor::OCLLogOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

OCLLogOpAdaptor::OCLLogOpAdaptor(OCLLogOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange OCLLogOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> OCLLogOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange OCLLogOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLLogOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr OCLLogOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult OCLLogOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> OCLLogOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range OCLLogOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLLogOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange OCLLogOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> OCLLogOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range OCLLogOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLLogOp::result() {
  return *getODSResults(0).begin();
}

void OCLLogOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void OCLLogOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void OCLLogOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void OCLLogOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void OCLLogOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult OCLLogOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult OCLLogOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult OCLLogOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void OCLLogOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void OCLLogOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::OCLLogOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::OCLPowOp definitions
//===----------------------------------------------------------------------===//

OCLPowOpAdaptor::OCLPowOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

OCLPowOpAdaptor::OCLPowOpAdaptor(OCLPowOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange OCLPowOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> OCLPowOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange OCLPowOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLPowOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value OCLPowOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr OCLPowOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult OCLPowOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> OCLPowOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range OCLPowOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLPowOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value OCLPowOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange OCLPowOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange OCLPowOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> OCLPowOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range OCLPowOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLPowOp::result() {
  return *getODSResults(0).begin();
}

void OCLPowOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void OCLPowOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void OCLPowOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void OCLPowOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes({lhs.getType()});

}

void OCLPowOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult OCLPowOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult OCLPowOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult OCLPowOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(resultTypes), ::llvm::ArrayRef<::mlir::Type>(resultTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void OCLPowOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void OCLPowOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::OCLPowOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::OCLRsqrtOp definitions
//===----------------------------------------------------------------------===//

OCLRsqrtOpAdaptor::OCLRsqrtOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

OCLRsqrtOpAdaptor::OCLRsqrtOpAdaptor(OCLRsqrtOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange OCLRsqrtOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> OCLRsqrtOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange OCLRsqrtOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLRsqrtOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr OCLRsqrtOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult OCLRsqrtOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> OCLRsqrtOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range OCLRsqrtOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLRsqrtOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange OCLRsqrtOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> OCLRsqrtOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range OCLRsqrtOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLRsqrtOp::result() {
  return *getODSResults(0).begin();
}

void OCLRsqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void OCLRsqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void OCLRsqrtOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void OCLRsqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void OCLRsqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult OCLRsqrtOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult OCLRsqrtOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult OCLRsqrtOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void OCLRsqrtOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void OCLRsqrtOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::OCLRsqrtOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::OCLSAbsOp definitions
//===----------------------------------------------------------------------===//

OCLSAbsOpAdaptor::OCLSAbsOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

OCLSAbsOpAdaptor::OCLSAbsOpAdaptor(OCLSAbsOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange OCLSAbsOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> OCLSAbsOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange OCLSAbsOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLSAbsOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr OCLSAbsOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult OCLSAbsOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> OCLSAbsOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range OCLSAbsOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLSAbsOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange OCLSAbsOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> OCLSAbsOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range OCLSAbsOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLSAbsOp::result() {
  return *getODSResults(0).begin();
}

void OCLSAbsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void OCLSAbsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void OCLSAbsOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void OCLSAbsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void OCLSAbsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult OCLSAbsOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult OCLSAbsOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult OCLSAbsOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void OCLSAbsOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void OCLSAbsOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::OCLSAbsOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::OCLSinOp definitions
//===----------------------------------------------------------------------===//

OCLSinOpAdaptor::OCLSinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

OCLSinOpAdaptor::OCLSinOpAdaptor(OCLSinOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange OCLSinOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> OCLSinOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange OCLSinOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLSinOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr OCLSinOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult OCLSinOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> OCLSinOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range OCLSinOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLSinOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange OCLSinOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> OCLSinOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range OCLSinOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLSinOp::result() {
  return *getODSResults(0).begin();
}

void OCLSinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void OCLSinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void OCLSinOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void OCLSinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void OCLSinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult OCLSinOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult OCLSinOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult OCLSinOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void OCLSinOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void OCLSinOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::OCLSinOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::OCLSqrtOp definitions
//===----------------------------------------------------------------------===//

OCLSqrtOpAdaptor::OCLSqrtOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

OCLSqrtOpAdaptor::OCLSqrtOpAdaptor(OCLSqrtOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange OCLSqrtOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> OCLSqrtOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange OCLSqrtOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLSqrtOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr OCLSqrtOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult OCLSqrtOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> OCLSqrtOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range OCLSqrtOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLSqrtOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange OCLSqrtOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> OCLSqrtOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range OCLSqrtOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLSqrtOp::result() {
  return *getODSResults(0).begin();
}

void OCLSqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void OCLSqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void OCLSqrtOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void OCLSqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void OCLSqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult OCLSqrtOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult OCLSqrtOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult OCLSqrtOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void OCLSqrtOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void OCLSqrtOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::OCLSqrtOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::OCLTanhOp definitions
//===----------------------------------------------------------------------===//

OCLTanhOpAdaptor::OCLTanhOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

OCLTanhOpAdaptor::OCLTanhOpAdaptor(OCLTanhOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange OCLTanhOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> OCLTanhOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange OCLTanhOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLTanhOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr OCLTanhOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult OCLTanhOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> OCLTanhOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range OCLTanhOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLTanhOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange OCLTanhOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> OCLTanhOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range OCLTanhOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OCLTanhOp::result() {
  return *getODSResults(0).begin();
}

void OCLTanhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void OCLTanhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void OCLTanhOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void OCLTanhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void OCLTanhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult OCLTanhOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult OCLTanhOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult OCLTanhOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void OCLTanhOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void OCLTanhOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::OCLTanhOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::OrderedOp definitions
//===----------------------------------------------------------------------===//

OrderedOpAdaptor::OrderedOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

OrderedOpAdaptor::OrderedOpAdaptor(OrderedOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange OrderedOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> OrderedOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange OrderedOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OrderedOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value OrderedOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr OrderedOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult OrderedOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> OrderedOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range OrderedOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OrderedOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value OrderedOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange OrderedOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange OrderedOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> OrderedOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range OrderedOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OrderedOp::result() {
  return *getODSResults(0).begin();
}

void OrderedOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value lhs, Value rhs) {
::buildLogicalBinaryOp(odsBuilder, odsState, lhs, rhs);
}

void OrderedOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void OrderedOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void OrderedOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult OrderedOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(getUnaryOpResultType((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of result to correspond to the `i1` equivalent of the operand");
  return ::mlir::success();
}

::mlir::LogicalResult OrderedOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult OrderedOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operand1RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand1Operands(operand1RawOperands);  ::llvm::SMLoc operand1OperandsLoc;
  (void)operand1OperandsLoc;
  ::mlir::OpAsmParser::OperandType operand2RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand2Operands(operand2RawOperands);  ::llvm::SMLoc operand2OperandsLoc;
  (void)operand2OperandsLoc;
  ::mlir::Type operand1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand1Types(operand1RawTypes);

  operand1OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand1RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  operand2OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand2RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand1RawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  for (::mlir::Type type : operand1Types) {
    (void)type;
    if (!((((type.isF16())) || ((type.isF32())) || ((type.isF64()))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isF16())) || ((elementType.isF32())) || ((elementType.isF64())); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
      return parser.emitError(parser.getNameLoc()) << "'operand1' must be 16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(getUnaryOpResultType(operand1Types[0]));
  if (parser.resolveOperands(operand1Operands, operand1Types, operand1OperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(operand2Operands, operand1Types[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void OrderedOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand1();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << operand2();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand1().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void OrderedOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::OrderedOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::PtrAccessChainOp definitions
//===----------------------------------------------------------------------===//

PtrAccessChainOpAdaptor::PtrAccessChainOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

PtrAccessChainOpAdaptor::PtrAccessChainOpAdaptor(PtrAccessChainOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange PtrAccessChainOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> PtrAccessChainOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 2) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange PtrAccessChainOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PtrAccessChainOpAdaptor::base_ptr() {
  return *getODSOperands(0).begin();
}

::mlir::Value PtrAccessChainOpAdaptor::element() {
  return *getODSOperands(1).begin();
}

::mlir::ValueRange PtrAccessChainOpAdaptor::indices() {
  return getODSOperands(2);
}

::mlir::DictionaryAttr PtrAccessChainOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult PtrAccessChainOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> PtrAccessChainOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 2) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range PtrAccessChainOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PtrAccessChainOp::base_ptr() {
  return *getODSOperands(0).begin();
}

::mlir::Value PtrAccessChainOp::element() {
  return *getODSOperands(1).begin();
}

::mlir::Operation::operand_range PtrAccessChainOp::indices() {
  return getODSOperands(2);
}

::mlir::MutableOperandRange PtrAccessChainOp::base_ptrMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange PtrAccessChainOp::elementMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange PtrAccessChainOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> PtrAccessChainOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range PtrAccessChainOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PtrAccessChainOp::result() {
  return *getODSResults(0).begin();
}

void PtrAccessChainOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value base_ptr, ::mlir::Value element, ::mlir::ValueRange indices) {
  odsState.addOperands(base_ptr);
  odsState.addOperands(element);
  odsState.addOperands(indices);
  odsState.addTypes(result);
}

void PtrAccessChainOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value base_ptr, ::mlir::Value element, ::mlir::ValueRange indices) {
  odsState.addOperands(base_ptr);
  odsState.addOperands(element);
  odsState.addOperands(indices);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void PtrAccessChainOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult PtrAccessChainOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps0(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps0(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult PtrAccessChainOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

void PtrAccessChainOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::PtrAccessChainOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::ReferenceOfOp definitions
//===----------------------------------------------------------------------===//

ReferenceOfOpAdaptor::ReferenceOfOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

ReferenceOfOpAdaptor::ReferenceOfOpAdaptor(ReferenceOfOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange ReferenceOfOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ReferenceOfOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ReferenceOfOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr ReferenceOfOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::FlatSymbolRefAttr ReferenceOfOpAdaptor::spec_constAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FlatSymbolRefAttr attr = odsAttrs.get("spec_const").cast<::mlir::FlatSymbolRefAttr>();
  return attr;
}

::llvm::StringRef ReferenceOfOpAdaptor::spec_const() {
  auto attr = spec_constAttr();
  return attr.getValue();
}

::mlir::LogicalResult ReferenceOfOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_spec_const = odsAttrs.get("spec_const");
    if (!tblgen_spec_const)
      return emitError(loc, "'spv.mlir.referenceof' op ""requires attribute 'spec_const'");

    if (tblgen_spec_const && !((tblgen_spec_const.isa<::mlir::FlatSymbolRefAttr>())))
      return emitError(loc, "'spv.mlir.referenceof' op ""attribute 'spec_const' failed to satisfy constraint: flat symbol reference attribute");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> ReferenceOfOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ReferenceOfOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> ReferenceOfOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ReferenceOfOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReferenceOfOp::reference() {
  return *getODSResults(0).begin();
}

::mlir::FlatSymbolRefAttr ReferenceOfOp::spec_constAttr() {
  return (*this)->getAttr(spec_constAttrName()).cast<::mlir::FlatSymbolRefAttr>();
}

::llvm::StringRef ReferenceOfOp::spec_const() {
  auto attr = spec_constAttr();
  return attr.getValue();
}

void ReferenceOfOp::spec_constAttr(::mlir::FlatSymbolRefAttr attr) {
  (*this)->setAttr(spec_constAttrName(), attr);
}

void ReferenceOfOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type reference, ::mlir::FlatSymbolRefAttr spec_const) {
  odsState.addAttribute(spec_constAttrName(odsState.name), spec_const);
  odsState.addTypes(reference);
}

void ReferenceOfOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::FlatSymbolRefAttr spec_const) {
  odsState.addAttribute(spec_constAttrName(odsState.name), spec_const);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReferenceOfOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type reference, ::llvm::StringRef spec_const) {
  odsState.addAttribute(spec_constAttrName(odsState.name), ::mlir::SymbolRefAttr::get(odsBuilder.getContext(), spec_const));
  odsState.addTypes(reference);
}

void ReferenceOfOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef spec_const) {
  odsState.addAttribute(spec_constAttrName(odsState.name), ::mlir::SymbolRefAttr::get(odsBuilder.getContext(), spec_const));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReferenceOfOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ReferenceOfOp::verifyInvariantsImpl() {
  {
    auto tblgen_spec_const = (*this)->getAttr(spec_constAttrName());
    if (!tblgen_spec_const)
      return emitOpError("requires attribute 'spec_const'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps0(*this, tblgen_spec_const, "spec_const")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps7(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult ReferenceOfOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult ReferenceOfOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::FlatSymbolRefAttr spec_constAttr;
  ::mlir::Type referenceRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> referenceTypes(referenceRawTypes);

  if (parser.parseCustomAttributeWithFallback(spec_constAttr, parser.getBuilder().getType<::mlir::NoneType>(), "spec_const",
          result.attributes)) {
    return ::mlir::failure();
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    referenceRawTypes[0] = type;
  }
  result.addTypes(referenceTypes);
  return ::mlir::success();
}

void ReferenceOfOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter.printAttributeWithoutType(spec_constAttr());
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"spec_const"});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = reference().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void ReferenceOfOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::ReferenceOfOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::ReturnOp definitions
//===----------------------------------------------------------------------===//

ReturnOpAdaptor::ReturnOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

ReturnOpAdaptor::ReturnOpAdaptor(ReturnOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange ReturnOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ReturnOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ReturnOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr ReturnOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult ReturnOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> ReturnOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ReturnOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> ReturnOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ReturnOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void ReturnOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState) {
}

void ReturnOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes) {
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReturnOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ReturnOp::verifyInvariantsImpl() {
  if (!((isNestedInFunctionOpInterface((*this->getOperation()).getParentOp()))))
    return emitOpError("failed to verify that op must appear in a function-like op's block");
  return ::mlir::success();
}

::mlir::LogicalResult ReturnOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult ReturnOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  return ::mlir::success();
}

void ReturnOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void ReturnOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::ReturnOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::ReturnValueOp definitions
//===----------------------------------------------------------------------===//

ReturnValueOpAdaptor::ReturnValueOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

ReturnValueOpAdaptor::ReturnValueOpAdaptor(ReturnValueOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange ReturnValueOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ReturnValueOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ReturnValueOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReturnValueOpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr ReturnValueOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult ReturnValueOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> ReturnValueOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ReturnValueOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReturnValueOp::value() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ReturnValueOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> ReturnValueOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ReturnValueOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void ReturnValueOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value value) {
  odsState.addOperands(value);
}

void ReturnValueOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value value) {
  odsState.addOperands(value);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReturnValueOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ReturnValueOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps7(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  if (!((isNestedInFunctionOpInterface((*this->getOperation()).getParentOp()))))
    return emitOpError("failed to verify that op must appear in a function-like op's block");
  return ::mlir::success();
}

::mlir::LogicalResult ReturnValueOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult ReturnValueOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType valueRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> valueOperands(valueRawOperands);  ::llvm::SMLoc valueOperandsLoc;
  (void)valueOperandsLoc;
  ::mlir::Type valueRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> valueTypes(valueRawTypes);

  valueOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(valueRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    valueRawTypes[0] = type;
  }
  if (parser.resolveOperands(valueOperands, valueTypes, valueOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ReturnValueOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << value();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = value().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void ReturnValueOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::ReturnValueOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::SConvertOp definitions
//===----------------------------------------------------------------------===//

SConvertOpAdaptor::SConvertOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

SConvertOpAdaptor::SConvertOpAdaptor(SConvertOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange SConvertOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SConvertOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SConvertOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SConvertOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr SConvertOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult SConvertOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> SConvertOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SConvertOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SConvertOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange SConvertOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> SConvertOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SConvertOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SConvertOp::result() {
  return *getODSResults(0).begin();
}

void SConvertOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void SConvertOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SConvertOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SConvertOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps10(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps10(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult SConvertOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult SConvertOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseKeyword("to"))
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void SConvertOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ' << "to";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void SConvertOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::SConvertOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::SDivOp definitions
//===----------------------------------------------------------------------===//

SDivOpAdaptor::SDivOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

SDivOpAdaptor::SDivOpAdaptor(SDivOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange SDivOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SDivOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SDivOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SDivOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value SDivOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr SDivOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult SDivOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> SDivOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SDivOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SDivOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value SDivOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SDivOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange SDivOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> SDivOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SDivOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SDivOp::result() {
  return *getODSResults(0).begin();
}

void SDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void SDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SDivOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void SDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes({operand1.getType()});

}

void SDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult SDivOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps10(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps10(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps10(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult SDivOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult SDivOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(resultTypes), ::llvm::ArrayRef<::mlir::Type>(resultTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void SDivOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void SDivOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::SDivOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::SGreaterThanEqualOp definitions
//===----------------------------------------------------------------------===//

SGreaterThanEqualOpAdaptor::SGreaterThanEqualOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

SGreaterThanEqualOpAdaptor::SGreaterThanEqualOpAdaptor(SGreaterThanEqualOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange SGreaterThanEqualOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SGreaterThanEqualOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SGreaterThanEqualOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SGreaterThanEqualOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value SGreaterThanEqualOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr SGreaterThanEqualOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult SGreaterThanEqualOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> SGreaterThanEqualOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SGreaterThanEqualOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SGreaterThanEqualOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value SGreaterThanEqualOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SGreaterThanEqualOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange SGreaterThanEqualOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> SGreaterThanEqualOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SGreaterThanEqualOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SGreaterThanEqualOp::result() {
  return *getODSResults(0).begin();
}

void SGreaterThanEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value lhs, Value rhs) {
::buildLogicalBinaryOp(odsBuilder, odsState, lhs, rhs);
}

void SGreaterThanEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void SGreaterThanEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SGreaterThanEqualOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SGreaterThanEqualOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(getUnaryOpResultType((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of result to correspond to the `i1` equivalent of the operand");
  return ::mlir::success();
}

::mlir::LogicalResult SGreaterThanEqualOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult SGreaterThanEqualOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operand1RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand1Operands(operand1RawOperands);  ::llvm::SMLoc operand1OperandsLoc;
  (void)operand1OperandsLoc;
  ::mlir::OpAsmParser::OperandType operand2RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand2Operands(operand2RawOperands);  ::llvm::SMLoc operand2OperandsLoc;
  (void)operand2OperandsLoc;
  ::mlir::Type operand1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand1Types(operand1RawTypes);

  operand1OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand1RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  operand2OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand2RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand1RawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  for (::mlir::Type type : operand1Types) {
    (void)type;
    if (!((((type.isInteger(8))) || ((type.isInteger(16))) || ((type.isInteger(32))) || ((type.isInteger(64)))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isInteger(8))) || ((elementType.isInteger(16))) || ((elementType.isInteger(32))) || ((elementType.isInteger(64))); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
      return parser.emitError(parser.getNameLoc()) << "'operand1' must be 8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(getUnaryOpResultType(operand1Types[0]));
  if (parser.resolveOperands(operand1Operands, operand1Types, operand1OperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(operand2Operands, operand1Types[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void SGreaterThanEqualOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand1();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << operand2();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand1().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void SGreaterThanEqualOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::SGreaterThanEqualOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::SGreaterThanOp definitions
//===----------------------------------------------------------------------===//

SGreaterThanOpAdaptor::SGreaterThanOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

SGreaterThanOpAdaptor::SGreaterThanOpAdaptor(SGreaterThanOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange SGreaterThanOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SGreaterThanOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SGreaterThanOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SGreaterThanOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value SGreaterThanOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr SGreaterThanOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult SGreaterThanOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> SGreaterThanOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SGreaterThanOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SGreaterThanOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value SGreaterThanOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SGreaterThanOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange SGreaterThanOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> SGreaterThanOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SGreaterThanOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SGreaterThanOp::result() {
  return *getODSResults(0).begin();
}

void SGreaterThanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value lhs, Value rhs) {
::buildLogicalBinaryOp(odsBuilder, odsState, lhs, rhs);
}

void SGreaterThanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void SGreaterThanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SGreaterThanOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SGreaterThanOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(getUnaryOpResultType((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of result to correspond to the `i1` equivalent of the operand");
  return ::mlir::success();
}

::mlir::LogicalResult SGreaterThanOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult SGreaterThanOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operand1RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand1Operands(operand1RawOperands);  ::llvm::SMLoc operand1OperandsLoc;
  (void)operand1OperandsLoc;
  ::mlir::OpAsmParser::OperandType operand2RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand2Operands(operand2RawOperands);  ::llvm::SMLoc operand2OperandsLoc;
  (void)operand2OperandsLoc;
  ::mlir::Type operand1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand1Types(operand1RawTypes);

  operand1OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand1RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  operand2OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand2RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand1RawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  for (::mlir::Type type : operand1Types) {
    (void)type;
    if (!((((type.isInteger(8))) || ((type.isInteger(16))) || ((type.isInteger(32))) || ((type.isInteger(64)))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isInteger(8))) || ((elementType.isInteger(16))) || ((elementType.isInteger(32))) || ((elementType.isInteger(64))); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
      return parser.emitError(parser.getNameLoc()) << "'operand1' must be 8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(getUnaryOpResultType(operand1Types[0]));
  if (parser.resolveOperands(operand1Operands, operand1Types, operand1OperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(operand2Operands, operand1Types[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void SGreaterThanOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand1();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << operand2();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand1().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void SGreaterThanOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::SGreaterThanOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::SLessThanEqualOp definitions
//===----------------------------------------------------------------------===//

SLessThanEqualOpAdaptor::SLessThanEqualOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

SLessThanEqualOpAdaptor::SLessThanEqualOpAdaptor(SLessThanEqualOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange SLessThanEqualOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SLessThanEqualOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SLessThanEqualOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SLessThanEqualOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value SLessThanEqualOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr SLessThanEqualOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult SLessThanEqualOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> SLessThanEqualOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SLessThanEqualOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SLessThanEqualOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value SLessThanEqualOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SLessThanEqualOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange SLessThanEqualOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> SLessThanEqualOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SLessThanEqualOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SLessThanEqualOp::result() {
  return *getODSResults(0).begin();
}

void SLessThanEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value lhs, Value rhs) {
::buildLogicalBinaryOp(odsBuilder, odsState, lhs, rhs);
}

void SLessThanEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void SLessThanEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SLessThanEqualOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SLessThanEqualOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(getUnaryOpResultType((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of result to correspond to the `i1` equivalent of the operand");
  return ::mlir::success();
}

::mlir::LogicalResult SLessThanEqualOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult SLessThanEqualOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operand1RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand1Operands(operand1RawOperands);  ::llvm::SMLoc operand1OperandsLoc;
  (void)operand1OperandsLoc;
  ::mlir::OpAsmParser::OperandType operand2RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand2Operands(operand2RawOperands);  ::llvm::SMLoc operand2OperandsLoc;
  (void)operand2OperandsLoc;
  ::mlir::Type operand1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand1Types(operand1RawTypes);

  operand1OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand1RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  operand2OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand2RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand1RawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  for (::mlir::Type type : operand1Types) {
    (void)type;
    if (!((((type.isInteger(8))) || ((type.isInteger(16))) || ((type.isInteger(32))) || ((type.isInteger(64)))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isInteger(8))) || ((elementType.isInteger(16))) || ((elementType.isInteger(32))) || ((elementType.isInteger(64))); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
      return parser.emitError(parser.getNameLoc()) << "'operand1' must be 8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(getUnaryOpResultType(operand1Types[0]));
  if (parser.resolveOperands(operand1Operands, operand1Types, operand1OperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(operand2Operands, operand1Types[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void SLessThanEqualOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand1();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << operand2();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand1().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void SLessThanEqualOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::SLessThanEqualOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::SLessThanOp definitions
//===----------------------------------------------------------------------===//

SLessThanOpAdaptor::SLessThanOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

SLessThanOpAdaptor::SLessThanOpAdaptor(SLessThanOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange SLessThanOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SLessThanOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SLessThanOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SLessThanOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value SLessThanOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr SLessThanOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult SLessThanOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> SLessThanOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SLessThanOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SLessThanOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value SLessThanOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SLessThanOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange SLessThanOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> SLessThanOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SLessThanOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SLessThanOp::result() {
  return *getODSResults(0).begin();
}

void SLessThanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value lhs, Value rhs) {
::buildLogicalBinaryOp(odsBuilder, odsState, lhs, rhs);
}

void SLessThanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void SLessThanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SLessThanOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SLessThanOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(getUnaryOpResultType((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of result to correspond to the `i1` equivalent of the operand");
  return ::mlir::success();
}

::mlir::LogicalResult SLessThanOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult SLessThanOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operand1RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand1Operands(operand1RawOperands);  ::llvm::SMLoc operand1OperandsLoc;
  (void)operand1OperandsLoc;
  ::mlir::OpAsmParser::OperandType operand2RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand2Operands(operand2RawOperands);  ::llvm::SMLoc operand2OperandsLoc;
  (void)operand2OperandsLoc;
  ::mlir::Type operand1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand1Types(operand1RawTypes);

  operand1OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand1RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  operand2OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand2RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand1RawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  for (::mlir::Type type : operand1Types) {
    (void)type;
    if (!((((type.isInteger(8))) || ((type.isInteger(16))) || ((type.isInteger(32))) || ((type.isInteger(64)))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isInteger(8))) || ((elementType.isInteger(16))) || ((elementType.isInteger(32))) || ((elementType.isInteger(64))); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
      return parser.emitError(parser.getNameLoc()) << "'operand1' must be 8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(getUnaryOpResultType(operand1Types[0]));
  if (parser.resolveOperands(operand1Operands, operand1Types, operand1OperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(operand2Operands, operand1Types[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void SLessThanOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand1();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << operand2();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand1().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void SLessThanOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::SLessThanOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::SModOp definitions
//===----------------------------------------------------------------------===//

SModOpAdaptor::SModOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

SModOpAdaptor::SModOpAdaptor(SModOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange SModOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SModOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SModOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SModOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value SModOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr SModOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult SModOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> SModOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SModOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SModOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value SModOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SModOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange SModOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> SModOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SModOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SModOp::result() {
  return *getODSResults(0).begin();
}

void SModOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void SModOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SModOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void SModOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes({operand1.getType()});

}

void SModOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult SModOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps10(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps10(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps10(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult SModOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult SModOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(resultTypes), ::llvm::ArrayRef<::mlir::Type>(resultTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void SModOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void SModOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::SModOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::SNegateOp definitions
//===----------------------------------------------------------------------===//

SNegateOpAdaptor::SNegateOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

SNegateOpAdaptor::SNegateOpAdaptor(SNegateOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange SNegateOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SNegateOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SNegateOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SNegateOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr SNegateOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult SNegateOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> SNegateOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SNegateOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SNegateOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange SNegateOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> SNegateOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SNegateOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SNegateOp::result() {
  return *getODSResults(0).begin();
}

void SNegateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void SNegateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SNegateOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void SNegateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void SNegateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult SNegateOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult SNegateOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult SNegateOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(operandTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void SNegateOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void SNegateOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::SNegateOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::SRemOp definitions
//===----------------------------------------------------------------------===//

SRemOpAdaptor::SRemOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

SRemOpAdaptor::SRemOpAdaptor(SRemOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange SRemOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SRemOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SRemOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SRemOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value SRemOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr SRemOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult SRemOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> SRemOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SRemOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SRemOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value SRemOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SRemOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange SRemOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> SRemOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SRemOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SRemOp::result() {
  return *getODSResults(0).begin();
}

void SRemOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void SRemOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SRemOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void SRemOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes({operand1.getType()});

}

void SRemOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult SRemOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps10(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps10(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps10(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult SRemOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult SRemOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(resultTypes), ::llvm::ArrayRef<::mlir::Type>(resultTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void SRemOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void SRemOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::SRemOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::SelectOp definitions
//===----------------------------------------------------------------------===//

SelectOpAdaptor::SelectOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

SelectOpAdaptor::SelectOpAdaptor(SelectOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange SelectOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SelectOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SelectOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SelectOpAdaptor::condition() {
  return *getODSOperands(0).begin();
}

::mlir::Value SelectOpAdaptor::true_value() {
  return *getODSOperands(1).begin();
}

::mlir::Value SelectOpAdaptor::false_value() {
  return *getODSOperands(2).begin();
}

::mlir::DictionaryAttr SelectOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult SelectOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> SelectOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SelectOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SelectOp::condition() {
  return *getODSOperands(0).begin();
}

::mlir::Value SelectOp::true_value() {
  return *getODSOperands(1).begin();
}

::mlir::Value SelectOp::false_value() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange SelectOp::conditionMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange SelectOp::true_valueMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange SelectOp::false_valueMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> SelectOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SelectOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SelectOp::result() {
  return *getODSResults(0).begin();
}

void SelectOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value condition, ::mlir::Value true_value, ::mlir::Value false_value) {
  odsState.addOperands(condition);
  odsState.addOperands(true_value);
  odsState.addOperands(false_value);
  odsState.addTypes(result);
}

void SelectOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value condition, ::mlir::Value true_value, ::mlir::Value false_value) {
  odsState.addOperands(condition);
  odsState.addOperands(true_value);
  odsState.addOperands(false_value);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(SelectOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      /*regions=*/{}, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void SelectOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value condition, ::mlir::Value true_value, ::mlir::Value false_value) {
  odsState.addOperands(condition);
  odsState.addOperands(true_value);
  odsState.addOperands(false_value);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SelectOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void SelectOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  ::mlir::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(SelectOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::mlir::LogicalResult SelectOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps24(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps24(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps24(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((::llvm::is_splat(::llvm::makeArrayRef({(*this->getODSOperands(1).begin()).getType(), (*this->getODSOperands(2).begin()).getType(), (*this->getODSResults(0).begin()).getType()})))))
    return emitOpError("failed to verify that all of {true_value, false_value, result} have same type");
  return ::mlir::success();
}

::mlir::LogicalResult SelectOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::LogicalResult SelectOp::inferReturnTypes(::mlir::MLIRContext *context, ::llvm::Optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  inferredReturnTypes[0] = operands[2].getType();
  return ::mlir::success();
}

::mlir::ParseResult SelectOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type conditionRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> conditionTypes(conditionRawTypes);
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    conditionRawTypes[0] = type;
  }
  if (parser.parseComma())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(conditionTypes), ::llvm::ArrayRef<::mlir::Type>(resultTypes), ::llvm::ArrayRef<::mlir::Type>(resultTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void SelectOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = condition().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void SelectOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::SelectOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::SelectionOp definitions
//===----------------------------------------------------------------------===//

SelectionOpAdaptor::SelectionOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

SelectionOpAdaptor::SelectionOpAdaptor(SelectionOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange SelectionOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SelectionOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SelectionOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr SelectionOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::SelectionControlAttr SelectionOpAdaptor::selection_controlAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::SelectionControlAttr attr = odsAttrs.get("selection_control").cast<::mlir::spirv::SelectionControlAttr>();
  return attr;
}

::mlir::spirv::SelectionControl SelectionOpAdaptor::selection_control() {
  auto attr = selection_controlAttr();
  return attr.getValue();
}

::mlir::RegionRange SelectionOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &SelectionOpAdaptor::body() {
  return *odsRegions[0];
}

::mlir::LogicalResult SelectionOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_selection_control = odsAttrs.get("selection_control");
    if (!tblgen_selection_control)
      return emitError(loc, "'spv.mlir.selection' op ""requires attribute 'selection_control'");

    if (tblgen_selection_control && !((((tblgen_selection_control.isa<::mlir::IntegerAttr>())) && ((tblgen_selection_control.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeSelectionControl(tblgen_selection_control.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.mlir.selection' op ""attribute 'selection_control' failed to satisfy constraint: valid SPIR-V SelectionControl");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> SelectionOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SelectionOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> SelectionOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SelectionOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Region &SelectionOp::body() {
  return (*this)->getRegion(0);
}

::mlir::spirv::SelectionControlAttr SelectionOp::selection_controlAttr() {
  return (*this)->getAttr(selection_controlAttrName()).cast<::mlir::spirv::SelectionControlAttr>();
}

::mlir::spirv::SelectionControl SelectionOp::selection_control() {
  auto attr = selection_controlAttr();
  return attr.getValue();
}

void SelectionOp::selection_controlAttr(::mlir::spirv::SelectionControlAttr attr) {
  (*this)->setAttr(selection_controlAttrName(), attr);
}

void SelectionOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::spirv::SelectionControlAttr selection_control) {
  odsState.addAttribute(selection_controlAttrName(odsState.name), selection_control);
  (void)odsState.addRegion();
}

void SelectionOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::SelectionControlAttr selection_control) {
  odsState.addAttribute(selection_controlAttrName(odsState.name), selection_control);
  (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SelectionOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::spirv::SelectionControl selection_control) {
  odsState.addAttribute(selection_controlAttrName(odsState.name), ::mlir::spirv::SelectionControlAttr::get(odsBuilder.getContext(), selection_control));
  (void)odsState.addRegion();
}

void SelectionOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::SelectionControl selection_control) {
  odsState.addAttribute(selection_controlAttrName(odsState.name), ::mlir::spirv::SelectionControlAttr::get(odsBuilder.getContext(), selection_control));
  (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SelectionOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 1; ++i)
    (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SelectionOp::verifyInvariantsImpl() {
  {
    auto tblgen_selection_control = (*this)->getAttr(selection_controlAttrName());
    if (!tblgen_selection_control)
      return emitOpError("requires attribute 'selection_control'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps19(*this, tblgen_selection_control, "selection_control")))
      return ::mlir::failure();
  }
  if (!((isNestedInFunctionOpInterface((*this->getOperation()).getParentOp()))))
    return emitOpError("failed to verify that op must appear in a function-like op's block");
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::makeMutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_SPIRVOps0(*this, region, "body", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::LogicalResult SelectionOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::SelectionOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::ShiftLeftLogicalOp definitions
//===----------------------------------------------------------------------===//

ShiftLeftLogicalOpAdaptor::ShiftLeftLogicalOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

ShiftLeftLogicalOpAdaptor::ShiftLeftLogicalOpAdaptor(ShiftLeftLogicalOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange ShiftLeftLogicalOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ShiftLeftLogicalOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ShiftLeftLogicalOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ShiftLeftLogicalOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value ShiftLeftLogicalOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr ShiftLeftLogicalOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult ShiftLeftLogicalOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> ShiftLeftLogicalOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ShiftLeftLogicalOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ShiftLeftLogicalOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value ShiftLeftLogicalOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange ShiftLeftLogicalOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange ShiftLeftLogicalOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> ShiftLeftLogicalOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ShiftLeftLogicalOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ShiftLeftLogicalOp::result() {
  return *getODSResults(0).begin();
}

void ShiftLeftLogicalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void ShiftLeftLogicalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(ShiftLeftLogicalOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      /*regions=*/{}, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void ShiftLeftLogicalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ShiftLeftLogicalOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void ShiftLeftLogicalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  ::mlir::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(ShiftLeftLogicalOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::mlir::LogicalResult ShiftLeftLogicalOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((::llvm::is_splat(::llvm::makeArrayRef({(*this->getODSOperands(0).begin()).getType(), (*this->getODSResults(0).begin()).getType()})))))
    return emitOpError("failed to verify that all of {operand1, result} have same type");
  return ::mlir::success();
}

::mlir::LogicalResult ShiftLeftLogicalOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::LogicalResult ShiftLeftLogicalOp::inferReturnTypes(::mlir::MLIRContext *context, ::llvm::Optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  inferredReturnTypes[0] = operands[0].getType();
  return ::mlir::success();
}

::mlir::ParseResult ShiftLeftLogicalOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type operand1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand1Types(operand1RawTypes);
  ::mlir::Type operand2RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand2Types(operand2RawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand1RawTypes[0] = type;
  }
  if (parser.parseComma())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand2RawTypes[0] = type;
  }
  result.addTypes(operand1Types);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(operand1Types), ::llvm::ArrayRef<::mlir::Type>(operand2Types)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ShiftLeftLogicalOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand1().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';
  {
    auto type = operand2().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void ShiftLeftLogicalOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::ShiftLeftLogicalOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::ShiftRightArithmeticOp definitions
//===----------------------------------------------------------------------===//

ShiftRightArithmeticOpAdaptor::ShiftRightArithmeticOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

ShiftRightArithmeticOpAdaptor::ShiftRightArithmeticOpAdaptor(ShiftRightArithmeticOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange ShiftRightArithmeticOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ShiftRightArithmeticOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ShiftRightArithmeticOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ShiftRightArithmeticOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value ShiftRightArithmeticOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr ShiftRightArithmeticOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult ShiftRightArithmeticOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> ShiftRightArithmeticOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ShiftRightArithmeticOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ShiftRightArithmeticOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value ShiftRightArithmeticOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange ShiftRightArithmeticOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange ShiftRightArithmeticOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> ShiftRightArithmeticOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ShiftRightArithmeticOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ShiftRightArithmeticOp::result() {
  return *getODSResults(0).begin();
}

void ShiftRightArithmeticOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void ShiftRightArithmeticOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(ShiftRightArithmeticOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      /*regions=*/{}, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void ShiftRightArithmeticOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ShiftRightArithmeticOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void ShiftRightArithmeticOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  ::mlir::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(ShiftRightArithmeticOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::mlir::LogicalResult ShiftRightArithmeticOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((::llvm::is_splat(::llvm::makeArrayRef({(*this->getODSOperands(0).begin()).getType(), (*this->getODSResults(0).begin()).getType()})))))
    return emitOpError("failed to verify that all of {operand1, result} have same type");
  return ::mlir::success();
}

::mlir::LogicalResult ShiftRightArithmeticOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::LogicalResult ShiftRightArithmeticOp::inferReturnTypes(::mlir::MLIRContext *context, ::llvm::Optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  inferredReturnTypes[0] = operands[0].getType();
  return ::mlir::success();
}

::mlir::ParseResult ShiftRightArithmeticOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type operand1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand1Types(operand1RawTypes);
  ::mlir::Type operand2RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand2Types(operand2RawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand1RawTypes[0] = type;
  }
  if (parser.parseComma())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand2RawTypes[0] = type;
  }
  result.addTypes(operand1Types);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(operand1Types), ::llvm::ArrayRef<::mlir::Type>(operand2Types)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ShiftRightArithmeticOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand1().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';
  {
    auto type = operand2().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void ShiftRightArithmeticOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::ShiftRightArithmeticOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::ShiftRightLogicalOp definitions
//===----------------------------------------------------------------------===//

ShiftRightLogicalOpAdaptor::ShiftRightLogicalOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

ShiftRightLogicalOpAdaptor::ShiftRightLogicalOpAdaptor(ShiftRightLogicalOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange ShiftRightLogicalOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ShiftRightLogicalOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ShiftRightLogicalOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ShiftRightLogicalOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value ShiftRightLogicalOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr ShiftRightLogicalOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult ShiftRightLogicalOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> ShiftRightLogicalOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ShiftRightLogicalOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ShiftRightLogicalOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value ShiftRightLogicalOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange ShiftRightLogicalOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange ShiftRightLogicalOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> ShiftRightLogicalOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ShiftRightLogicalOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ShiftRightLogicalOp::result() {
  return *getODSResults(0).begin();
}

void ShiftRightLogicalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void ShiftRightLogicalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(ShiftRightLogicalOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      /*regions=*/{}, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void ShiftRightLogicalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ShiftRightLogicalOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void ShiftRightLogicalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  ::mlir::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(ShiftRightLogicalOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::mlir::LogicalResult ShiftRightLogicalOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((::llvm::is_splat(::llvm::makeArrayRef({(*this->getODSOperands(0).begin()).getType(), (*this->getODSResults(0).begin()).getType()})))))
    return emitOpError("failed to verify that all of {operand1, result} have same type");
  return ::mlir::success();
}

::mlir::LogicalResult ShiftRightLogicalOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::LogicalResult ShiftRightLogicalOp::inferReturnTypes(::mlir::MLIRContext *context, ::llvm::Optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  inferredReturnTypes[0] = operands[0].getType();
  return ::mlir::success();
}

::mlir::ParseResult ShiftRightLogicalOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type operand1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand1Types(operand1RawTypes);
  ::mlir::Type operand2RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand2Types(operand2RawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand1RawTypes[0] = type;
  }
  if (parser.parseComma())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand2RawTypes[0] = type;
  }
  result.addTypes(operand1Types);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(operand1Types), ::llvm::ArrayRef<::mlir::Type>(operand2Types)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ShiftRightLogicalOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand1().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';
  {
    auto type = operand2().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void ShiftRightLogicalOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::ShiftRightLogicalOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::SpecConstantCompositeOp definitions
//===----------------------------------------------------------------------===//

SpecConstantCompositeOpAdaptor::SpecConstantCompositeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

SpecConstantCompositeOpAdaptor::SpecConstantCompositeOpAdaptor(SpecConstantCompositeOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange SpecConstantCompositeOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SpecConstantCompositeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SpecConstantCompositeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr SpecConstantCompositeOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::TypeAttr SpecConstantCompositeOpAdaptor::typeAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::TypeAttr attr = odsAttrs.get("type").cast<::mlir::TypeAttr>();
  return attr;
}

::mlir::Type SpecConstantCompositeOpAdaptor::type() {
  auto attr = typeAttr();
  return attr.getValue().cast<::mlir::Type>();
}

::mlir::StringAttr SpecConstantCompositeOpAdaptor::sym_nameAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("sym_name").cast<::mlir::StringAttr>();
  return attr;
}

::llvm::StringRef SpecConstantCompositeOpAdaptor::sym_name() {
  auto attr = sym_nameAttr();
  return attr.getValue();
}

::mlir::ArrayAttr SpecConstantCompositeOpAdaptor::constituentsAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("constituents").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr SpecConstantCompositeOpAdaptor::constituents() {
  auto attr = constituentsAttr();
  return attr;
}

::mlir::LogicalResult SpecConstantCompositeOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_type = odsAttrs.get("type");
    if (!tblgen_type)
      return emitError(loc, "'spv.SpecConstantComposite' op ""requires attribute 'type'");

    if (tblgen_type && !(((tblgen_type.isa<::mlir::TypeAttr>())) && ((tblgen_type.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>()))))
      return emitError(loc, "'spv.SpecConstantComposite' op ""attribute 'type' failed to satisfy constraint: any type attribute");
  }
  {
    auto tblgen_sym_name = odsAttrs.get("sym_name");
    if (!tblgen_sym_name)
      return emitError(loc, "'spv.SpecConstantComposite' op ""requires attribute 'sym_name'");

    if (tblgen_sym_name && !((tblgen_sym_name.isa<::mlir::StringAttr>())))
      return emitError(loc, "'spv.SpecConstantComposite' op ""attribute 'sym_name' failed to satisfy constraint: string attribute");
  }
  {
    auto tblgen_constituents = odsAttrs.get("constituents");
    if (!tblgen_constituents)
      return emitError(loc, "'spv.SpecConstantComposite' op ""requires attribute 'constituents'");

    if (tblgen_constituents && !(((tblgen_constituents.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_constituents.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return (attr.isa<::mlir::SymbolRefAttr>()); }))))
      return emitError(loc, "'spv.SpecConstantComposite' op ""attribute 'constituents' failed to satisfy constraint: symbol ref array attribute");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> SpecConstantCompositeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SpecConstantCompositeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> SpecConstantCompositeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SpecConstantCompositeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::TypeAttr SpecConstantCompositeOp::typeAttr() {
  return (*this)->getAttr(typeAttrName()).cast<::mlir::TypeAttr>();
}

::mlir::Type SpecConstantCompositeOp::type() {
  auto attr = typeAttr();
  return attr.getValue().cast<::mlir::Type>();
}

::mlir::StringAttr SpecConstantCompositeOp::sym_nameAttr() {
  return (*this)->getAttr(sym_nameAttrName()).cast<::mlir::StringAttr>();
}

::llvm::StringRef SpecConstantCompositeOp::sym_name() {
  auto attr = sym_nameAttr();
  return attr.getValue();
}

::mlir::ArrayAttr SpecConstantCompositeOp::constituentsAttr() {
  return (*this)->getAttr(constituentsAttrName()).cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr SpecConstantCompositeOp::constituents() {
  auto attr = constituentsAttr();
  return attr;
}

void SpecConstantCompositeOp::typeAttr(::mlir::TypeAttr attr) {
  (*this)->setAttr(typeAttrName(), attr);
}

void SpecConstantCompositeOp::sym_nameAttr(::mlir::StringAttr attr) {
  (*this)->setAttr(sym_nameAttrName(), attr);
}

void SpecConstantCompositeOp::constituentsAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(constituentsAttrName(), attr);
}

void SpecConstantCompositeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeAttr type, ::mlir::StringAttr sym_name, ::mlir::ArrayAttr constituents) {
  odsState.addAttribute(typeAttrName(odsState.name), type);
  odsState.addAttribute(sym_nameAttrName(odsState.name), sym_name);
  odsState.addAttribute(constituentsAttrName(odsState.name), constituents);
}

void SpecConstantCompositeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::TypeAttr type, ::mlir::StringAttr sym_name, ::mlir::ArrayAttr constituents) {
  odsState.addAttribute(typeAttrName(odsState.name), type);
  odsState.addAttribute(sym_nameAttrName(odsState.name), sym_name);
  odsState.addAttribute(constituentsAttrName(odsState.name), constituents);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SpecConstantCompositeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type type, ::llvm::StringRef sym_name, ::mlir::ArrayAttr constituents) {
  odsState.addAttribute(typeAttrName(odsState.name), ::mlir::TypeAttr::get(type));
  odsState.addAttribute(sym_nameAttrName(odsState.name), odsBuilder.getStringAttr(sym_name));
  odsState.addAttribute(constituentsAttrName(odsState.name), constituents);
}

void SpecConstantCompositeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Type type, ::llvm::StringRef sym_name, ::mlir::ArrayAttr constituents) {
  odsState.addAttribute(typeAttrName(odsState.name), ::mlir::TypeAttr::get(type));
  odsState.addAttribute(sym_nameAttrName(odsState.name), odsBuilder.getStringAttr(sym_name));
  odsState.addAttribute(constituentsAttrName(odsState.name), constituents);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SpecConstantCompositeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SpecConstantCompositeOp::verifyInvariantsImpl() {
  {
    auto tblgen_type = (*this)->getAttr(typeAttrName());
    if (!tblgen_type)
      return emitOpError("requires attribute 'type'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps5(*this, tblgen_type, "type")))
      return ::mlir::failure();
  }
  {
    auto tblgen_sym_name = (*this)->getAttr(sym_nameAttrName());
    if (!tblgen_sym_name)
      return emitOpError("requires attribute 'sym_name'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps11(*this, tblgen_sym_name, "sym_name")))
      return ::mlir::failure();
  }
  {
    auto tblgen_constituents = (*this)->getAttr(constituentsAttrName());
    if (!tblgen_constituents)
      return emitOpError("requires attribute 'constituents'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps9(*this, tblgen_constituents, "constituents")))
      return ::mlir::failure();
  }
  if (!((isDirectInModuleLikeOp((*this->getOperation()).getParentOp()))))
    return emitOpError("failed to verify that op must appear in a module-like op's block");
  return ::mlir::success();
}

::mlir::LogicalResult SpecConstantCompositeOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::SpecConstantCompositeOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::SpecConstantOp definitions
//===----------------------------------------------------------------------===//

SpecConstantOpAdaptor::SpecConstantOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

SpecConstantOpAdaptor::SpecConstantOpAdaptor(SpecConstantOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange SpecConstantOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SpecConstantOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SpecConstantOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr SpecConstantOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::StringAttr SpecConstantOpAdaptor::sym_nameAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("sym_name").cast<::mlir::StringAttr>();
  return attr;
}

::llvm::StringRef SpecConstantOpAdaptor::sym_name() {
  auto attr = sym_nameAttr();
  return attr.getValue();
}

::mlir::Attribute SpecConstantOpAdaptor::default_valueAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::Attribute attr = odsAttrs.get("default_value").cast<::mlir::Attribute>();
  return attr;
}

::mlir::Attribute SpecConstantOpAdaptor::default_value() {
  auto attr = default_valueAttr();
  return attr;
}

::mlir::LogicalResult SpecConstantOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_sym_name = odsAttrs.get("sym_name");
    if (!tblgen_sym_name)
      return emitError(loc, "'spv.SpecConstant' op ""requires attribute 'sym_name'");

    if (tblgen_sym_name && !((tblgen_sym_name.isa<::mlir::StringAttr>())))
      return emitError(loc, "'spv.SpecConstant' op ""attribute 'sym_name' failed to satisfy constraint: string attribute");
  }
  {
    auto tblgen_default_value = odsAttrs.get("default_value");
    if (!tblgen_default_value)
      return emitError(loc, "'spv.SpecConstant' op ""requires attribute 'default_value'");

    if (tblgen_default_value && !((true)))
      return emitError(loc, "'spv.SpecConstant' op ""attribute 'default_value' failed to satisfy constraint: any attribute");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> SpecConstantOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SpecConstantOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> SpecConstantOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SpecConstantOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::StringAttr SpecConstantOp::sym_nameAttr() {
  return (*this)->getAttr(sym_nameAttrName()).cast<::mlir::StringAttr>();
}

::llvm::StringRef SpecConstantOp::sym_name() {
  auto attr = sym_nameAttr();
  return attr.getValue();
}

::mlir::Attribute SpecConstantOp::default_valueAttr() {
  return (*this)->getAttr(default_valueAttrName()).cast<::mlir::Attribute>();
}

::mlir::Attribute SpecConstantOp::default_value() {
  auto attr = default_valueAttr();
  return attr;
}

void SpecConstantOp::sym_nameAttr(::mlir::StringAttr attr) {
  (*this)->setAttr(sym_nameAttrName(), attr);
}

void SpecConstantOp::default_valueAttr(::mlir::Attribute attr) {
  (*this)->setAttr(default_valueAttrName(), attr);
}

void SpecConstantOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::StringAttr sym_name, ::mlir::Attribute default_value) {
  odsState.addAttribute(sym_nameAttrName(odsState.name), sym_name);
  odsState.addAttribute(default_valueAttrName(odsState.name), default_value);
}

void SpecConstantOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::StringAttr sym_name, ::mlir::Attribute default_value) {
  odsState.addAttribute(sym_nameAttrName(odsState.name), sym_name);
  odsState.addAttribute(default_valueAttrName(odsState.name), default_value);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SpecConstantOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::llvm::StringRef sym_name, ::mlir::Attribute default_value) {
  odsState.addAttribute(sym_nameAttrName(odsState.name), odsBuilder.getStringAttr(sym_name));
  odsState.addAttribute(default_valueAttrName(odsState.name), default_value);
}

void SpecConstantOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef sym_name, ::mlir::Attribute default_value) {
  odsState.addAttribute(sym_nameAttrName(odsState.name), odsBuilder.getStringAttr(sym_name));
  odsState.addAttribute(default_valueAttrName(odsState.name), default_value);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SpecConstantOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SpecConstantOp::verifyInvariantsImpl() {
  {
    auto tblgen_sym_name = (*this)->getAttr(sym_nameAttrName());
    if (!tblgen_sym_name)
      return emitOpError("requires attribute 'sym_name'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps11(*this, tblgen_sym_name, "sym_name")))
      return ::mlir::failure();
  }
  {
    auto tblgen_default_value = (*this)->getAttr(default_valueAttrName());
    if (!tblgen_default_value)
      return emitOpError("requires attribute 'default_value'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps4(*this, tblgen_default_value, "default_value")))
      return ::mlir::failure();
  }
  if (!((isDirectInModuleLikeOp((*this->getOperation()).getParentOp()))))
    return emitOpError("failed to verify that op must appear in a module-like op's block");
  return ::mlir::success();
}

::mlir::LogicalResult SpecConstantOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::SpecConstantOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::SpecConstantOperationOp definitions
//===----------------------------------------------------------------------===//

SpecConstantOperationOpAdaptor::SpecConstantOperationOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

SpecConstantOperationOpAdaptor::SpecConstantOperationOpAdaptor(SpecConstantOperationOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange SpecConstantOperationOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SpecConstantOperationOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SpecConstantOperationOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr SpecConstantOperationOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange SpecConstantOperationOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &SpecConstantOperationOpAdaptor::body() {
  return *odsRegions[0];
}

::mlir::LogicalResult SpecConstantOperationOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> SpecConstantOperationOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SpecConstantOperationOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> SpecConstantOperationOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SpecConstantOperationOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SpecConstantOperationOp::result() {
  return *getODSResults(0).begin();
}

::mlir::Region &SpecConstantOperationOp::body() {
  return (*this)->getRegion(0);
}

void SpecConstantOperationOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result) {
  (void)odsState.addRegion();
  odsState.addTypes(result);
}

void SpecConstantOperationOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes) {
  (void)odsState.addRegion();
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SpecConstantOperationOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 1; ++i)
    (void)odsState.addRegion();
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SpecConstantOperationOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps25(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((isNestedInFunctionOpInterface((*this->getOperation()).getParentOp()))))
    return emitOpError("failed to verify that op must appear in a function-like op's block");
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::makeMutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_SPIRVOps1(*this, region, "body", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::LogicalResult SpecConstantOperationOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

void SpecConstantOperationOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::SpecConstantOperationOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::StoreOp definitions
//===----------------------------------------------------------------------===//

StoreOpAdaptor::StoreOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

StoreOpAdaptor::StoreOpAdaptor(StoreOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange StoreOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> StoreOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange StoreOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StoreOpAdaptor::ptr() {
  return *getODSOperands(0).begin();
}

::mlir::Value StoreOpAdaptor::value() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr StoreOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::MemoryAccessAttr StoreOpAdaptor::memory_accessAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::MemoryAccessAttr attr = odsAttrs.get("memory_access").dyn_cast_or_null<::mlir::spirv::MemoryAccessAttr>();
  return attr;
}

::llvm::Optional<::mlir::spirv::MemoryAccess> StoreOpAdaptor::memory_access() {
  auto attr = memory_accessAttr();
  return attr ? ::llvm::Optional<::mlir::spirv::MemoryAccess>(attr.getValue()) : (::llvm::None);
}

::mlir::IntegerAttr StoreOpAdaptor::alignmentAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("alignment").dyn_cast_or_null<::mlir::IntegerAttr>();
  return attr;
}

::llvm::Optional<uint32_t> StoreOpAdaptor::alignment() {
  auto attr = alignmentAttr();
  return attr ? ::llvm::Optional<uint32_t>(attr.getValue().getZExtValue()) : (::llvm::None);
}

::mlir::LogicalResult StoreOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_memory_access = odsAttrs.get("memory_access");
    if (tblgen_memory_access && !((((tblgen_memory_access.isa<::mlir::IntegerAttr>())) && ((tblgen_memory_access.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeMemoryAccess(tblgen_memory_access.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.Store' op ""attribute 'memory_access' failed to satisfy constraint: valid SPIR-V MemoryAccess");
  }
  {
    auto tblgen_alignment = odsAttrs.get("alignment");
    if (tblgen_alignment && !(((tblgen_alignment.isa<::mlir::IntegerAttr>())) && ((tblgen_alignment.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))))
      return emitError(loc, "'spv.Store' op ""attribute 'alignment' failed to satisfy constraint: 32-bit signless integer attribute");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> StoreOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range StoreOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value StoreOp::ptr() {
  return *getODSOperands(0).begin();
}

::mlir::Value StoreOp::value() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange StoreOp::ptrMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange StoreOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> StoreOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range StoreOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::spirv::MemoryAccessAttr StoreOp::memory_accessAttr() {
  return (*this)->getAttr(memory_accessAttrName()).dyn_cast_or_null<::mlir::spirv::MemoryAccessAttr>();
}

::llvm::Optional<::mlir::spirv::MemoryAccess> StoreOp::memory_access() {
  auto attr = memory_accessAttr();
  return attr ? ::llvm::Optional<::mlir::spirv::MemoryAccess>(attr.getValue()) : (::llvm::None);
}

::mlir::IntegerAttr StoreOp::alignmentAttr() {
  return (*this)->getAttr(alignmentAttrName()).dyn_cast_or_null<::mlir::IntegerAttr>();
}

::llvm::Optional<uint32_t> StoreOp::alignment() {
  auto attr = alignmentAttr();
  return attr ? ::llvm::Optional<uint32_t>(attr.getValue().getZExtValue()) : (::llvm::None);
}

void StoreOp::memory_accessAttr(::mlir::spirv::MemoryAccessAttr attr) {
  (*this)->setAttr(memory_accessAttrName(), attr);
}

void StoreOp::alignmentAttr(::mlir::IntegerAttr attr) {
  (*this)->setAttr(alignmentAttrName(), attr);
}

::mlir::Attribute StoreOp::removeMemory_accessAttr() {
  return (*this)->removeAttr(memory_accessAttrName());
}

::mlir::Attribute StoreOp::removeAlignmentAttr() {
  return (*this)->removeAttr(alignmentAttrName());
}

void StoreOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value ptr, Value value, ArrayRef<NamedAttribute> namedAttrs) {
      odsState.addOperands(ptr);
      odsState.addOperands(value);
      odsState.addAttributes(namedAttrs);
    
}

void StoreOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value ptr, ::mlir::Value value, /*optional*/::mlir::spirv::MemoryAccessAttr memory_access, /*optional*/::mlir::IntegerAttr alignment) {
  odsState.addOperands(ptr);
  odsState.addOperands(value);
  if (memory_access) {
  odsState.addAttribute(memory_accessAttrName(odsState.name), memory_access);
  }
  if (alignment) {
  odsState.addAttribute(alignmentAttrName(odsState.name), alignment);
  }
}

void StoreOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value ptr, ::mlir::Value value, /*optional*/::mlir::spirv::MemoryAccessAttr memory_access, /*optional*/::mlir::IntegerAttr alignment) {
  odsState.addOperands(ptr);
  odsState.addOperands(value);
  if (memory_access) {
  odsState.addAttribute(memory_accessAttrName(odsState.name), memory_access);
  }
  if (alignment) {
  odsState.addAttribute(alignmentAttrName(odsState.name), alignment);
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void StoreOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult StoreOp::verifyInvariantsImpl() {
  {
    auto tblgen_memory_access = (*this)->getAttr(memory_accessAttrName());
    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps6(*this, tblgen_memory_access, "memory_access")))
      return ::mlir::failure();
  }
  {
    auto tblgen_alignment = (*this)->getAttr(alignmentAttrName());
    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps7(*this, tblgen_alignment, "alignment")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps0(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps7(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult StoreOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::StoreOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::SubgroupBallotKHROp definitions
//===----------------------------------------------------------------------===//

SubgroupBallotKHROpAdaptor::SubgroupBallotKHROpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

SubgroupBallotKHROpAdaptor::SubgroupBallotKHROpAdaptor(SubgroupBallotKHROp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange SubgroupBallotKHROpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SubgroupBallotKHROpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SubgroupBallotKHROpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SubgroupBallotKHROpAdaptor::predicate() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr SubgroupBallotKHROpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult SubgroupBallotKHROpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> SubgroupBallotKHROp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SubgroupBallotKHROp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SubgroupBallotKHROp::predicate() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange SubgroupBallotKHROp::predicateMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> SubgroupBallotKHROp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SubgroupBallotKHROp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SubgroupBallotKHROp::result() {
  return *getODSResults(0).begin();
}

void SubgroupBallotKHROp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value predicate) {
  odsState.addOperands(predicate);
  odsState.addTypes(result);
}

void SubgroupBallotKHROp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value predicate) {
  odsState.addOperands(predicate);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SubgroupBallotKHROp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SubgroupBallotKHROp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps6(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps26(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult SubgroupBallotKHROp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult SubgroupBallotKHROp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType predicateRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> predicateOperands(predicateRawOperands);  ::llvm::SMLoc predicateOperandsLoc;
  (void)predicateOperandsLoc;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  predicateOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(predicateRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::VectorType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getIntegerType(1);
  result.addTypes(resultTypes);
  if (parser.resolveOperands(predicateOperands, odsBuildableType0, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void SubgroupBallotKHROp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << predicate();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::VectorType>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::SubgroupBallotKHROp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::SubgroupBlockReadINTELOp definitions
//===----------------------------------------------------------------------===//

SubgroupBlockReadINTELOpAdaptor::SubgroupBlockReadINTELOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

SubgroupBlockReadINTELOpAdaptor::SubgroupBlockReadINTELOpAdaptor(SubgroupBlockReadINTELOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange SubgroupBlockReadINTELOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SubgroupBlockReadINTELOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SubgroupBlockReadINTELOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SubgroupBlockReadINTELOpAdaptor::ptr() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr SubgroupBlockReadINTELOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult SubgroupBlockReadINTELOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> SubgroupBlockReadINTELOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SubgroupBlockReadINTELOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SubgroupBlockReadINTELOp::ptr() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange SubgroupBlockReadINTELOp::ptrMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> SubgroupBlockReadINTELOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SubgroupBlockReadINTELOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SubgroupBlockReadINTELOp::value() {
  return *getODSResults(0).begin();
}

void SubgroupBlockReadINTELOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type value, ::mlir::Value ptr) {
  odsState.addOperands(ptr);
  odsState.addTypes(value);
}

void SubgroupBlockReadINTELOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value ptr) {
  odsState.addOperands(ptr);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SubgroupBlockReadINTELOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SubgroupBlockReadINTELOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps0(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps7(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult SubgroupBlockReadINTELOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::SubgroupBlockReadINTELOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::SubgroupBlockWriteINTELOp definitions
//===----------------------------------------------------------------------===//

SubgroupBlockWriteINTELOpAdaptor::SubgroupBlockWriteINTELOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

SubgroupBlockWriteINTELOpAdaptor::SubgroupBlockWriteINTELOpAdaptor(SubgroupBlockWriteINTELOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange SubgroupBlockWriteINTELOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SubgroupBlockWriteINTELOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SubgroupBlockWriteINTELOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SubgroupBlockWriteINTELOpAdaptor::ptr() {
  return *getODSOperands(0).begin();
}

::mlir::Value SubgroupBlockWriteINTELOpAdaptor::value() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr SubgroupBlockWriteINTELOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult SubgroupBlockWriteINTELOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> SubgroupBlockWriteINTELOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SubgroupBlockWriteINTELOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SubgroupBlockWriteINTELOp::ptr() {
  return *getODSOperands(0).begin();
}

::mlir::Value SubgroupBlockWriteINTELOp::value() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SubgroupBlockWriteINTELOp::ptrMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange SubgroupBlockWriteINTELOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> SubgroupBlockWriteINTELOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SubgroupBlockWriteINTELOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void SubgroupBlockWriteINTELOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value ptr, ::mlir::Value value) {
  odsState.addOperands(ptr);
  odsState.addOperands(value);
}

void SubgroupBlockWriteINTELOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value ptr, ::mlir::Value value) {
  odsState.addOperands(ptr);
  odsState.addOperands(value);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SubgroupBlockWriteINTELOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SubgroupBlockWriteINTELOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps0(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps7(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult SubgroupBlockWriteINTELOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::SubgroupBlockWriteINTELOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::TransposeOp definitions
//===----------------------------------------------------------------------===//

TransposeOpAdaptor::TransposeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

TransposeOpAdaptor::TransposeOpAdaptor(TransposeOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange TransposeOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> TransposeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TransposeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TransposeOpAdaptor::matrix() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr TransposeOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult TransposeOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> TransposeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TransposeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TransposeOp::matrix() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange TransposeOp::matrixMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> TransposeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TransposeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TransposeOp::result() {
  return *getODSResults(0).begin();
}

void TransposeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value matrix) {
  odsState.addOperands(matrix);
  odsState.addTypes(result);
}

void TransposeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value matrix) {
  odsState.addOperands(matrix);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TransposeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TransposeOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps23(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps23(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult TransposeOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult TransposeOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type matrixRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> matrixTypes(matrixRawTypes);
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    matrixRawTypes[0] = type;
  }
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(allOperands, matrixTypes, allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void TransposeOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = matrix().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ' << "->";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void TransposeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::TransposeOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::UConvertOp definitions
//===----------------------------------------------------------------------===//

UConvertOpAdaptor::UConvertOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

UConvertOpAdaptor::UConvertOpAdaptor(UConvertOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange UConvertOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> UConvertOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange UConvertOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UConvertOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr UConvertOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult UConvertOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> UConvertOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range UConvertOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UConvertOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange UConvertOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> UConvertOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range UConvertOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UConvertOp::result() {
  return *getODSResults(0).begin();
}

void UConvertOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void UConvertOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UConvertOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult UConvertOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps10(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps10(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult UConvertOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult UConvertOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.parseKeyword("to"))
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void UConvertOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ' << "to";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void UConvertOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::UConvertOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::UDivOp definitions
//===----------------------------------------------------------------------===//

UDivOpAdaptor::UDivOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

UDivOpAdaptor::UDivOpAdaptor(UDivOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange UDivOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> UDivOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange UDivOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UDivOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value UDivOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr UDivOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult UDivOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> UDivOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range UDivOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UDivOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value UDivOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange UDivOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange UDivOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> UDivOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range UDivOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UDivOp::result() {
  return *getODSResults(0).begin();
}

void UDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void UDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UDivOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void UDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes({operand1.getType()});

}

void UDivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult UDivOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps10(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps10(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps10(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult UDivOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult UDivOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(resultTypes), ::llvm::ArrayRef<::mlir::Type>(resultTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void UDivOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void UDivOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::UDivOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::UGreaterThanEqualOp definitions
//===----------------------------------------------------------------------===//

UGreaterThanEqualOpAdaptor::UGreaterThanEqualOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

UGreaterThanEqualOpAdaptor::UGreaterThanEqualOpAdaptor(UGreaterThanEqualOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange UGreaterThanEqualOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> UGreaterThanEqualOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange UGreaterThanEqualOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UGreaterThanEqualOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value UGreaterThanEqualOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr UGreaterThanEqualOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult UGreaterThanEqualOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> UGreaterThanEqualOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range UGreaterThanEqualOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UGreaterThanEqualOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value UGreaterThanEqualOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange UGreaterThanEqualOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange UGreaterThanEqualOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> UGreaterThanEqualOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range UGreaterThanEqualOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UGreaterThanEqualOp::result() {
  return *getODSResults(0).begin();
}

void UGreaterThanEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value lhs, Value rhs) {
::buildLogicalBinaryOp(odsBuilder, odsState, lhs, rhs);
}

void UGreaterThanEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void UGreaterThanEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UGreaterThanEqualOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult UGreaterThanEqualOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(getUnaryOpResultType((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of result to correspond to the `i1` equivalent of the operand");
  return ::mlir::success();
}

::mlir::LogicalResult UGreaterThanEqualOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult UGreaterThanEqualOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operand1RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand1Operands(operand1RawOperands);  ::llvm::SMLoc operand1OperandsLoc;
  (void)operand1OperandsLoc;
  ::mlir::OpAsmParser::OperandType operand2RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand2Operands(operand2RawOperands);  ::llvm::SMLoc operand2OperandsLoc;
  (void)operand2OperandsLoc;
  ::mlir::Type operand1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand1Types(operand1RawTypes);

  operand1OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand1RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  operand2OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand2RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand1RawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  for (::mlir::Type type : operand1Types) {
    (void)type;
    if (!((((type.isInteger(8))) || ((type.isInteger(16))) || ((type.isInteger(32))) || ((type.isInteger(64)))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isInteger(8))) || ((elementType.isInteger(16))) || ((elementType.isInteger(32))) || ((elementType.isInteger(64))); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
      return parser.emitError(parser.getNameLoc()) << "'operand1' must be 8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(getUnaryOpResultType(operand1Types[0]));
  if (parser.resolveOperands(operand1Operands, operand1Types, operand1OperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(operand2Operands, operand1Types[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void UGreaterThanEqualOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand1();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << operand2();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand1().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void UGreaterThanEqualOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::UGreaterThanEqualOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::UGreaterThanOp definitions
//===----------------------------------------------------------------------===//

UGreaterThanOpAdaptor::UGreaterThanOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

UGreaterThanOpAdaptor::UGreaterThanOpAdaptor(UGreaterThanOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange UGreaterThanOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> UGreaterThanOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange UGreaterThanOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UGreaterThanOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value UGreaterThanOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr UGreaterThanOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult UGreaterThanOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> UGreaterThanOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range UGreaterThanOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UGreaterThanOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value UGreaterThanOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange UGreaterThanOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange UGreaterThanOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> UGreaterThanOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range UGreaterThanOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UGreaterThanOp::result() {
  return *getODSResults(0).begin();
}

void UGreaterThanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value lhs, Value rhs) {
::buildLogicalBinaryOp(odsBuilder, odsState, lhs, rhs);
}

void UGreaterThanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void UGreaterThanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UGreaterThanOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult UGreaterThanOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(getUnaryOpResultType((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of result to correspond to the `i1` equivalent of the operand");
  return ::mlir::success();
}

::mlir::LogicalResult UGreaterThanOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult UGreaterThanOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operand1RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand1Operands(operand1RawOperands);  ::llvm::SMLoc operand1OperandsLoc;
  (void)operand1OperandsLoc;
  ::mlir::OpAsmParser::OperandType operand2RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand2Operands(operand2RawOperands);  ::llvm::SMLoc operand2OperandsLoc;
  (void)operand2OperandsLoc;
  ::mlir::Type operand1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand1Types(operand1RawTypes);

  operand1OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand1RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  operand2OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand2RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand1RawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  for (::mlir::Type type : operand1Types) {
    (void)type;
    if (!((((type.isInteger(8))) || ((type.isInteger(16))) || ((type.isInteger(32))) || ((type.isInteger(64)))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isInteger(8))) || ((elementType.isInteger(16))) || ((elementType.isInteger(32))) || ((elementType.isInteger(64))); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
      return parser.emitError(parser.getNameLoc()) << "'operand1' must be 8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(getUnaryOpResultType(operand1Types[0]));
  if (parser.resolveOperands(operand1Operands, operand1Types, operand1OperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(operand2Operands, operand1Types[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void UGreaterThanOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand1();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << operand2();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand1().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void UGreaterThanOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::UGreaterThanOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::ULessThanEqualOp definitions
//===----------------------------------------------------------------------===//

ULessThanEqualOpAdaptor::ULessThanEqualOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

ULessThanEqualOpAdaptor::ULessThanEqualOpAdaptor(ULessThanEqualOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange ULessThanEqualOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ULessThanEqualOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ULessThanEqualOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ULessThanEqualOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value ULessThanEqualOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr ULessThanEqualOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult ULessThanEqualOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> ULessThanEqualOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ULessThanEqualOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ULessThanEqualOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value ULessThanEqualOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange ULessThanEqualOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange ULessThanEqualOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> ULessThanEqualOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ULessThanEqualOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ULessThanEqualOp::result() {
  return *getODSResults(0).begin();
}

void ULessThanEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value lhs, Value rhs) {
::buildLogicalBinaryOp(odsBuilder, odsState, lhs, rhs);
}

void ULessThanEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void ULessThanEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ULessThanEqualOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ULessThanEqualOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(getUnaryOpResultType((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of result to correspond to the `i1` equivalent of the operand");
  return ::mlir::success();
}

::mlir::LogicalResult ULessThanEqualOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult ULessThanEqualOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operand1RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand1Operands(operand1RawOperands);  ::llvm::SMLoc operand1OperandsLoc;
  (void)operand1OperandsLoc;
  ::mlir::OpAsmParser::OperandType operand2RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand2Operands(operand2RawOperands);  ::llvm::SMLoc operand2OperandsLoc;
  (void)operand2OperandsLoc;
  ::mlir::Type operand1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand1Types(operand1RawTypes);

  operand1OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand1RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  operand2OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand2RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand1RawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  for (::mlir::Type type : operand1Types) {
    (void)type;
    if (!((((type.isInteger(8))) || ((type.isInteger(16))) || ((type.isInteger(32))) || ((type.isInteger(64)))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isInteger(8))) || ((elementType.isInteger(16))) || ((elementType.isInteger(32))) || ((elementType.isInteger(64))); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
      return parser.emitError(parser.getNameLoc()) << "'operand1' must be 8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(getUnaryOpResultType(operand1Types[0]));
  if (parser.resolveOperands(operand1Operands, operand1Types, operand1OperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(operand2Operands, operand1Types[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ULessThanEqualOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand1();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << operand2();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand1().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void ULessThanEqualOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::ULessThanEqualOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::ULessThanOp definitions
//===----------------------------------------------------------------------===//

ULessThanOpAdaptor::ULessThanOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

ULessThanOpAdaptor::ULessThanOpAdaptor(ULessThanOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange ULessThanOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ULessThanOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ULessThanOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ULessThanOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value ULessThanOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr ULessThanOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult ULessThanOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> ULessThanOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ULessThanOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ULessThanOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value ULessThanOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange ULessThanOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange ULessThanOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> ULessThanOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ULessThanOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ULessThanOp::result() {
  return *getODSResults(0).begin();
}

void ULessThanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value lhs, Value rhs) {
::buildLogicalBinaryOp(odsBuilder, odsState, lhs, rhs);
}

void ULessThanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void ULessThanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ULessThanOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ULessThanOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(getUnaryOpResultType((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of result to correspond to the `i1` equivalent of the operand");
  return ::mlir::success();
}

::mlir::LogicalResult ULessThanOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult ULessThanOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operand1RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand1Operands(operand1RawOperands);  ::llvm::SMLoc operand1OperandsLoc;
  (void)operand1OperandsLoc;
  ::mlir::OpAsmParser::OperandType operand2RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand2Operands(operand2RawOperands);  ::llvm::SMLoc operand2OperandsLoc;
  (void)operand2OperandsLoc;
  ::mlir::Type operand1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand1Types(operand1RawTypes);

  operand1OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand1RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  operand2OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand2RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand1RawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  for (::mlir::Type type : operand1Types) {
    (void)type;
    if (!((((type.isInteger(8))) || ((type.isInteger(16))) || ((type.isInteger(32))) || ((type.isInteger(64)))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isInteger(8))) || ((elementType.isInteger(16))) || ((elementType.isInteger(32))) || ((elementType.isInteger(64))); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
      return parser.emitError(parser.getNameLoc()) << "'operand1' must be 8/16/32/64-bit integer or vector of 8/16/32/64-bit integer values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(getUnaryOpResultType(operand1Types[0]));
  if (parser.resolveOperands(operand1Operands, operand1Types, operand1OperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(operand2Operands, operand1Types[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ULessThanOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand1();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << operand2();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand1().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void ULessThanOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::ULessThanOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::UModOp definitions
//===----------------------------------------------------------------------===//

UModOpAdaptor::UModOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

UModOpAdaptor::UModOpAdaptor(UModOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange UModOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> UModOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange UModOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UModOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value UModOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr UModOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult UModOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> UModOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range UModOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UModOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value UModOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange UModOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange UModOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> UModOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range UModOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UModOp::result() {
  return *getODSResults(0).begin();
}

void UModOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void UModOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UModOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void UModOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes({operand1.getType()});

}

void UModOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult UModOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps10(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps10(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps10(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult UModOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult UModOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const ::mlir::Type>(::llvm::ArrayRef<::mlir::Type>(resultTypes), ::llvm::ArrayRef<::mlir::Type>(resultTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void UModOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getOperation()->getOperands();
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void UModOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::UModOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::UndefOp definitions
//===----------------------------------------------------------------------===//

UndefOpAdaptor::UndefOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

UndefOpAdaptor::UndefOpAdaptor(UndefOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange UndefOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> UndefOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange UndefOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr UndefOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult UndefOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> UndefOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range UndefOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> UndefOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range UndefOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UndefOp::result() {
  return *getODSResults(0).begin();
}

void UndefOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result) {
  odsState.addTypes(result);
}

void UndefOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes) {
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UndefOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult UndefOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps7(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult UndefOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult UndefOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  return ::mlir::success();
}

void UndefOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::UndefOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::UnorderedOp definitions
//===----------------------------------------------------------------------===//

UnorderedOpAdaptor::UnorderedOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

UnorderedOpAdaptor::UnorderedOpAdaptor(UnorderedOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange UnorderedOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> UnorderedOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange UnorderedOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UnorderedOpAdaptor::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value UnorderedOpAdaptor::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr UnorderedOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult UnorderedOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> UnorderedOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range UnorderedOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UnorderedOp::operand1() {
  return *getODSOperands(0).begin();
}

::mlir::Value UnorderedOp::operand2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange UnorderedOp::operand1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange UnorderedOp::operand2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> UnorderedOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range UnorderedOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UnorderedOp::result() {
  return *getODSResults(0).begin();
}

void UnorderedOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value lhs, Value rhs) {
::buildLogicalBinaryOp(odsBuilder, odsState, lhs, rhs);
}

void UnorderedOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  odsState.addTypes(result);
}

void UnorderedOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand1, ::mlir::Value operand2) {
  odsState.addOperands(operand1);
  odsState.addOperands(operand2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UnorderedOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult UnorderedOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps13(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps14(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()(getUnaryOpResultType((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of result to correspond to the `i1` equivalent of the operand");
  return ::mlir::success();
}

::mlir::LogicalResult UnorderedOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult UnorderedOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operand1RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand1Operands(operand1RawOperands);  ::llvm::SMLoc operand1OperandsLoc;
  (void)operand1OperandsLoc;
  ::mlir::OpAsmParser::OperandType operand2RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operand2Operands(operand2RawOperands);  ::llvm::SMLoc operand2OperandsLoc;
  (void)operand2OperandsLoc;
  ::mlir::Type operand1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operand1Types(operand1RawTypes);

  operand1OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand1RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  operand2OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operand2RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operand1RawTypes[0] = type;
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  for (::mlir::Type type : operand1Types) {
    (void)type;
    if (!((((type.isF16())) || ((type.isF32())) || ((type.isF64()))) || (((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isF16())) || ((elementType.isF32())) || ((elementType.isF64())); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16))))))) {
      return parser.emitError(parser.getNameLoc()) << "'operand1' must be 16/32/64-bit float or vector of 16/32/64-bit float values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(getUnaryOpResultType(operand1Types[0]));
  if (parser.resolveOperands(operand1Operands, operand1Types, operand1OperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(operand2Operands, operand1Types[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void UnorderedOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << operand1();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << operand2();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand1().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void UnorderedOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::UnorderedOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::UnreachableOp definitions
//===----------------------------------------------------------------------===//

UnreachableOpAdaptor::UnreachableOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

UnreachableOpAdaptor::UnreachableOpAdaptor(UnreachableOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange UnreachableOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> UnreachableOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange UnreachableOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr UnreachableOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult UnreachableOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> UnreachableOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range UnreachableOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> UnreachableOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range UnreachableOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void UnreachableOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState) {
}

void UnreachableOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes) {
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UnreachableOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult UnreachableOp::verifyInvariantsImpl() {
  if (!((isNestedInFunctionOpInterface((*this->getOperation()).getParentOp()))))
    return emitOpError("failed to verify that op must appear in a function-like op's block");
  return ::mlir::success();
}

::mlir::LogicalResult UnreachableOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult UnreachableOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  return ::mlir::success();
}

void UnreachableOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::UnreachableOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::VariableOp definitions
//===----------------------------------------------------------------------===//

VariableOpAdaptor::VariableOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

VariableOpAdaptor::VariableOpAdaptor(VariableOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange VariableOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> VariableOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange VariableOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value VariableOpAdaptor::initializer() {
  auto operands = getODSOperands(0);
  return operands.empty() ? ::mlir::Value() : *operands.begin();
}

::mlir::DictionaryAttr VariableOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::spirv::StorageClassAttr VariableOpAdaptor::storage_classAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::spirv::StorageClassAttr attr = odsAttrs.get("storage_class").cast<::mlir::spirv::StorageClassAttr>();
  return attr;
}

::mlir::spirv::StorageClass VariableOpAdaptor::storage_class() {
  auto attr = storage_classAttr();
  return attr.getValue();
}

::mlir::LogicalResult VariableOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_storage_class = odsAttrs.get("storage_class");
    if (!tblgen_storage_class)
      return emitError(loc, "'spv.Variable' op ""requires attribute 'storage_class'");

    if (tblgen_storage_class && !((((tblgen_storage_class.isa<::mlir::IntegerAttr>())) && ((tblgen_storage_class.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((::mlir::spirv::symbolizeStorageClass(tblgen_storage_class.cast<IntegerAttr>().getValue().getZExtValue()).hasValue()))))
      return emitError(loc, "'spv.Variable' op ""attribute 'storage_class' failed to satisfy constraint: valid SPIR-V StorageClass");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> VariableOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range VariableOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value VariableOp::initializer() {
  auto operands = getODSOperands(0);
  return operands.empty() ? ::mlir::Value() : *operands.begin();
}

::mlir::MutableOperandRange VariableOp::initializerMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> VariableOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range VariableOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value VariableOp::pointer() {
  return *getODSResults(0).begin();
}

::mlir::spirv::StorageClassAttr VariableOp::storage_classAttr() {
  return (*this)->getAttr(storage_classAttrName()).cast<::mlir::spirv::StorageClassAttr>();
}

::mlir::spirv::StorageClass VariableOp::storage_class() {
  auto attr = storage_classAttr();
  return attr.getValue();
}

void VariableOp::storage_classAttr(::mlir::spirv::StorageClassAttr attr) {
  (*this)->setAttr(storage_classAttrName(), attr);
}

void VariableOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type pointer, ::mlir::spirv::StorageClassAttr storage_class, /*optional*/::mlir::Value initializer) {
  if (initializer)
    odsState.addOperands(initializer);
  odsState.addAttribute(storage_classAttrName(odsState.name), storage_class);
  odsState.addTypes(pointer);
}

void VariableOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::StorageClassAttr storage_class, /*optional*/::mlir::Value initializer) {
  if (initializer)
    odsState.addOperands(initializer);
  odsState.addAttribute(storage_classAttrName(odsState.name), storage_class);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void VariableOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type pointer, ::mlir::spirv::StorageClass storage_class, /*optional*/::mlir::Value initializer) {
  if (initializer)
    odsState.addOperands(initializer);
  odsState.addAttribute(storage_classAttrName(odsState.name), ::mlir::spirv::StorageClassAttr::get(odsBuilder.getContext(), storage_class));
  odsState.addTypes(pointer);
}

void VariableOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::spirv::StorageClass storage_class, /*optional*/::mlir::Value initializer) {
  if (initializer)
    odsState.addOperands(initializer);
  odsState.addAttribute(storage_classAttrName(odsState.name), ::mlir::spirv::StorageClassAttr::get(odsBuilder.getContext(), storage_class));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void VariableOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult VariableOp::verifyInvariantsImpl() {
  {
    auto tblgen_storage_class = (*this)->getAttr(storage_classAttrName());
    if (!tblgen_storage_class)
      return emitOpError("requires attribute 'storage_class'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps20(*this, tblgen_storage_class, "storage_class")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    if (valueGroup0.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup0.size();
    }

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps25(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps0(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult VariableOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::VariableOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::VectorExtractDynamicOp definitions
//===----------------------------------------------------------------------===//

VectorExtractDynamicOpAdaptor::VectorExtractDynamicOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

VectorExtractDynamicOpAdaptor::VectorExtractDynamicOpAdaptor(VectorExtractDynamicOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange VectorExtractDynamicOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> VectorExtractDynamicOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange VectorExtractDynamicOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value VectorExtractDynamicOpAdaptor::vector() {
  return *getODSOperands(0).begin();
}

::mlir::Value VectorExtractDynamicOpAdaptor::index() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr VectorExtractDynamicOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult VectorExtractDynamicOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> VectorExtractDynamicOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range VectorExtractDynamicOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value VectorExtractDynamicOp::vector() {
  return *getODSOperands(0).begin();
}

::mlir::Value VectorExtractDynamicOp::index() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange VectorExtractDynamicOp::vectorMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange VectorExtractDynamicOp::indexMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> VectorExtractDynamicOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range VectorExtractDynamicOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value VectorExtractDynamicOp::result() {
  return *getODSResults(0).begin();
}

void VectorExtractDynamicOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value vector, ::mlir::Value index) {
  odsState.addOperands(vector);
  odsState.addOperands(index);
  odsState.addTypes(result);
}

void VectorExtractDynamicOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value vector, ::mlir::Value index) {
  odsState.addOperands(vector);
  odsState.addOperands(index);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void VectorExtractDynamicOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult VectorExtractDynamicOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps21(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps27(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()((*this->getODSOperands(0).begin()).getType().cast<mlir::VectorType>().getElementType(), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that type of 'result' matches element type of 'vector'");
  return ::mlir::success();
}

::mlir::LogicalResult VectorExtractDynamicOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult VectorExtractDynamicOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType vectorRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> vectorOperands(vectorRawOperands);  ::llvm::SMLoc vectorOperandsLoc;
  (void)vectorOperandsLoc;
  ::mlir::OpAsmParser::OperandType indexRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> indexOperands(indexRawOperands);  ::llvm::SMLoc indexOperandsLoc;
  (void)indexOperandsLoc;
  ::mlir::Type vectorRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> vectorTypes(vectorRawTypes);
  ::mlir::Type indexRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> indexTypes(indexRawTypes);

  vectorOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(vectorRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseLSquare())
    return ::mlir::failure();

  indexOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(indexRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseRSquare())
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::VectorType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    vectorRawTypes[0] = type;
  }
  if (parser.parseComma())
    return ::mlir::failure();

  {
    ::mlir::IntegerType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    indexRawTypes[0] = type;
  }
  for (::mlir::Type type : vectorTypes) {
    (void)type;
    if (!(((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isSignlessInteger(1))) || (((elementType.isInteger(8))) || ((elementType.isInteger(16))) || ((elementType.isInteger(32))) || ((elementType.isInteger(64)))) || (((elementType.isF16())) || ((elementType.isF32())) || ((elementType.isF64()))); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16)))))) {
      return parser.emitError(parser.getNameLoc()) << "'vector' must be vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(vectorTypes[0].cast<mlir::VectorType>().getElementType());
  if (parser.resolveOperands(vectorOperands, vectorTypes, vectorOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(indexOperands, indexTypes, indexOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void VectorExtractDynamicOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << vector();
  _odsPrinter << "[";
  _odsPrinter << index();
  _odsPrinter << "]";
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = vector().getType();
    if (auto validType = type.dyn_cast<::mlir::VectorType>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';
  {
    auto type = index().getType();
    if (auto validType = type.dyn_cast<::mlir::IntegerType>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void VectorExtractDynamicOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::VectorExtractDynamicOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::VectorInsertDynamicOp definitions
//===----------------------------------------------------------------------===//

VectorInsertDynamicOpAdaptor::VectorInsertDynamicOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

VectorInsertDynamicOpAdaptor::VectorInsertDynamicOpAdaptor(VectorInsertDynamicOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange VectorInsertDynamicOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> VectorInsertDynamicOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange VectorInsertDynamicOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value VectorInsertDynamicOpAdaptor::vector() {
  return *getODSOperands(0).begin();
}

::mlir::Value VectorInsertDynamicOpAdaptor::component() {
  return *getODSOperands(1).begin();
}

::mlir::Value VectorInsertDynamicOpAdaptor::index() {
  return *getODSOperands(2).begin();
}

::mlir::DictionaryAttr VectorInsertDynamicOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult VectorInsertDynamicOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> VectorInsertDynamicOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range VectorInsertDynamicOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value VectorInsertDynamicOp::vector() {
  return *getODSOperands(0).begin();
}

::mlir::Value VectorInsertDynamicOp::component() {
  return *getODSOperands(1).begin();
}

::mlir::Value VectorInsertDynamicOp::index() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange VectorInsertDynamicOp::vectorMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange VectorInsertDynamicOp::componentMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange VectorInsertDynamicOp::indexMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> VectorInsertDynamicOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range VectorInsertDynamicOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value VectorInsertDynamicOp::result() {
  return *getODSResults(0).begin();
}

void VectorInsertDynamicOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value vector, ::mlir::Value component, ::mlir::Value index) {
  odsState.addOperands(vector);
  odsState.addOperands(component);
  odsState.addOperands(index);
  odsState.addTypes(result);
}

void VectorInsertDynamicOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value vector, ::mlir::Value component, ::mlir::Value index) {
  odsState.addOperands(vector);
  odsState.addOperands(component);
  odsState.addOperands(index);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (::mlir::succeeded(VectorInsertDynamicOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      /*regions=*/{}, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void VectorInsertDynamicOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value vector, ::mlir::Value component, ::mlir::Value index) {
  odsState.addOperands(vector);
  odsState.addOperands(component);
  odsState.addOperands(index);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void VectorInsertDynamicOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void VectorInsertDynamicOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

  ::mlir::SmallVector<::mlir::Type, 2> inferredReturnTypes;
  if (::mlir::succeeded(VectorInsertDynamicOp::inferReturnTypes(odsBuilder.getContext(),
          odsState.location, operands,
          odsState.attributes.getDictionary(odsState.getContext()),
          odsState.regions, inferredReturnTypes))) {
    assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
    odsState.addTypes(inferredReturnTypes);
  } else {
    ::llvm::report_fatal_error("Failed to infer result type(s).");
  }
}

::mlir::LogicalResult VectorInsertDynamicOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps21(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps27(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps21(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((std::equal_to<>()((*this->getODSOperands(0).begin()).getType().cast<mlir::VectorType>().getElementType(), (*this->getODSOperands(1).begin()).getType()))))
    return emitOpError("failed to verify that type of 'component' matches element type of 'vector'");
  if (!((::llvm::is_splat(::llvm::makeArrayRef({(*this->getODSOperands(0).begin()).getType(), (*this->getODSResults(0).begin()).getType()})))))
    return emitOpError("failed to verify that all of {vector, result} have same type");
  return ::mlir::success();
}

::mlir::LogicalResult VectorInsertDynamicOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::LogicalResult VectorInsertDynamicOp::inferReturnTypes(::mlir::MLIRContext *context, ::llvm::Optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  inferredReturnTypes[0] = operands[0].getType();
  return ::mlir::success();
}

::mlir::ParseResult VectorInsertDynamicOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType componentRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> componentOperands(componentRawOperands);  ::llvm::SMLoc componentOperandsLoc;
  (void)componentOperandsLoc;
  ::mlir::OpAsmParser::OperandType vectorRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> vectorOperands(vectorRawOperands);  ::llvm::SMLoc vectorOperandsLoc;
  (void)vectorOperandsLoc;
  ::mlir::OpAsmParser::OperandType indexRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> indexOperands(indexRawOperands);  ::llvm::SMLoc indexOperandsLoc;
  (void)indexOperandsLoc;
  ::mlir::Type vectorRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> vectorTypes(vectorRawTypes);
  ::mlir::Type indexRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> indexTypes(indexRawTypes);

  componentOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(componentRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  vectorOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(vectorRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseLSquare())
    return ::mlir::failure();

  indexOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(indexRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseRSquare())
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::VectorType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    vectorRawTypes[0] = type;
  }
  if (parser.parseComma())
    return ::mlir::failure();

  {
    ::mlir::IntegerType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    indexRawTypes[0] = type;
  }
  for (::mlir::Type type : vectorTypes) {
    (void)type;
    if (!(((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && ([](::mlir::Type elementType) { return ((elementType.isSignlessInteger(1))) || (((elementType.isInteger(8))) || ((elementType.isInteger(16))) || ((elementType.isInteger(32))) || ((elementType.isInteger(64)))) || (((elementType.isF16())) || ((elementType.isF32())) || ((elementType.isF64()))); }(type.cast<::mlir::ShapedType>().getElementType()))) && ((((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank() > 0))) && (((type.cast<::mlir::VectorType>().getNumElements()
                           == 2)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 3)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 4)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 8)) || ((type.cast<::mlir::VectorType>().getNumElements()
                           == 16)))))) {
      return parser.emitError(parser.getNameLoc()) << "'vector' must be vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float values of length 2/3/4/8/16, but got " << type;
    }
  }
  result.addTypes(vectorTypes);
  if (parser.resolveOperands(vectorOperands, vectorTypes, vectorOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(componentOperands, vectorTypes[0].cast<mlir::VectorType>().getElementType(), componentOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(indexOperands, indexTypes, indexOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void VectorInsertDynamicOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << component();
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << vector();
  _odsPrinter << "[";
  _odsPrinter << index();
  _odsPrinter << "]";
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = vector().getType();
    if (auto validType = type.dyn_cast<::mlir::VectorType>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';
  {
    auto type = index().getType();
    if (auto validType = type.dyn_cast<::mlir::IntegerType>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void VectorInsertDynamicOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::VectorInsertDynamicOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::VectorShuffleOp definitions
//===----------------------------------------------------------------------===//

VectorShuffleOpAdaptor::VectorShuffleOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

VectorShuffleOpAdaptor::VectorShuffleOpAdaptor(VectorShuffleOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange VectorShuffleOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> VectorShuffleOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange VectorShuffleOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value VectorShuffleOpAdaptor::vector1() {
  return *getODSOperands(0).begin();
}

::mlir::Value VectorShuffleOpAdaptor::vector2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr VectorShuffleOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::ArrayAttr VectorShuffleOpAdaptor::componentsAttr() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("components").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr VectorShuffleOpAdaptor::components() {
  auto attr = componentsAttr();
  return attr;
}

::mlir::LogicalResult VectorShuffleOpAdaptor::verify(::mlir::Location loc) {
  {
    auto tblgen_components = odsAttrs.get("components");
    if (!tblgen_components)
      return emitError(loc, "'spv.VectorShuffle' op ""requires attribute 'components'");

    if (tblgen_components && !(((tblgen_components.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_components.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32))); }))))
      return emitError(loc, "'spv.VectorShuffle' op ""attribute 'components' failed to satisfy constraint: 32-bit integer array attribute");
  }
  return ::mlir::success();
}

std::pair<unsigned, unsigned> VectorShuffleOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range VectorShuffleOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value VectorShuffleOp::vector1() {
  return *getODSOperands(0).begin();
}

::mlir::Value VectorShuffleOp::vector2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange VectorShuffleOp::vector1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

::mlir::MutableOperandRange VectorShuffleOp::vector2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> VectorShuffleOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range VectorShuffleOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value VectorShuffleOp::result() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr VectorShuffleOp::componentsAttr() {
  return (*this)->getAttr(componentsAttrName()).cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr VectorShuffleOp::components() {
  auto attr = componentsAttr();
  return attr;
}

void VectorShuffleOp::componentsAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(componentsAttrName(), attr);
}

void VectorShuffleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value vector1, ::mlir::Value vector2, ::mlir::ArrayAttr components) {
  odsState.addOperands(vector1);
  odsState.addOperands(vector2);
  odsState.addAttribute(componentsAttrName(odsState.name), components);
  odsState.addTypes(result);
}

void VectorShuffleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value vector1, ::mlir::Value vector2, ::mlir::ArrayAttr components) {
  odsState.addOperands(vector1);
  odsState.addOperands(vector2);
  odsState.addAttribute(componentsAttrName(odsState.name), components);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void VectorShuffleOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult VectorShuffleOp::verifyInvariantsImpl() {
  {
    auto tblgen_components = (*this)->getAttr(componentsAttrName());
    if (!tblgen_components)
      return emitOpError("requires attribute 'components'");

    if (::mlir::failed(__mlir_ods_local_attr_constraint_SPIRVOps3(*this, tblgen_components, "components")))
      return ::mlir::failure();
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps21(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps21(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps21(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  if (!((::llvm::is_splat(::llvm::makeArrayRef({getElementTypeOrSelf((*this->getODSOperands(0).begin())), getElementTypeOrSelf((*this->getODSOperands(1).begin())), getElementTypeOrSelf((*this->getODSResults(0).begin()))})))))
    return emitOpError("failed to verify that all of {vector1, vector2, result} have same element type");
  return ::mlir::success();
}

::mlir::LogicalResult VectorShuffleOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult VectorShuffleOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::ArrayAttr componentsAttr;
  ::mlir::OpAsmParser::OperandType vector1RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> vector1Operands(vector1RawOperands);  ::llvm::SMLoc vector1OperandsLoc;
  (void)vector1OperandsLoc;
  ::mlir::Type vector1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> vector1Types(vector1RawTypes);
  ::mlir::OpAsmParser::OperandType vector2RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> vector2Operands(vector2RawOperands);  ::llvm::SMLoc vector2OperandsLoc;
  (void)vector2OperandsLoc;
  ::mlir::Type vector2RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> vector2Types(vector2RawTypes);
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();

  if (parser.parseCustomAttributeWithFallback(componentsAttr, parser.getBuilder().getType<::mlir::NoneType>(), "components",
          result.attributes)) {
    return ::mlir::failure();
  }

  vector1OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(vector1RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::VectorType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    vector1RawTypes[0] = type;
  }
  if (parser.parseComma())
    return ::mlir::failure();

  vector2OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(vector2RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::VectorType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    vector2RawTypes[0] = type;
  }
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::VectorType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    resultRawTypes[0] = type;
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(vector1Operands, vector1Types, vector1OperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(vector2Operands, vector2Types, vector2OperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void VectorShuffleOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"components"});
  _odsPrinter << ' ';
  _odsPrinter.printAttributeWithoutType(componentsAttr());
  _odsPrinter << ' ';
  _odsPrinter << vector1();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = vector1().getType();
    if (auto validType = type.dyn_cast<::mlir::VectorType>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter << vector2();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = vector2().getType();
    if (auto validType = type.dyn_cast<::mlir::VectorType>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ' << "->";
  _odsPrinter << ' ';
  {
    auto type = result().getType();
    if (auto validType = type.dyn_cast<::mlir::VectorType>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void VectorShuffleOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::VectorShuffleOp)

namespace mlir {
namespace spirv {

//===----------------------------------------------------------------------===//
// ::mlir::spirv::YieldOp definitions
//===----------------------------------------------------------------------===//

YieldOpAdaptor::YieldOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions) : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {}

YieldOpAdaptor::YieldOpAdaptor(YieldOp &op) : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {}

::mlir::ValueRange YieldOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> YieldOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange YieldOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value YieldOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr YieldOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult YieldOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> YieldOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range YieldOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value YieldOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange YieldOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

std::pair<unsigned, unsigned> YieldOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range YieldOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void YieldOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
}

void YieldOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void YieldOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult YieldOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_SPIRVOps25(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult YieldOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult YieldOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    operandRawTypes[0] = type;
  }
  if (parser.resolveOperands(operandOperands, operandTypes, operandOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void YieldOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  _odsPrinter << ' ';
  _odsPrinter << operand();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = operand().getType();
    if (auto validType = type.dyn_cast<::mlir::Type>())
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
}

void YieldOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace spirv
} // namespace mlir
DEFINE_EXPLICIT_TYPE_ID(::mlir::spirv::YieldOp)


#endif  // GET_OP_CLASSES

