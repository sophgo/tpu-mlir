/* Autogenerated by mlir-tblgen; don't manually edit */

//===----------------------------------------------------------------------===//
// ConvertElementwiseToLinalg
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTELEMENTWISETOLINALG
#undef GEN_PASS_DECL_CONVERTELEMENTWISETOLINALG
#endif // GEN_PASS_DECL_CONVERTELEMENTWISETOLINALG
#ifdef GEN_PASS_DEF_CONVERTELEMENTWISETOLINALG
namespace impl {

template <typename DerivedT>
class ConvertElementwiseToLinalgBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertElementwiseToLinalgBase;

  ConvertElementwiseToLinalgBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertElementwiseToLinalgBase(const ConvertElementwiseToLinalgBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-elementwise-to-linalg");
  }
  ::llvm::StringRef getArgument() const override { return "convert-elementwise-to-linalg"; }

  ::llvm::StringRef getDescription() const override { return "Convert ElementwiseMappable ops to linalg"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertElementwiseToLinalg");
  }
  ::llvm::StringRef getName() const override { return "ConvertElementwiseToLinalg"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<linalg::LinalgDialect>();

  registry.insert<memref::MemRefDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertElementwiseToLinalgBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTELEMENTWISETOLINALG
#endif // GEN_PASS_DEF_CONVERTELEMENTWISETOLINALG

//===----------------------------------------------------------------------===//
// LinalgBufferize
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LINALGBUFFERIZE
#undef GEN_PASS_DECL_LINALGBUFFERIZE
#endif // GEN_PASS_DECL_LINALGBUFFERIZE
#ifdef GEN_PASS_DEF_LINALGBUFFERIZE
namespace impl {

template <typename DerivedT>
class LinalgBufferizeBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LinalgBufferizeBase;

  LinalgBufferizeBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgBufferizeBase(const LinalgBufferizeBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-bufferize");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-bufferize"; }

  ::llvm::StringRef getDescription() const override { return "Bufferize the linalg dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgBufferize");
  }
  ::llvm::StringRef getName() const override { return "LinalgBufferize"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<AffineDialect>();

  registry.insert<bufferization::BufferizationDialect>();

  registry.insert<linalg::LinalgDialect>();

  registry.insert<memref::MemRefDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgBufferizeBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LINALGBUFFERIZE
#endif // GEN_PASS_DEF_LINALGBUFFERIZE

//===----------------------------------------------------------------------===//
// LinalgDetensorize
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LINALGDETENSORIZE
struct LinalgDetensorizeOptions {
  bool aggressiveMode = false;
};
#undef GEN_PASS_DECL_LINALGDETENSORIZE
#endif // GEN_PASS_DECL_LINALGDETENSORIZE
#ifdef GEN_PASS_DEF_LINALGDETENSORIZE
namespace impl {

template <typename DerivedT>
class LinalgDetensorizeBase : public ::mlir::OperationPass<> {
public:
  using Base = LinalgDetensorizeBase;

  LinalgDetensorizeBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgDetensorizeBase(const LinalgDetensorizeBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-detensorize");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-detensorize"; }

  ::llvm::StringRef getDescription() const override { return "Detensorize linalg ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgDetensorize");
  }
  ::llvm::StringRef getName() const override { return "LinalgDetensorize"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgDetensorizeBase<DerivedT>)

  LinalgDetensorizeBase(const LinalgDetensorizeOptions &options) : LinalgDetensorizeBase() {
    aggressiveMode = options.aggressiveMode;
  }
protected:
  ::mlir::Pass::Option<bool> aggressiveMode{*this, "aggressive-mode", ::llvm::cl::desc("Detensorize all ops that qualify for detensoring along with branch operands and basic-block arguments."), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LINALGDETENSORIZE
#endif // GEN_PASS_DEF_LINALGDETENSORIZE

//===----------------------------------------------------------------------===//
// LinalgElementwiseOpFusion
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LINALGELEMENTWISEOPFUSION
#undef GEN_PASS_DECL_LINALGELEMENTWISEOPFUSION
#endif // GEN_PASS_DECL_LINALGELEMENTWISEOPFUSION
#ifdef GEN_PASS_DEF_LINALGELEMENTWISEOPFUSION
namespace impl {

template <typename DerivedT>
class LinalgElementwiseOpFusionBase : public ::mlir::OperationPass<> {
public:
  using Base = LinalgElementwiseOpFusionBase;

  LinalgElementwiseOpFusionBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgElementwiseOpFusionBase(const LinalgElementwiseOpFusionBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-fuse-elementwise-ops");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-fuse-elementwise-ops"; }

  ::llvm::StringRef getDescription() const override { return "Fuse elementwise operations on tensors"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgElementwiseOpFusion");
  }
  ::llvm::StringRef getName() const override { return "LinalgElementwiseOpFusion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<AffineDialect>();

  registry.insert<linalg::LinalgDialect>();

  registry.insert<memref::MemRefDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgElementwiseOpFusionBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LINALGELEMENTWISEOPFUSION
#endif // GEN_PASS_DEF_LINALGELEMENTWISEOPFUSION

//===----------------------------------------------------------------------===//
// LinalgFoldUnitExtentDims
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LINALGFOLDUNITEXTENTDIMS
struct LinalgFoldUnitExtentDimsOptions {
  bool foldOneTripLoopsOnly = false;
};
#undef GEN_PASS_DECL_LINALGFOLDUNITEXTENTDIMS
#endif // GEN_PASS_DECL_LINALGFOLDUNITEXTENTDIMS
#ifdef GEN_PASS_DEF_LINALGFOLDUNITEXTENTDIMS
namespace impl {

template <typename DerivedT>
class LinalgFoldUnitExtentDimsBase : public ::mlir::OperationPass<> {
public:
  using Base = LinalgFoldUnitExtentDimsBase;

  LinalgFoldUnitExtentDimsBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgFoldUnitExtentDimsBase(const LinalgFoldUnitExtentDimsBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-fold-unit-extent-dims");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-fold-unit-extent-dims"; }

  ::llvm::StringRef getDescription() const override { return "Remove unit-extent dimension in Linalg ops on tensors"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgFoldUnitExtentDims");
  }
  ::llvm::StringRef getName() const override { return "LinalgFoldUnitExtentDims"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<linalg::LinalgDialect>();

  registry.insert<AffineDialect>();

  registry.insert<memref::MemRefDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgFoldUnitExtentDimsBase<DerivedT>)

  LinalgFoldUnitExtentDimsBase(const LinalgFoldUnitExtentDimsOptions &options) : LinalgFoldUnitExtentDimsBase() {
    foldOneTripLoopsOnly = options.foldOneTripLoopsOnly;
  }
protected:
  ::mlir::Pass::Option<bool> foldOneTripLoopsOnly{*this, "fold-one-trip-loops-only", ::llvm::cl::desc("Only folds the one-trip loops from Linalg ops on tensors (for testing purposes only)"), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LINALGFOLDUNITEXTENTDIMS
#endif // GEN_PASS_DEF_LINALGFOLDUNITEXTENTDIMS

//===----------------------------------------------------------------------===//
// LinalgGeneralization
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LINALGGENERALIZATION
#undef GEN_PASS_DECL_LINALGGENERALIZATION
#endif // GEN_PASS_DECL_LINALGGENERALIZATION
#ifdef GEN_PASS_DEF_LINALGGENERALIZATION
namespace impl {

template <typename DerivedT>
class LinalgGeneralizationBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LinalgGeneralizationBase;

  LinalgGeneralizationBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgGeneralizationBase(const LinalgGeneralizationBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-generalize-named-ops");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-generalize-named-ops"; }

  ::llvm::StringRef getDescription() const override { return "Convert named ops into generic ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgGeneralization");
  }
  ::llvm::StringRef getName() const override { return "LinalgGeneralization"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<linalg::LinalgDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgGeneralizationBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LINALGGENERALIZATION
#endif // GEN_PASS_DEF_LINALGGENERALIZATION

//===----------------------------------------------------------------------===//
// LinalgInitTensorToAllocTensor
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LINALGINITTENSORTOALLOCTENSOR
#undef GEN_PASS_DECL_LINALGINITTENSORTOALLOCTENSOR
#endif // GEN_PASS_DECL_LINALGINITTENSORTOALLOCTENSOR
#ifdef GEN_PASS_DEF_LINALGINITTENSORTOALLOCTENSOR
namespace impl {

template <typename DerivedT>
class LinalgInitTensorToAllocTensorBase : public ::mlir::OperationPass<> {
public:
  using Base = LinalgInitTensorToAllocTensorBase;

  LinalgInitTensorToAllocTensorBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgInitTensorToAllocTensorBase(const LinalgInitTensorToAllocTensorBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-init-tensor-to-alloc-tensor");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-init-tensor-to-alloc-tensor"; }

  ::llvm::StringRef getDescription() const override { return "Replace all init_tensor ops by alloc_tensor ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgInitTensorToAllocTensor");
  }
  ::llvm::StringRef getName() const override { return "LinalgInitTensorToAllocTensor"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgInitTensorToAllocTensorBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LINALGINITTENSORTOALLOCTENSOR
#endif // GEN_PASS_DEF_LINALGINITTENSORTOALLOCTENSOR

//===----------------------------------------------------------------------===//
// LinalgInlineScalarOperands
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LINALGINLINESCALAROPERANDS
#undef GEN_PASS_DECL_LINALGINLINESCALAROPERANDS
#endif // GEN_PASS_DECL_LINALGINLINESCALAROPERANDS
#ifdef GEN_PASS_DEF_LINALGINLINESCALAROPERANDS
namespace impl {

template <typename DerivedT>
class LinalgInlineScalarOperandsBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LinalgInlineScalarOperandsBase;

  LinalgInlineScalarOperandsBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgInlineScalarOperandsBase(const LinalgInlineScalarOperandsBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-inline-scalar-operands");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-inline-scalar-operands"; }

  ::llvm::StringRef getDescription() const override { return "Inline scalar operands into linalg generic ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgInlineScalarOperands");
  }
  ::llvm::StringRef getName() const override { return "LinalgInlineScalarOperands"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<linalg::LinalgDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgInlineScalarOperandsBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LINALGINLINESCALAROPERANDS
#endif // GEN_PASS_DEF_LINALGINLINESCALAROPERANDS

//===----------------------------------------------------------------------===//
// LinalgLowerToAffineLoops
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LINALGLOWERTOAFFINELOOPS
#undef GEN_PASS_DECL_LINALGLOWERTOAFFINELOOPS
#endif // GEN_PASS_DECL_LINALGLOWERTOAFFINELOOPS
#ifdef GEN_PASS_DEF_LINALGLOWERTOAFFINELOOPS
namespace impl {

template <typename DerivedT>
class LinalgLowerToAffineLoopsBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LinalgLowerToAffineLoopsBase;

  LinalgLowerToAffineLoopsBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgLowerToAffineLoopsBase(const LinalgLowerToAffineLoopsBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-linalg-to-affine-loops");
  }
  ::llvm::StringRef getArgument() const override { return "convert-linalg-to-affine-loops"; }

  ::llvm::StringRef getDescription() const override { return "Lower the operations from the linalg dialect into affine loops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgLowerToAffineLoops");
  }
  ::llvm::StringRef getName() const override { return "LinalgLowerToAffineLoops"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<AffineDialect>();

  registry.insert<linalg::LinalgDialect>();

  registry.insert<memref::MemRefDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgLowerToAffineLoopsBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LINALGLOWERTOAFFINELOOPS
#endif // GEN_PASS_DEF_LINALGLOWERTOAFFINELOOPS

//===----------------------------------------------------------------------===//
// LinalgLowerToLoops
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LINALGLOWERTOLOOPS
#undef GEN_PASS_DECL_LINALGLOWERTOLOOPS
#endif // GEN_PASS_DECL_LINALGLOWERTOLOOPS
#ifdef GEN_PASS_DEF_LINALGLOWERTOLOOPS
namespace impl {

template <typename DerivedT>
class LinalgLowerToLoopsBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LinalgLowerToLoopsBase;

  LinalgLowerToLoopsBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgLowerToLoopsBase(const LinalgLowerToLoopsBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-linalg-to-loops");
  }
  ::llvm::StringRef getArgument() const override { return "convert-linalg-to-loops"; }

  ::llvm::StringRef getDescription() const override { return "Lower the operations from the linalg dialect into loops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgLowerToLoops");
  }
  ::llvm::StringRef getName() const override { return "LinalgLowerToLoops"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<linalg::LinalgDialect>();

  registry.insert<scf::SCFDialect>();

  registry.insert<AffineDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgLowerToLoopsBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LINALGLOWERTOLOOPS
#endif // GEN_PASS_DEF_LINALGLOWERTOLOOPS

//===----------------------------------------------------------------------===//
// LinalgLowerToParallelLoops
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LINALGLOWERTOPARALLELLOOPS
#undef GEN_PASS_DECL_LINALGLOWERTOPARALLELLOOPS
#endif // GEN_PASS_DECL_LINALGLOWERTOPARALLELLOOPS
#ifdef GEN_PASS_DEF_LINALGLOWERTOPARALLELLOOPS
namespace impl {

template <typename DerivedT>
class LinalgLowerToParallelLoopsBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LinalgLowerToParallelLoopsBase;

  LinalgLowerToParallelLoopsBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgLowerToParallelLoopsBase(const LinalgLowerToParallelLoopsBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-linalg-to-parallel-loops");
  }
  ::llvm::StringRef getArgument() const override { return "convert-linalg-to-parallel-loops"; }

  ::llvm::StringRef getDescription() const override { return "Lower the operations from the linalg dialect into parallel loops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgLowerToParallelLoops");
  }
  ::llvm::StringRef getName() const override { return "LinalgLowerToParallelLoops"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<AffineDialect>();

  registry.insert<linalg::LinalgDialect>();

  registry.insert<memref::MemRefDialect>();

  registry.insert<scf::SCFDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgLowerToParallelLoopsBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LINALGLOWERTOPARALLELLOOPS
#endif // GEN_PASS_DEF_LINALGLOWERTOPARALLELLOOPS

//===----------------------------------------------------------------------===//
// LinalgNamedOpConversion
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LINALGNAMEDOPCONVERSION
#undef GEN_PASS_DECL_LINALGNAMEDOPCONVERSION
#endif // GEN_PASS_DECL_LINALGNAMEDOPCONVERSION
#ifdef GEN_PASS_DEF_LINALGNAMEDOPCONVERSION
namespace impl {

template <typename DerivedT>
class LinalgNamedOpConversionBase : public ::mlir::OperationPass<> {
public:
  using Base = LinalgNamedOpConversionBase;

  LinalgNamedOpConversionBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgNamedOpConversionBase(const LinalgNamedOpConversionBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-named-op-conversion");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-named-op-conversion"; }

  ::llvm::StringRef getDescription() const override { return "Convert from one named linalg op to another."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgNamedOpConversion");
  }
  ::llvm::StringRef getName() const override { return "LinalgNamedOpConversion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<linalg::LinalgDialect>();

  registry.insert<tensor::TensorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgNamedOpConversionBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LINALGNAMEDOPCONVERSION
#endif // GEN_PASS_DEF_LINALGNAMEDOPCONVERSION

//===----------------------------------------------------------------------===//
// LinalgStrategyDecomposePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LINALGSTRATEGYDECOMPOSEPASS
struct LinalgStrategyDecomposePassOptions {
  std::string anchorFuncName;
};
#undef GEN_PASS_DECL_LINALGSTRATEGYDECOMPOSEPASS
#endif // GEN_PASS_DECL_LINALGSTRATEGYDECOMPOSEPASS
#ifdef GEN_PASS_DEF_LINALGSTRATEGYDECOMPOSEPASS
namespace impl {

template <typename DerivedT>
class LinalgStrategyDecomposePassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LinalgStrategyDecomposePassBase;

  LinalgStrategyDecomposePassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgStrategyDecomposePassBase(const LinalgStrategyDecomposePassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-strategy-decompose-pass");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-strategy-decompose-pass"; }

  ::llvm::StringRef getDescription() const override { return "Configurable pass to apply pattern-based generalization."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgStrategyDecomposePass");
  }
  ::llvm::StringRef getName() const override { return "LinalgStrategyDecomposePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<linalg::LinalgDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgStrategyDecomposePassBase<DerivedT>)

  LinalgStrategyDecomposePassBase(const LinalgStrategyDecomposePassOptions &options) : LinalgStrategyDecomposePassBase() {
    anchorFuncName = options.anchorFuncName;
  }
protected:
  ::mlir::Pass::Option<std::string> anchorFuncName{*this, "anchor-func", ::llvm::cl::desc("Which func op is the anchor to latch on.")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LINALGSTRATEGYDECOMPOSEPASS
#endif // GEN_PASS_DEF_LINALGSTRATEGYDECOMPOSEPASS

//===----------------------------------------------------------------------===//
// LinalgStrategyLowerVectorsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LINALGSTRATEGYLOWERVECTORSPASS
struct LinalgStrategyLowerVectorsPassOptions {
  std::string anchorFuncName;
};
#undef GEN_PASS_DECL_LINALGSTRATEGYLOWERVECTORSPASS
#endif // GEN_PASS_DECL_LINALGSTRATEGYLOWERVECTORSPASS
#ifdef GEN_PASS_DEF_LINALGSTRATEGYLOWERVECTORSPASS
namespace impl {

template <typename DerivedT>
class LinalgStrategyLowerVectorsPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LinalgStrategyLowerVectorsPassBase;

  LinalgStrategyLowerVectorsPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgStrategyLowerVectorsPassBase(const LinalgStrategyLowerVectorsPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-strategy-lower-vectors-pass");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-strategy-lower-vectors-pass"; }

  ::llvm::StringRef getDescription() const override { return "Configurable pass to lower vector operations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgStrategyLowerVectorsPass");
  }
  ::llvm::StringRef getName() const override { return "LinalgStrategyLowerVectorsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<linalg::LinalgDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgStrategyLowerVectorsPassBase<DerivedT>)

  LinalgStrategyLowerVectorsPassBase(const LinalgStrategyLowerVectorsPassOptions &options) : LinalgStrategyLowerVectorsPassBase() {
    anchorFuncName = options.anchorFuncName;
  }
protected:
  ::mlir::Pass::Option<std::string> anchorFuncName{*this, "anchor-func", ::llvm::cl::desc("Which func op is the anchor to latch on.")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LINALGSTRATEGYLOWERVECTORSPASS
#endif // GEN_PASS_DEF_LINALGSTRATEGYLOWERVECTORSPASS

//===----------------------------------------------------------------------===//
// LinalgStrategyPadPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LINALGSTRATEGYPADPASS
struct LinalgStrategyPadPassOptions {
  std::string anchorFuncName;
  std::string anchorOpName;
};
#undef GEN_PASS_DECL_LINALGSTRATEGYPADPASS
#endif // GEN_PASS_DECL_LINALGSTRATEGYPADPASS
#ifdef GEN_PASS_DEF_LINALGSTRATEGYPADPASS
namespace impl {

template <typename DerivedT>
class LinalgStrategyPadPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LinalgStrategyPadPassBase;

  LinalgStrategyPadPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgStrategyPadPassBase(const LinalgStrategyPadPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-strategy-pad-pass");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-strategy-pad-pass"; }

  ::llvm::StringRef getDescription() const override { return "Configurable pass to apply padding and hoisting."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgStrategyPadPass");
  }
  ::llvm::StringRef getName() const override { return "LinalgStrategyPadPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<linalg::LinalgDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgStrategyPadPassBase<DerivedT>)

  LinalgStrategyPadPassBase(const LinalgStrategyPadPassOptions &options) : LinalgStrategyPadPassBase() {
    anchorFuncName = options.anchorFuncName;
    anchorOpName = options.anchorOpName;
  }
protected:
  ::mlir::Pass::Option<std::string> anchorFuncName{*this, "anchor-func", ::llvm::cl::desc("Which func op is the anchor to latch on.")};
  ::mlir::Pass::Option<std::string> anchorOpName{*this, "anchor-op", ::llvm::cl::desc("Which linalg op within the func is the anchor to latch on.")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LINALGSTRATEGYPADPASS
#endif // GEN_PASS_DEF_LINALGSTRATEGYPADPASS

//===----------------------------------------------------------------------===//
// LinalgStrategyPeelPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LINALGSTRATEGYPEELPASS
struct LinalgStrategyPeelPassOptions {
  std::string anchorFuncName;
  std::string anchorOpName;
};
#undef GEN_PASS_DECL_LINALGSTRATEGYPEELPASS
#endif // GEN_PASS_DECL_LINALGSTRATEGYPEELPASS
#ifdef GEN_PASS_DEF_LINALGSTRATEGYPEELPASS
namespace impl {

template <typename DerivedT>
class LinalgStrategyPeelPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LinalgStrategyPeelPassBase;

  LinalgStrategyPeelPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgStrategyPeelPassBase(const LinalgStrategyPeelPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-strategy-peel-pass");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-strategy-peel-pass"; }

  ::llvm::StringRef getDescription() const override { return "Configurable pass to apply pattern-based linalg peeling."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgStrategyPeelPass");
  }
  ::llvm::StringRef getName() const override { return "LinalgStrategyPeelPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<linalg::LinalgDialect>();

  registry.insert<scf::SCFDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgStrategyPeelPassBase<DerivedT>)

  LinalgStrategyPeelPassBase(const LinalgStrategyPeelPassOptions &options) : LinalgStrategyPeelPassBase() {
    anchorFuncName = options.anchorFuncName;
    anchorOpName = options.anchorOpName;
  }
protected:
  ::mlir::Pass::Option<std::string> anchorFuncName{*this, "anchor-func", ::llvm::cl::desc("Which func op is the anchor to latch on.")};
  ::mlir::Pass::Option<std::string> anchorOpName{*this, "anchor-op", ::llvm::cl::desc("Which linalg op within the func is the anchor to latch on.")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LINALGSTRATEGYPEELPASS
#endif // GEN_PASS_DEF_LINALGSTRATEGYPEELPASS

//===----------------------------------------------------------------------===//
// LinalgStrategyRemoveMarkersPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LINALGSTRATEGYREMOVEMARKERSPASS
struct LinalgStrategyRemoveMarkersPassOptions {
  std::string anchorFuncName;
};
#undef GEN_PASS_DECL_LINALGSTRATEGYREMOVEMARKERSPASS
#endif // GEN_PASS_DECL_LINALGSTRATEGYREMOVEMARKERSPASS
#ifdef GEN_PASS_DEF_LINALGSTRATEGYREMOVEMARKERSPASS
namespace impl {

template <typename DerivedT>
class LinalgStrategyRemoveMarkersPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LinalgStrategyRemoveMarkersPassBase;

  LinalgStrategyRemoveMarkersPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgStrategyRemoveMarkersPassBase(const LinalgStrategyRemoveMarkersPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-strategy-remove-markers-pass");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-strategy-remove-markers-pass"; }

  ::llvm::StringRef getDescription() const override { return "Cleanup pass that drops markers."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgStrategyRemoveMarkersPass");
  }
  ::llvm::StringRef getName() const override { return "LinalgStrategyRemoveMarkersPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<linalg::LinalgDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgStrategyRemoveMarkersPassBase<DerivedT>)

  LinalgStrategyRemoveMarkersPassBase(const LinalgStrategyRemoveMarkersPassOptions &options) : LinalgStrategyRemoveMarkersPassBase() {
    anchorFuncName = options.anchorFuncName;
  }
protected:
  ::mlir::Pass::Option<std::string> anchorFuncName{*this, "anchor-func", ::llvm::cl::desc("Which func op is the anchor to latch on.")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LINALGSTRATEGYREMOVEMARKERSPASS
#endif // GEN_PASS_DEF_LINALGSTRATEGYREMOVEMARKERSPASS

//===----------------------------------------------------------------------===//
// LinalgStrategyTileAndFusePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LINALGSTRATEGYTILEANDFUSEPASS
struct LinalgStrategyTileAndFusePassOptions {
  std::string anchorFuncName;
  std::string anchorOpName;
};
#undef GEN_PASS_DECL_LINALGSTRATEGYTILEANDFUSEPASS
#endif // GEN_PASS_DECL_LINALGSTRATEGYTILEANDFUSEPASS
#ifdef GEN_PASS_DEF_LINALGSTRATEGYTILEANDFUSEPASS
namespace impl {

template <typename DerivedT>
class LinalgStrategyTileAndFusePassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LinalgStrategyTileAndFusePassBase;

  LinalgStrategyTileAndFusePassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgStrategyTileAndFusePassBase(const LinalgStrategyTileAndFusePassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-strategy-tile-and-fuse-pass");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-strategy-tile-and-fuse-pass"; }

  ::llvm::StringRef getDescription() const override { return "Configurable pass to apply pattern-based tiling and fusion."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgStrategyTileAndFusePass");
  }
  ::llvm::StringRef getName() const override { return "LinalgStrategyTileAndFusePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgStrategyTileAndFusePassBase<DerivedT>)

  LinalgStrategyTileAndFusePassBase(const LinalgStrategyTileAndFusePassOptions &options) : LinalgStrategyTileAndFusePassBase() {
    anchorFuncName = options.anchorFuncName;
    anchorOpName = options.anchorOpName;
  }
protected:
  ::mlir::Pass::Option<std::string> anchorFuncName{*this, "anchor-func", ::llvm::cl::desc("Which func op is the anchor to latch on.")};
  ::mlir::Pass::Option<std::string> anchorOpName{*this, "anchor-op", ::llvm::cl::desc("Which linalg op within the func is the anchor to latch on.")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LINALGSTRATEGYTILEANDFUSEPASS
#endif // GEN_PASS_DEF_LINALGSTRATEGYTILEANDFUSEPASS

//===----------------------------------------------------------------------===//
// LinalgStrategyTilePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LINALGSTRATEGYTILEPASS
struct LinalgStrategyTilePassOptions {
  std::string anchorFuncName;
  std::string anchorOpName;
};
#undef GEN_PASS_DECL_LINALGSTRATEGYTILEPASS
#endif // GEN_PASS_DECL_LINALGSTRATEGYTILEPASS
#ifdef GEN_PASS_DEF_LINALGSTRATEGYTILEPASS
namespace impl {

template <typename DerivedT>
class LinalgStrategyTilePassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LinalgStrategyTilePassBase;

  LinalgStrategyTilePassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgStrategyTilePassBase(const LinalgStrategyTilePassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-strategy-tile-pass");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-strategy-tile-pass"; }

  ::llvm::StringRef getDescription() const override { return "Configurable pass to apply pattern-based linalg tiling."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgStrategyTilePass");
  }
  ::llvm::StringRef getName() const override { return "LinalgStrategyTilePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<linalg::LinalgDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgStrategyTilePassBase<DerivedT>)

  LinalgStrategyTilePassBase(const LinalgStrategyTilePassOptions &options) : LinalgStrategyTilePassBase() {
    anchorFuncName = options.anchorFuncName;
    anchorOpName = options.anchorOpName;
  }
protected:
  ::mlir::Pass::Option<std::string> anchorFuncName{*this, "anchor-func", ::llvm::cl::desc("Which func op is the anchor to latch on.")};
  ::mlir::Pass::Option<std::string> anchorOpName{*this, "anchor-op", ::llvm::cl::desc("Which linalg op within the func is the anchor to latch on.")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LINALGSTRATEGYTILEPASS
#endif // GEN_PASS_DEF_LINALGSTRATEGYTILEPASS

//===----------------------------------------------------------------------===//
// LinalgStrategyVectorizePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LINALGSTRATEGYVECTORIZEPASS
struct LinalgStrategyVectorizePassOptions {
  std::string anchorFuncName;
  std::string anchorOpName;
  bool vectorizePadding = false;
};
#undef GEN_PASS_DECL_LINALGSTRATEGYVECTORIZEPASS
#endif // GEN_PASS_DECL_LINALGSTRATEGYVECTORIZEPASS
#ifdef GEN_PASS_DEF_LINALGSTRATEGYVECTORIZEPASS
namespace impl {

template <typename DerivedT>
class LinalgStrategyVectorizePassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LinalgStrategyVectorizePassBase;

  LinalgStrategyVectorizePassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgStrategyVectorizePassBase(const LinalgStrategyVectorizePassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-strategy-vectorize-pass");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-strategy-vectorize-pass"; }

  ::llvm::StringRef getDescription() const override { return "Configurable pass to apply pattern-based linalg vectorization."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgStrategyVectorizePass");
  }
  ::llvm::StringRef getName() const override { return "LinalgStrategyVectorizePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<linalg::LinalgDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgStrategyVectorizePassBase<DerivedT>)

  LinalgStrategyVectorizePassBase(const LinalgStrategyVectorizePassOptions &options) : LinalgStrategyVectorizePassBase() {
    anchorFuncName = options.anchorFuncName;
    anchorOpName = options.anchorOpName;
    vectorizePadding = options.vectorizePadding;
  }
protected:
  ::mlir::Pass::Option<std::string> anchorFuncName{*this, "anchor-func", ::llvm::cl::desc("Which func op is the anchor to latch on.")};
  ::mlir::Pass::Option<std::string> anchorOpName{*this, "anchor-op", ::llvm::cl::desc("Which linalg op within the func is the anchor to latch on.")};
  ::mlir::Pass::Option<bool> vectorizePadding{*this, "vectorize-padding", ::llvm::cl::desc("Enable vectorization of padding ops."), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LINALGSTRATEGYVECTORIZEPASS
#endif // GEN_PASS_DEF_LINALGSTRATEGYVECTORIZEPASS

//===----------------------------------------------------------------------===//
// LinalgTilingPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LINALGTILINGPASS
struct LinalgTilingPassOptions {
  ::llvm::ArrayRef<int64_t> tileSizes;
  std::string loopType = "for";
};
#undef GEN_PASS_DECL_LINALGTILINGPASS
#endif // GEN_PASS_DECL_LINALGTILINGPASS
#ifdef GEN_PASS_DEF_LINALGTILINGPASS
namespace impl {

template <typename DerivedT>
class LinalgTilingPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LinalgTilingPassBase;

  LinalgTilingPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgTilingPassBase(const LinalgTilingPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-tile");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-tile"; }

  ::llvm::StringRef getDescription() const override { return "Tile operations in the linalg dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgTilingPass");
  }
  ::llvm::StringRef getName() const override { return "LinalgTilingPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<AffineDialect>();

  registry.insert<linalg::LinalgDialect>();

  registry.insert<memref::MemRefDialect>();

  registry.insert<scf::SCFDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgTilingPassBase<DerivedT>)

  LinalgTilingPassBase(const LinalgTilingPassOptions &options) : LinalgTilingPassBase() {
    tileSizes = options.tileSizes;
    loopType = options.loopType;
  }
protected:
  ::mlir::Pass::ListOption<int64_t> tileSizes{*this, "tile-sizes", ::llvm::cl::desc("Tile sizes")};
  ::mlir::Pass::Option<std::string> loopType{*this, "loop-type", ::llvm::cl::desc("Specify the type of loops to generate: for, parallel"), ::llvm::cl::init("for")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LINALGTILINGPASS
#endif // GEN_PASS_DEF_LINALGTILINGPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// ConvertElementwiseToLinalg Registration
//===----------------------------------------------------------------------===//

inline void registerConvertElementwiseToLinalg() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createConvertElementwiseToLinalgPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertElementwiseToLinalgPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createConvertElementwiseToLinalgPass();
  });
}

//===----------------------------------------------------------------------===//
// LinalgBufferize Registration
//===----------------------------------------------------------------------===//

inline void registerLinalgBufferize() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgBufferizePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLinalgBufferizePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgBufferizePass();
  });
}

//===----------------------------------------------------------------------===//
// LinalgDetensorize Registration
//===----------------------------------------------------------------------===//

inline void registerLinalgDetensorize() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgDetensorizePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLinalgDetensorizePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgDetensorizePass();
  });
}

//===----------------------------------------------------------------------===//
// LinalgElementwiseOpFusion Registration
//===----------------------------------------------------------------------===//

inline void registerLinalgElementwiseOpFusion() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgElementwiseOpFusionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLinalgElementwiseOpFusionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgElementwiseOpFusionPass();
  });
}

//===----------------------------------------------------------------------===//
// LinalgFoldUnitExtentDims Registration
//===----------------------------------------------------------------------===//

inline void registerLinalgFoldUnitExtentDims() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgFoldUnitExtentDimsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLinalgFoldUnitExtentDimsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgFoldUnitExtentDimsPass();
  });
}

//===----------------------------------------------------------------------===//
// LinalgGeneralization Registration
//===----------------------------------------------------------------------===//

inline void registerLinalgGeneralization() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgGeneralizationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLinalgGeneralizationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgGeneralizationPass();
  });
}

//===----------------------------------------------------------------------===//
// LinalgInitTensorToAllocTensor Registration
//===----------------------------------------------------------------------===//

inline void registerLinalgInitTensorToAllocTensor() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgInitTensorToAllocTensorPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLinalgInitTensorToAllocTensorPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgInitTensorToAllocTensorPass();
  });
}

//===----------------------------------------------------------------------===//
// LinalgInlineScalarOperands Registration
//===----------------------------------------------------------------------===//

inline void registerLinalgInlineScalarOperands() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgInlineScalarOperandsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLinalgInlineScalarOperandsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgInlineScalarOperandsPass();
  });
}

//===----------------------------------------------------------------------===//
// LinalgLowerToAffineLoops Registration
//===----------------------------------------------------------------------===//

inline void registerLinalgLowerToAffineLoops() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createConvertLinalgToAffineLoopsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLinalgLowerToAffineLoopsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createConvertLinalgToAffineLoopsPass();
  });
}

//===----------------------------------------------------------------------===//
// LinalgLowerToLoops Registration
//===----------------------------------------------------------------------===//

inline void registerLinalgLowerToLoops() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createConvertLinalgToLoopsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLinalgLowerToLoopsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createConvertLinalgToLoopsPass();
  });
}

//===----------------------------------------------------------------------===//
// LinalgLowerToParallelLoops Registration
//===----------------------------------------------------------------------===//

inline void registerLinalgLowerToParallelLoops() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createConvertLinalgToParallelLoopsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLinalgLowerToParallelLoopsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createConvertLinalgToParallelLoopsPass();
  });
}

//===----------------------------------------------------------------------===//
// LinalgNamedOpConversion Registration
//===----------------------------------------------------------------------===//

inline void registerLinalgNamedOpConversion() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgNamedOpConversionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLinalgNamedOpConversionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgNamedOpConversionPass();
  });
}

//===----------------------------------------------------------------------===//
// LinalgStrategyDecomposePass Registration
//===----------------------------------------------------------------------===//

inline void registerLinalgStrategyDecomposePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgStrategyDecomposePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLinalgStrategyDecomposePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgStrategyDecomposePass();
  });
}

//===----------------------------------------------------------------------===//
// LinalgStrategyLowerVectorsPass Registration
//===----------------------------------------------------------------------===//

inline void registerLinalgStrategyLowerVectorsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgStrategyLowerVectorsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLinalgStrategyLowerVectorsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgStrategyLowerVectorsPass();
  });
}

//===----------------------------------------------------------------------===//
// LinalgStrategyPadPass Registration
//===----------------------------------------------------------------------===//

inline void registerLinalgStrategyPadPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgStrategyPadPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLinalgStrategyPadPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgStrategyPadPass();
  });
}

//===----------------------------------------------------------------------===//
// LinalgStrategyPeelPass Registration
//===----------------------------------------------------------------------===//

inline void registerLinalgStrategyPeelPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgStrategyPeelPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLinalgStrategyPeelPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgStrategyPeelPass();
  });
}

//===----------------------------------------------------------------------===//
// LinalgStrategyRemoveMarkersPass Registration
//===----------------------------------------------------------------------===//

inline void registerLinalgStrategyRemoveMarkersPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgStrategyRemoveMarkersPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLinalgStrategyRemoveMarkersPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgStrategyRemoveMarkersPass();
  });
}

//===----------------------------------------------------------------------===//
// LinalgStrategyTileAndFusePass Registration
//===----------------------------------------------------------------------===//

inline void registerLinalgStrategyTileAndFusePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgStrategyTileAndFusePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLinalgStrategyTileAndFusePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgStrategyTileAndFusePass();
  });
}

//===----------------------------------------------------------------------===//
// LinalgStrategyTilePass Registration
//===----------------------------------------------------------------------===//

inline void registerLinalgStrategyTilePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgStrategyTilePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLinalgStrategyTilePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgStrategyTilePass();
  });
}

//===----------------------------------------------------------------------===//
// LinalgStrategyVectorizePass Registration
//===----------------------------------------------------------------------===//

inline void registerLinalgStrategyVectorizePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgStrategyVectorizePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLinalgStrategyVectorizePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgStrategyVectorizePass();
  });
}

//===----------------------------------------------------------------------===//
// LinalgTilingPass Registration
//===----------------------------------------------------------------------===//

inline void registerLinalgTilingPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgTilingPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLinalgTilingPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLinalgTilingPass();
  });
}

//===----------------------------------------------------------------------===//
// Linalg Registration
//===----------------------------------------------------------------------===//

inline void registerLinalgPasses() {
  registerConvertElementwiseToLinalg();
  registerLinalgBufferize();
  registerLinalgDetensorize();
  registerLinalgElementwiseOpFusion();
  registerLinalgFoldUnitExtentDims();
  registerLinalgGeneralization();
  registerLinalgInitTensorToAllocTensor();
  registerLinalgInlineScalarOperands();
  registerLinalgLowerToAffineLoops();
  registerLinalgLowerToLoops();
  registerLinalgLowerToParallelLoops();
  registerLinalgNamedOpConversion();
  registerLinalgStrategyDecomposePass();
  registerLinalgStrategyLowerVectorsPass();
  registerLinalgStrategyPadPass();
  registerLinalgStrategyPeelPass();
  registerLinalgStrategyRemoveMarkersPass();
  registerLinalgStrategyTileAndFusePass();
  registerLinalgStrategyTilePass();
  registerLinalgStrategyVectorizePass();
  registerLinalgTilingPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class ConvertElementwiseToLinalgBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertElementwiseToLinalgBase;

  ConvertElementwiseToLinalgBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertElementwiseToLinalgBase(const ConvertElementwiseToLinalgBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-elementwise-to-linalg");
  }
  ::llvm::StringRef getArgument() const override { return "convert-elementwise-to-linalg"; }

  ::llvm::StringRef getDescription() const override { return "Convert ElementwiseMappable ops to linalg"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertElementwiseToLinalg");
  }
  ::llvm::StringRef getName() const override { return "ConvertElementwiseToLinalg"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<linalg::LinalgDialect>();

  registry.insert<memref::MemRefDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertElementwiseToLinalgBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LinalgBufferizeBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LinalgBufferizeBase;

  LinalgBufferizeBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgBufferizeBase(const LinalgBufferizeBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-bufferize");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-bufferize"; }

  ::llvm::StringRef getDescription() const override { return "Bufferize the linalg dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgBufferize");
  }
  ::llvm::StringRef getName() const override { return "LinalgBufferize"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<AffineDialect>();

  registry.insert<bufferization::BufferizationDialect>();

  registry.insert<linalg::LinalgDialect>();

  registry.insert<memref::MemRefDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgBufferizeBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LinalgDetensorizeBase : public ::mlir::OperationPass<> {
public:
  using Base = LinalgDetensorizeBase;

  LinalgDetensorizeBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgDetensorizeBase(const LinalgDetensorizeBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-detensorize");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-detensorize"; }

  ::llvm::StringRef getDescription() const override { return "Detensorize linalg ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgDetensorize");
  }
  ::llvm::StringRef getName() const override { return "LinalgDetensorize"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgDetensorizeBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> aggressiveMode{*this, "aggressive-mode", ::llvm::cl::desc("Detensorize all ops that qualify for detensoring along with branch operands and basic-block arguments."), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class LinalgElementwiseOpFusionBase : public ::mlir::OperationPass<> {
public:
  using Base = LinalgElementwiseOpFusionBase;

  LinalgElementwiseOpFusionBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgElementwiseOpFusionBase(const LinalgElementwiseOpFusionBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-fuse-elementwise-ops");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-fuse-elementwise-ops"; }

  ::llvm::StringRef getDescription() const override { return "Fuse elementwise operations on tensors"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgElementwiseOpFusion");
  }
  ::llvm::StringRef getName() const override { return "LinalgElementwiseOpFusion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<AffineDialect>();

  registry.insert<linalg::LinalgDialect>();

  registry.insert<memref::MemRefDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgElementwiseOpFusionBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LinalgFoldUnitExtentDimsBase : public ::mlir::OperationPass<> {
public:
  using Base = LinalgFoldUnitExtentDimsBase;

  LinalgFoldUnitExtentDimsBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgFoldUnitExtentDimsBase(const LinalgFoldUnitExtentDimsBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-fold-unit-extent-dims");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-fold-unit-extent-dims"; }

  ::llvm::StringRef getDescription() const override { return "Remove unit-extent dimension in Linalg ops on tensors"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgFoldUnitExtentDims");
  }
  ::llvm::StringRef getName() const override { return "LinalgFoldUnitExtentDims"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<linalg::LinalgDialect>();

  registry.insert<AffineDialect>();

  registry.insert<memref::MemRefDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgFoldUnitExtentDimsBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> foldOneTripLoopsOnly{*this, "fold-one-trip-loops-only", ::llvm::cl::desc("Only folds the one-trip loops from Linalg ops on tensors (for testing purposes only)"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class LinalgGeneralizationBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LinalgGeneralizationBase;

  LinalgGeneralizationBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgGeneralizationBase(const LinalgGeneralizationBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-generalize-named-ops");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-generalize-named-ops"; }

  ::llvm::StringRef getDescription() const override { return "Convert named ops into generic ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgGeneralization");
  }
  ::llvm::StringRef getName() const override { return "LinalgGeneralization"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<linalg::LinalgDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgGeneralizationBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LinalgInitTensorToAllocTensorBase : public ::mlir::OperationPass<> {
public:
  using Base = LinalgInitTensorToAllocTensorBase;

  LinalgInitTensorToAllocTensorBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgInitTensorToAllocTensorBase(const LinalgInitTensorToAllocTensorBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-init-tensor-to-alloc-tensor");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-init-tensor-to-alloc-tensor"; }

  ::llvm::StringRef getDescription() const override { return "Replace all init_tensor ops by alloc_tensor ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgInitTensorToAllocTensor");
  }
  ::llvm::StringRef getName() const override { return "LinalgInitTensorToAllocTensor"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgInitTensorToAllocTensorBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LinalgInlineScalarOperandsBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LinalgInlineScalarOperandsBase;

  LinalgInlineScalarOperandsBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgInlineScalarOperandsBase(const LinalgInlineScalarOperandsBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-inline-scalar-operands");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-inline-scalar-operands"; }

  ::llvm::StringRef getDescription() const override { return "Inline scalar operands into linalg generic ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgInlineScalarOperands");
  }
  ::llvm::StringRef getName() const override { return "LinalgInlineScalarOperands"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<linalg::LinalgDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgInlineScalarOperandsBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LinalgLowerToAffineLoopsBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LinalgLowerToAffineLoopsBase;

  LinalgLowerToAffineLoopsBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgLowerToAffineLoopsBase(const LinalgLowerToAffineLoopsBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-linalg-to-affine-loops");
  }
  ::llvm::StringRef getArgument() const override { return "convert-linalg-to-affine-loops"; }

  ::llvm::StringRef getDescription() const override { return "Lower the operations from the linalg dialect into affine loops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgLowerToAffineLoops");
  }
  ::llvm::StringRef getName() const override { return "LinalgLowerToAffineLoops"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<AffineDialect>();

  registry.insert<linalg::LinalgDialect>();

  registry.insert<memref::MemRefDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgLowerToAffineLoopsBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LinalgLowerToLoopsBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LinalgLowerToLoopsBase;

  LinalgLowerToLoopsBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgLowerToLoopsBase(const LinalgLowerToLoopsBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-linalg-to-loops");
  }
  ::llvm::StringRef getArgument() const override { return "convert-linalg-to-loops"; }

  ::llvm::StringRef getDescription() const override { return "Lower the operations from the linalg dialect into loops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgLowerToLoops");
  }
  ::llvm::StringRef getName() const override { return "LinalgLowerToLoops"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<linalg::LinalgDialect>();

  registry.insert<scf::SCFDialect>();

  registry.insert<AffineDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgLowerToLoopsBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LinalgLowerToParallelLoopsBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LinalgLowerToParallelLoopsBase;

  LinalgLowerToParallelLoopsBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgLowerToParallelLoopsBase(const LinalgLowerToParallelLoopsBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-linalg-to-parallel-loops");
  }
  ::llvm::StringRef getArgument() const override { return "convert-linalg-to-parallel-loops"; }

  ::llvm::StringRef getDescription() const override { return "Lower the operations from the linalg dialect into parallel loops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgLowerToParallelLoops");
  }
  ::llvm::StringRef getName() const override { return "LinalgLowerToParallelLoops"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<AffineDialect>();

  registry.insert<linalg::LinalgDialect>();

  registry.insert<memref::MemRefDialect>();

  registry.insert<scf::SCFDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgLowerToParallelLoopsBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LinalgNamedOpConversionBase : public ::mlir::OperationPass<> {
public:
  using Base = LinalgNamedOpConversionBase;

  LinalgNamedOpConversionBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgNamedOpConversionBase(const LinalgNamedOpConversionBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-named-op-conversion");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-named-op-conversion"; }

  ::llvm::StringRef getDescription() const override { return "Convert from one named linalg op to another."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgNamedOpConversion");
  }
  ::llvm::StringRef getName() const override { return "LinalgNamedOpConversion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<linalg::LinalgDialect>();

  registry.insert<tensor::TensorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgNamedOpConversionBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LinalgStrategyDecomposePassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LinalgStrategyDecomposePassBase;

  LinalgStrategyDecomposePassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgStrategyDecomposePassBase(const LinalgStrategyDecomposePassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-strategy-decompose-pass");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-strategy-decompose-pass"; }

  ::llvm::StringRef getDescription() const override { return "Configurable pass to apply pattern-based generalization."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgStrategyDecomposePass");
  }
  ::llvm::StringRef getName() const override { return "LinalgStrategyDecomposePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<linalg::LinalgDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgStrategyDecomposePassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> anchorFuncName{*this, "anchor-func", ::llvm::cl::desc("Which func op is the anchor to latch on.")};
};

template <typename DerivedT>
class LinalgStrategyLowerVectorsPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LinalgStrategyLowerVectorsPassBase;

  LinalgStrategyLowerVectorsPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgStrategyLowerVectorsPassBase(const LinalgStrategyLowerVectorsPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-strategy-lower-vectors-pass");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-strategy-lower-vectors-pass"; }

  ::llvm::StringRef getDescription() const override { return "Configurable pass to lower vector operations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgStrategyLowerVectorsPass");
  }
  ::llvm::StringRef getName() const override { return "LinalgStrategyLowerVectorsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<linalg::LinalgDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgStrategyLowerVectorsPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> anchorFuncName{*this, "anchor-func", ::llvm::cl::desc("Which func op is the anchor to latch on.")};
};

template <typename DerivedT>
class LinalgStrategyPadPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LinalgStrategyPadPassBase;

  LinalgStrategyPadPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgStrategyPadPassBase(const LinalgStrategyPadPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-strategy-pad-pass");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-strategy-pad-pass"; }

  ::llvm::StringRef getDescription() const override { return "Configurable pass to apply padding and hoisting."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgStrategyPadPass");
  }
  ::llvm::StringRef getName() const override { return "LinalgStrategyPadPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<linalg::LinalgDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgStrategyPadPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> anchorFuncName{*this, "anchor-func", ::llvm::cl::desc("Which func op is the anchor to latch on.")};
  ::mlir::Pass::Option<std::string> anchorOpName{*this, "anchor-op", ::llvm::cl::desc("Which linalg op within the func is the anchor to latch on.")};
};

template <typename DerivedT>
class LinalgStrategyPeelPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LinalgStrategyPeelPassBase;

  LinalgStrategyPeelPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgStrategyPeelPassBase(const LinalgStrategyPeelPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-strategy-peel-pass");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-strategy-peel-pass"; }

  ::llvm::StringRef getDescription() const override { return "Configurable pass to apply pattern-based linalg peeling."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgStrategyPeelPass");
  }
  ::llvm::StringRef getName() const override { return "LinalgStrategyPeelPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<linalg::LinalgDialect>();

  registry.insert<scf::SCFDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgStrategyPeelPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> anchorFuncName{*this, "anchor-func", ::llvm::cl::desc("Which func op is the anchor to latch on.")};
  ::mlir::Pass::Option<std::string> anchorOpName{*this, "anchor-op", ::llvm::cl::desc("Which linalg op within the func is the anchor to latch on.")};
};

template <typename DerivedT>
class LinalgStrategyRemoveMarkersPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LinalgStrategyRemoveMarkersPassBase;

  LinalgStrategyRemoveMarkersPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgStrategyRemoveMarkersPassBase(const LinalgStrategyRemoveMarkersPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-strategy-remove-markers-pass");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-strategy-remove-markers-pass"; }

  ::llvm::StringRef getDescription() const override { return "Cleanup pass that drops markers."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgStrategyRemoveMarkersPass");
  }
  ::llvm::StringRef getName() const override { return "LinalgStrategyRemoveMarkersPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<linalg::LinalgDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgStrategyRemoveMarkersPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> anchorFuncName{*this, "anchor-func", ::llvm::cl::desc("Which func op is the anchor to latch on.")};
};

template <typename DerivedT>
class LinalgStrategyTileAndFusePassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LinalgStrategyTileAndFusePassBase;

  LinalgStrategyTileAndFusePassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgStrategyTileAndFusePassBase(const LinalgStrategyTileAndFusePassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-strategy-tile-and-fuse-pass");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-strategy-tile-and-fuse-pass"; }

  ::llvm::StringRef getDescription() const override { return "Configurable pass to apply pattern-based tiling and fusion."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgStrategyTileAndFusePass");
  }
  ::llvm::StringRef getName() const override { return "LinalgStrategyTileAndFusePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgStrategyTileAndFusePassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> anchorFuncName{*this, "anchor-func", ::llvm::cl::desc("Which func op is the anchor to latch on.")};
  ::mlir::Pass::Option<std::string> anchorOpName{*this, "anchor-op", ::llvm::cl::desc("Which linalg op within the func is the anchor to latch on.")};
};

template <typename DerivedT>
class LinalgStrategyTilePassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LinalgStrategyTilePassBase;

  LinalgStrategyTilePassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgStrategyTilePassBase(const LinalgStrategyTilePassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-strategy-tile-pass");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-strategy-tile-pass"; }

  ::llvm::StringRef getDescription() const override { return "Configurable pass to apply pattern-based linalg tiling."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgStrategyTilePass");
  }
  ::llvm::StringRef getName() const override { return "LinalgStrategyTilePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<linalg::LinalgDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgStrategyTilePassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> anchorFuncName{*this, "anchor-func", ::llvm::cl::desc("Which func op is the anchor to latch on.")};
  ::mlir::Pass::Option<std::string> anchorOpName{*this, "anchor-op", ::llvm::cl::desc("Which linalg op within the func is the anchor to latch on.")};
};

template <typename DerivedT>
class LinalgStrategyVectorizePassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LinalgStrategyVectorizePassBase;

  LinalgStrategyVectorizePassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgStrategyVectorizePassBase(const LinalgStrategyVectorizePassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-strategy-vectorize-pass");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-strategy-vectorize-pass"; }

  ::llvm::StringRef getDescription() const override { return "Configurable pass to apply pattern-based linalg vectorization."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgStrategyVectorizePass");
  }
  ::llvm::StringRef getName() const override { return "LinalgStrategyVectorizePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<linalg::LinalgDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgStrategyVectorizePassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> anchorFuncName{*this, "anchor-func", ::llvm::cl::desc("Which func op is the anchor to latch on.")};
  ::mlir::Pass::Option<std::string> anchorOpName{*this, "anchor-op", ::llvm::cl::desc("Which linalg op within the func is the anchor to latch on.")};
  ::mlir::Pass::Option<bool> vectorizePadding{*this, "vectorize-padding", ::llvm::cl::desc("Enable vectorization of padding ops."), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class LinalgTilingPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LinalgTilingPassBase;

  LinalgTilingPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgTilingPassBase(const LinalgTilingPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("linalg-tile");
  }
  ::llvm::StringRef getArgument() const override { return "linalg-tile"; }

  ::llvm::StringRef getDescription() const override { return "Tile operations in the linalg dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgTilingPass");
  }
  ::llvm::StringRef getName() const override { return "LinalgTilingPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<AffineDialect>();

  registry.insert<linalg::LinalgDialect>();

  registry.insert<memref::MemRefDialect>();

  registry.insert<scf::SCFDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgTilingPassBase<DerivedT>)

protected:
  ::mlir::Pass::ListOption<int64_t> tileSizes{*this, "tile-sizes", ::llvm::cl::desc("Tile sizes")};
  ::mlir::Pass::Option<std::string> loopType{*this, "loop-type", ::llvm::cl::desc("Specify the type of loops to generate: for, parallel"), ::llvm::cl::init("for")};
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
